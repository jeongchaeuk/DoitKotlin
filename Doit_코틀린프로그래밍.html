<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    .red {
      color: red
    }

    .material-icons {
      display: inline-flex;
      vertical-align: middle;
    }

    .float {
      position: fixed;
      width: 60px;
      height: 60px;
      bottom: 30px;
      right: 30px;
      background-color: royalblue;
      color: #FFF;
      border-radius: 30px;
      text-align: center;
    }

    .my-float {
      /* margin-top: 5px; */
      font-size: 3.5rem;
    }

    pre {
      margin: .25rem;
      border-radius: .5rem;
      padding: .25rem .5rem;
      font-size: .9rem;
      background-color: #073042;
      color: whitesmoke;
      width: fit-content;
    }

    .madang,
    .center {
      text-align: center;
    }

    .madang_number {
      font-size: 0.75em;
      color: tomato;
      text-decoration-line: underline;
    }

    h1>.titleNumber {
      color: white;
      background-color: tomato;
      padding: .25rem .5rem;
      margin-right: .5rem;
    }

    h2.title {
      border-width: 1px;
      border-bottom-style: dashed
    }

    h2>.titleNumber,
    h3.title {
      color: tomato;
      margin-right: .5rem;
    }

    ul.roundBox {
      border: 1px solid lightgray;
      border-radius: 0.5em;
      padding: .5rem 2rem;
    }

    table,
    th,
    td {
      border-collapse: collapse;
      border: 1px solid gray;
      padding: 0.25em;
    }

    table.noneLine,
    table .noneLine {
      border-collapse: collapse;
      border: 1px none;
      padding: 0.25em;
      margin: 0.25em;
      background-color: #EEE;
    }

    th {
      background-color: lightgray;
    }

    span.title {
      background-color: red;
      padding: 0.1rem 0.25em;
    }

    strong {
      background-color: goldenrod;
      padding: 0.1em 0.2rem;
      border-radius: 1rem;
      font-weight: bolder;
      color: black;
    }

    pre>strong {
      font-family: monospace;
    }

    kbd {
      border: 1px solid gray;
      border-radius: 10%;
      padding: 0.25em;
      background-color: lightgray;
      box-shadow: .05rem .05rem black;
    }

    img {
      max-width: 100%;
      height: auto;
    }

    a {
      text-decoration: none;
      border-bottom: 1px solid lightgray;
      padding-bottom: .1rem;
      cursor: pointer;
      color: inherit
    }

    a:hover {
      border-bottom: 1px solid black;
    }

    li {
      margin-top: .25rem;
    }

    .number {
      font-family: D2Coding;
    }
  </style>
  <title>Kotlin programming</title>
</head>

<body>
  <a href="#end" class="float">
    <span class="material-icons my-float">
      arrow_circle_down
    </span>
  </a>
  <h1 class="madang"><span class="madang_number">첫째 마당</span><br>Kotlin<br>기본 익히기</h1>
  <h1><span class="titleNumber">01</span>시작하기</h1>
  <h2 class="title"><span class="titleNumber">01-1</span> 탄생 배경</h2>
  <h3 class="title">소개합니다</h3>
  <p>IntelliJ IDEA라는 통합 개발 환경으로 유명한 JetBrains에서 개발했다.<br>
  <ul>
    <li><a href="https://kotlinlang.org/" target="_blank">Kotlinlang.org</a></li>
    <li><a href="https://github.com/JetBrains/kotlin/" target="_blank">Github Kotlin</a></li>
  </ul>
  </p>
  종류
  <ul>
    <li>Kotlin/JVM : Java 가상 Machine에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/JS : Javascript로 web browser에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/Native : LLVM compiler를 이용하여 여러 platform을 target으로 하는 application을 만들 수 있다.</li>
  </ul>
  사용 환경
  <ul>
    <li>Apple iOS (arm32, arm64, emulator x86_64)</li>
    <li>Apple Mac OS(x86_64)</li>
    <li>Android (arm32, arm64)</li>
    <li>Windows (MinGW x86_64)</li>
    <li>Linux (x86_64, arm32, MIPS, MIPS litter-endian)</li>
    <li>Web 전용(wasm32)</li>
  </ul>
  Java와 완벽하게 호환된다.
  <h3 class="title">장점</h3>
  <ul>
    <li>Compiled 자료형을 검사하여 확정하는 정적 언어로 자료형 오류를 초기에 발견할 수 있다.</li>
    <li>NPE <sub>Null pointer exception</sub>로 인한 program의 중단을 예방할 수 있다.</li>
    <li>아주 간결하고 효율적이다.</li>
    <li>함수형 programming과 객체 지향 programming이 모두 가능하다.</li>
    <li>';' 을 생략할 수도 있다.</li>
  </ul>
  <h3 class="title">Android 공식 언어로 채택된 Kotlin</h3>
  <h4>JDK 들</h4>
  <ul>
    <li><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank">Oracle JDK</a></li>
    <li><a href="https://openjdk.java.net/" target="_blank">Open JDK</a></li>
    <li><a href="https://www.azul.com/" target="_blank">Zulu</a></li>
  </ul>
  <h3 class="title">IntelliJ IDEA 설치하기</h3>
  <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ IDEA 2021.1.1 (211.7142.45 build)</a>
  <h2 class="title"><span class="titleNumber">01-3</span> Kotlin project 시작하기</h2>
  <h3 class="title">Kotlin project 만들기</h3>
  <h4>Hellokotlin project 만들기</h4>
  <img src="images/creatNewProject.png" width="582" height="414" alt="Create New Project" title="새 project 생성하기"><br>
  <img src="images/newProject.png" width="925" height="686" alt="New Project" title="Kotlin/JVM project 선택"><br>
  <img src="images/newProject2.png" width="952" height="423" alt="New Project2" title="Kotlin/JVM project 선택 2"><br>
  <img src="images/newProject3.png" width="735" height="197" alt="New Project3" title="Kotlin/JVM project 선택 3"><br>
  <img src="images/newProject4.png" width="334" height="261" alt="New Project4" title="Kotlin/JVM project 선택 4"><br>
  HelloKotlin.kt
  <pre>
fun main() {
  println("Hello Kotlin!")
}</pre>
  <code>Run > Run > HelloKotlinKt > Run</code> menu를 선택해서 실행한다.
  <pre>
// 결과
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Hello Kotlin!

Process finished with exit code 0</pre>
  <h3 class="title">Project 하나씩 뜯어보기</h3>
  <h4>Kotlin의 <code>main()</code> 함수는 program의 실행 진입점</h4>
  <ul>
    <li>Kotlin code는 JVM에서 실행되며, <code>main()</code> 함수가 있는 file 이름을 기준으로 Java class가 자동 생성된다.</li>
    <li>자동 생성된 class는 <code>Tools > Kotlin > Show Kotlin Bytecode</code>에서 <code>Decompile</code>(역compile) button을 누르면 확인할 수 있다.</li>
  </ul>
  <pre>
// compiler의 version에 따라 다를 수 있다. 
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

@Metadata(
    mv = {1, 5, 1},
    k = 2,
    d1 = {"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"},
    d2 = {"main", "", "args", "", "", "([Ljava/lang/String;)V", "HelloKotlin.main"}
)
public final class HelloKotlinKt {
    public static final void main(@NotNull String[] args) {
      Intrinsics.checkNotNullParameter(args, "args");
      String var1 = "Hello Kotlin!";
      boolean var2 = false;
      System.out.println(var1);
    }
}</pre>
  <h4>Program의 memory 영역</h4>
  <table>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
    <tr>
      <th>Code</th>
      <td>명령어가 저장된다.</td>
    </tr>
    <tr>
      <th>Data</th>
      <td>문자열, 정적 변수등이 저장된다. Method Static Area, 정적 memory 영역, literal pool</td>
    </tr>
    <tr>
      <th>Heap</th>
      <td>실행 중 생성되는 객체들이 저장된다. <span class="material-icons">arrow_downward</span> 아래쪽 방향으로 증가, 동적 memory 영역</td>
    </tr>
    <tr>
      <th>Stack</th>
      <td>지역 변수나 함수 호출 정보(매개변수)가 저장된다. <span class="material-icons">arrow_upward</span>위쪽 방향으로 증가</td>
    </tr>
  </table>
  <span class="material-icons">info</span><code>Garbage Collection</code> : JVM은 더 이상 참조하지 않는 객체들을 자동으로 memory에서 삭제해준다.
  <h4>Kotlin의 <code>main()</code> method에서 매개변수를 사용할 경우</h4>
  <code>main()</code>에 전달할 외부의 인자들을 가리키고, 명령행에서 입력받은 값들이 차례대로 배열에 저장된다.<br>
  <pre>
fun main(<strong>args: Array&lt;String></strong>) {
  for (str in args) {
      println(str)
  }
}</pre>
  <code>Run > Edit Configurations... > Program arguments</code> 에 'Good 안녕 123'을 입력한다.
  <pre>
// 실행 결과 화면
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Good
안녕
123

Process finished with exit code 0</pre>
  <hr>
  <h1><span class="titleNumber">02</span>변수와 자료형, 연산자</h1>
  <h2 class="title"><span class="titleNumber">02-1</span>코틀린 패키지</h2>
  Kotlin에서 Project는 Module, Package, File로 구성된다.
  <h3 class="title">Project, Module, Package, File의 관계 이해하기</h3>
  <ul>
    <li style="list-style: none;">HelloKotlin (Project)
      <ul>
        <li>HelloKotlin (Module 1)
          <ul>
            <li>default (Package)
              <ul>
                <li>HelloKotlin.kt (File)</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>OtherModule (Module 2)</li>
      </ul>
    </li>
  </ul>
  <ul>
    <li>default package는 src folder에 따로 package 이름을 지정하지 않은 file들이 포함된다.</li>
    <li>Kotlin file은 .kt 확장자를 가지며 compiler가 알 수 있도록 file의 맨 위에는 이 file이 속한 package 이름을 선언해야 한다.</li>
    <li>그렇지 않으면 자동으로 <strong>default</strong> package에 포함된다.</li>
    <li>file이 package folder 안에 있어도 package 이름을 선언하지 않으면 default package에 포함된 것으로 인식한다.</li><br>
    <li>File에 1개의 class가 정의되어 있다면 project 창 화면에 .kt 확장자가 빠진 class 이름만 보인다.</li>
    <li>File에 여러 개의 class를 정의한다면 file은 단순히 class를 묶는 역할을 하고 .kt 확장자가 붙게 된다.</li>
    <li>Kotlin에서는 file 이름과 class의 선언 개수에 큰 의미를 두지 않는다.</li>
    <li>같은 file에 들어 있는 class들은 모두 그 file에 지정한 package로 인식한다.</li>
    <li>Kotlin은 Java처럼 class 이름과 file 이름이 같아야 하고, plublic class는 하나만 사용해야 하는 규칙이 <strong>없다</strong>.</li>
  </ul>
  <h4>Package를 만들어야 하는 이유</h4>
  같은 이름의 file이라도 package가 다르면 다른 file로 인식되어 중복 오류가 발생하지 않는다.
  <h3 class="title">Kotlin project에 package 만들기</h3>
  <h4>Package 이름 정하기</h4>
  <ul>
    <li>이름은 file 첫 줄에 적는다.</li>
    <li><code><strong>package</strong></code> keyword를 앞에 붙인다.</li>
    <li>이름은 특수문자나 숫자로 시작하면 안된다.</li>
    <li>여러 단계의 분류가 필요하면 <strong>.</strong> 을 붙여 이름을 짓는다.</li>
  </ul>
  예) <code><strong>package com.acaroom.net.upload</strong></code>
  <h3 class="title">기본 package 활용하기</h3>
  <ul>
    <li>기본 package는 자주 사용하는 class와 함수 등을 미리 만들어 놓은 것이다.</li>
    <li><code><strong>import</strong></code> keyword로 package를 선언하지 않아도 바로 사용할 수 있다.</li>
  </ul>
  <table>
    <caption>기본 package</caption>
    <tr>
      <th>이름</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>kotlin.*</code></td>
      <td><code>Any, Int, Double</code> 등 핵심 함수와 자료형</td>
    </tr>
    <tr>
      <td><code>kotlin.text.*</code></td>
      <td>문자와 관련된 API</td>
    </tr>
    <tr>
      <td><code>kotlin.sequences.*</code></td>
      <td>Collection 자료형의 하나로 반복이 허용되는 개체를 열거</td>
    </tr>
    <tr>
      <td><code>kotlin.ranges.*</code></td>
      <td><code>if</code> 문이나 <code>for</code> 문에서 사용할 범위 관련 요소</td>
    </tr>
    <tr>
      <td><code>kotlin.io.*</code></td>
      <td>입출력 관련 API</td>
    </tr>
    <tr>
      <td><code>kotlin.collections.*</code></td>
      <td><code>List, Set, Map</code> 등의 collection</td>
    </tr>
    <tr>
      <td><code>kotlin.annotation.*</code></td>
      <td>주석 관련 API</td>
    </tr>
  </table>
  <sub>별표(*)는 해당 package에 포함된 모든 요소를 의미한다.</sub>
  <h4>IntelliJ 단축키</h4>
  <ul>
    <li style="line-height: 1.5rem;"><kbd>Ctr</kbd> + <kbd>B</kbd> : 선택한 class나 함수의 source file을 찾아 보여준다.</li>
    <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F10</kbd> : 현재 file 실행하기</li>
  </ul>
  <h3 class="title">사용자 class 가져오기</h3>
  <pre>
package com.example.edu.Person

class Person(val name: String, val age: Int) { ... }</pre>
  <pre>
package chap02.section1

// 같은 이름의 class가 있을 때 as 로 별명을 지정 할 수 있다.
<strong>import</strong> com.example.edu.Person <strong>as</strong> <span style="color:gold;">User</span>

fun main(args: Array&lt;String&gt;) {
    val user1 = <span style="color:gold;">User</span>("Kildong", 30)
    println(user1.name)
    println(user1.age)

    // 이 package에 선언된 Person
    val user2 = Person("A123", "Kildong") 
    println(user2.id)
    println(user2.name)
}

class Person(val id: String, val name: String) { ... }</pre>
  <h2 class="title"><span class="titleNumber">02-2</span>변수와 자료형</h2>
  <h3 class="title">변수를 선언하고 자료형 추론하기</h3>
  <ul>
    <li><code><strong>val</strong></code>ue : 읽기 전용, 변경 불가 변수</li>
    <li><strong><code>var</code></strong>iable : 변경 가능 변수</li>
  </ul>
  <h4>변수 이름 짓기 규칙</h4>
  <ul>
    <li>영문자, 숫자, _ 만 사용할 수 있다.</li>
    <li>숫자로 시작할 수 없다.</li>
    <li>keyword는 사용할 수 없다.</li>
    <li>여러 단어로 구성된 이름은 소문자로 시작하는 낙타표기법을 사용하면 좋다.<br>
      예) <code>lowerCamelCase</code></li>
  </ul>
  <h4>변수를 선언하는 방법</h4>
  <table>
    <tr>
      <th>방법</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>val username: String = "Kildong"</code></td>
      <td>선언 keyword 변수이름: 자료형 = 값</td>
    </tr>
    <tr>
      <td><code>val username = "Kildong"</code></td>
      <td>초기화 값을 보고 자료형을 추론한다.
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> : 추론한 자료형을 알려준다.
      </td>
    </tr>
    <tr>
      <td><code>val username</code></td>
      <td><span class="material-icons red">warning</span> 초기값이 없어서 자료형을 추론하지 못한다.</td>
    </tr>
    <tr>
      <td><code>val username: String</code></td>
      <td>이런 경우 자료형을 반드시 지정해야 한다.</td>
    </tr>
  </table>
  <h3 class="title">자료형 알아보기</h3>
  <h4>Kotlin의 자료형은 <strong>참조형</strong>을 사용한다</h4>
  <ul>
    <li>Primitive Data Type (기본형)</li>
    <li>Reference Type (참조형)<br>
      객체를 생성하고 heap<sub>(동적 memory 영역)</sub>에 data를 저장한 후 이것을 참조하는 자료형.<br>
      <small>(* Kotlin에서 참조형은 성능 최적화를 위해 컴파일러에서 다시 기본형으로 대체된다.)</small>
    </li>
  </ul>
  <h4>기본형과 참조형의 동작 원리</h4>
  Java에서 기본형은 stack에 값이 저장되고 참조형은 참조하는 객체가 heap에 저장되고 그 주소가 stack에 저장된다.
  <h4>정수 자료형</h4>
  <table class="center">
    <caption>부호가 있는 정수 자료형<sub>signed</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">정수 자료형</td>
      <td><code>Byte</code></td>
      <td>8</td>
      <td>-2<sup> 7</sup> ~ 2<sup> 7</sup>-1</td>
    </tr>
    <tr>
      <td><code>Short</code></td>
      <td>16</td>
      <td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>
    </tr>
    <tr>
      <td><code>Int</code></td>
      <td>32</td>
      <td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>
    </tr>
    <tr>
      <td><code>Long</code></td>
      <td>64</td>
      <td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>
    </tr>
  </table>
  <pre>
val a = 123               // 10진수 표현
val b = 123<strong>L</strong>	          // Long 형으로 추론
val c = <strong>0x</strong>0F	          // 16진수 표현
val d = <strong>0b</strong>00001111	  // 2진수 표현</pre>
  보통 숫자값은 <code>Int</code>형으로 추론되기 때문에 좀 더 작은 범위의 정수 자료형인 <code>Byte</code>형이나 <code>Short</code>형을 사용하기 위해서는 <strong>직접</strong> 자료형을 명시해야 한다.
  <p />
  <table class="center">
    <caption>부호가 없는 정수 자료형<sub>unsigned</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">부호 없는<br>정수 자료형</td>
      <td><code>UByte</code></td>
      <td>8</td>
      <td>0 ~ 2<sup> 8</sup>-1</td>
    </tr>
    <tr>
      <td><code>UShort</code></td>
      <td>16</td>
      <td>0 ~ 2<sup>16</sup>-1</td>
    </tr>
    <tr>
      <td><code>UInt</code></td>
      <td>32</td>
      <td>0 ~ 2<sup>32</sup>-1</td>
    </tr>
    <tr>
      <td><code>ULong</code></td>
      <td>64</td>
      <td>0 ~ 2<sup>64</sup>-1</td>
    </tr>
  </table><br>
  부호 없는 자료형에는 <strong>u</strong> 식별자를 사용해야 한다. 없으면 값을 할당할 수 없다.<br>
  <pre>
val a: UInt = 153<strong>u</strong>
val b: ULong = 46322342<strong>uL</strong></pre><br>
  <strong>_</strong>로 자리값을 구분할 수 있다. 값에 영향을 주지 않는다.
  <pre>
val million = 1_000_000
val cardNumber = 1234_1234_1234_1234
val hexVal = 0xAB_CD_EF_12
val binary = 0b1010_0101</pre>
  <h4>실수 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="2">실수 자료형</td>
      <td><code>Float</code></td>
      <td>32</td>
      <td>약 1.4E<sup>-45</sup> ~ 3.4E<sup>+38</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
    <tr>
      <td><code>Double</code></td>
      <td>64</td>
      <td>약 4.9E<sup>-324</sup> ~ 1.7E<sup>+308</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
  </table>
  <ul>
    <li>실수도 자료형을 명시하지 않으면 <code>Double</code>형으로 추론된다.</li>
    <li><code>Float</code>형으로 지정하고 싶다면 식별자 <strong>F</strong>를 값 뒤에 붙이면 된다.</li>
  </ul>
  <pre>
val a = 3.14	// Double형으로 추론. 기본
val b = 3.14<strong>F</strong>	// Float형으로 추론.</pre>
  <table>
    <tr>
      <th>일반 수학의 표현</th>
      <th>Source code상의 표현</th>
    </tr>
    <tr>
      <td>3.14<sub>가수</sub> x 10<sub>밑수</sub><sup>16<sub>지수</sub></sup></td>
      <td>3.14<sub>(소수점이 없을 수도 있다.)</sub>E<sub>(또는 e)</sub> +<sub>(- 또는 +, +는 생략 가능)</sub> 16</td>
    </tr>
  </table>
  <pre>
val exp1 = 3.14E-2 // 0.0314
val exp2 = 3.14e2  // 314
</pre>
  <h4>부동 소수점 제대로 이해하기<small>(IEEE 754 표준)</small></h4>
  <p><span class="material-icons red" style="float:left">info</span>지수부에 저장되는 값은 <strong>(지수 bias + 실제 지수 값)</strong> 이다.<br>
  <sub>값이 2의 보수로 저장 되는데 이 때 음수값의 비교를 쉽게 하기위해 지수 bias를 적용해 양수값으로 저장되게 한다.</sub></p>
  <table class="center number">
    <caption>32 bits Float (지수 bias : 2<sup>7</sup>-1 = 127)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 8 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 23 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>31</td>
      <td>30...23</td>
      <td>22...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b00000001 ~ 0b11111110 : 실제 지수값 범위: -126 ~ 127</li>
          <li>0b11111111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table><br>
  <table class="center number">
    <caption>64 bits Float (지수 bias : 2<sup>10</sup>-1 = 1023)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 11 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 52 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>63</td>
      <td>62...52</td>
      <td>51...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b00000000001 ~ 0b11111111110 : 실제 지수값 범위: -1022 ~ 1023</li>
          <li>0b11111111111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table>
  <h4>정수값을 2진수로 표현하기</h4>
  <ul>
    <li>정수값을 2로 나누어 나머지를 취한다.</li>
    <li>몫을 다음 정수값으로 사용한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>나머지</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>10 ÷ 2 = 5, 0</td>
      <td>0</td>
      <td rowspan="4">low<br><span class="material-icons">arrow_upward</span><br>hi</td>
    </tr>
    <tr>
      <td>5 ÷ 2 = 2, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2 ÷ 2 = 1, 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1 ÷ 2 = 0, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10<sub>10</sub></th>
      <th colspan="2">1010<sub>2</sub></th>
    </tr>
  </table><br>
  <h4>소수값을 2진수로 표현하기</h4>
  <ul>
    <li>소수값에 2를 곱한 결과값에서 정수 부분을 취한다.</li>
    <li>다음 소수값은 이 정수 값을 뺀 값으로 한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>정수부</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>0.375 x 2 = 0.75</td>
      <td>0</td>
      <td rowspan="3">hi<br><span class="material-icons">arrow_downward</span><br>low</td>
    </tr>
    <tr>
      <td>(0.75 - 0) x 2 = 1.5</td>
      <td>1</td>
    </tr>
    <tr>
      <td>(1.5 - 1) x 2 = 1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0.375<sub>10</sub></th>
      <th colspan="2">0.011<sub>2</sub></th>
    </tr>
  </table><br>
  <span class="material-icons red">info</span>정수부는 항상 1이 되게 정규화한 후 값을 저장한다.
  <pre>
예) -12.375<sub>10</sub>를 32bits의 float 형식으로 표현하면 음수이므로 부호 bit는 1이고,
절댓값 12.375<sub>10</sub>의 2진수는 1100.011<sub>2</sub>이다.
이 값을 정수부가 항상 1이 되게 정규화 하면 1.100011 x 2<sup>3</sup>이 된다.
항상 1인 정수부를 제외한 소수부 100011<sub>2</sub>만 가수부에 저장한다. 뒤쪽엔 0으로 채운다.
지수부는 (3 + 127<sub>지수 bias 값</sub>)인 130<sub>10</sub>의 2진수인 10000010<sub>2</sub>를 저장한다.
<div style="font-size: 1.5rem;">
<span style="background:#a11; padding:.3rem">1</span><span style="background:#191; padding:.3rem">10000010</span><span style="background:#77f; padding:.3rem">10001100000000000000000</span>
</div>
</pre>
  <h4>정수 자료형과 실수 자료형의 최솟값과 최댓값 알아보기</h4>
  각 자료형에 <span class="title">MIN_VALUE, MAX_VALUE</span> 상수가 정의되어 있다.
  <h4>2의 보수</h4>
  <table>
    <caption>음수는 2의 보수로 표현한다.</caption>
    <tr>
      <td>0b0000_0001</td>
      <td>+1</td>
    </tr>
    <tr>
      <td>0b1111_1110</td>
      <td>1의 보수는 각 비트를 반대로 하면 된다.</td>
    </tr>
    <tr>
      <td>0b1111_1111</td>
      <td>1의 보수에 +1를 하면 2의 보수가 된다. -1</td>
    </tr>
  </table>
  <small>(* 컴퓨터는 뺄셈을 2의 보수와의 합으로 계산한다.)</small>
  <h4>논리 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>논리 자료형</td>
      <td>Boolean</td>
      <td>8</td>
      <td>true, false</td>
    </tr>
  </table>
  <pre>
val isOpen = true
val isUploaded: Boolean</pre>
  <h4>문자 자료형</h4>
  문자를 ' '로 감싸 표현한다.
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>문자 자료형</td>
      <td>Char</td>
      <td>16</td>
      <td>0 ~ 2<sup>15</sup>-1 (\u0000 ~ \uffff)</td>
    </tr>
  </table>
  <pre>    val ch = 'c'
    val ch: Char</pre>









  <h2 class="title"><span class="titleNumber">02-3</span>자료형 검사하고 변환하기</h2>
  <h2 class="title"><span class="titleNumber">02-4</span>코틀린 연산자</h2>
  <h1><span class="titleNumber">03</span>함수와 함수형 프로그래밍</h1>
  <h2 class="title"><span class="titleNumber">03-1</span></h2>
  <h2 class="title"><span class="titleNumber">03-2</span></h2>
  <h2 class="title"><span class="titleNumber">03-3</span></h2>
  <h2 class="title"><span class="titleNumber">03-4</span></h2>
  <h2 class="title"><span class="titleNumber">03-5</span></h2>
  <h2 class="title"><span class="titleNumber">03-6</span></h2>
  <h1><span class="titleNumber">04</span>프로그램의 흐름 제어</h1>
  <h2 class="title"><span class="titleNumber">04-1</span></h2>
  <h2 class="title"><span class="titleNumber">04-2</span></h2>
  <h2 class="title"><span class="titleNumber">04-3</span></h2>

  <p id="end">END</p>
</body>

</html>
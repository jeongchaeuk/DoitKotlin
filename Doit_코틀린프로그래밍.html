<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    .red {
      color: red
    }

    .mb-0 {
      margin-bottom: 0;
    }

    .mt-0 {
      margin-top: 0;
    }

    .bg-lg {
      background-color: lightgray;
    }

    .bg-ws {
      background-color: whitesmoke;
    }

    .color-on-board {
      color: #0f0;
      font-weight: bolder;
      font-style: italic;
      font-size: 1rem;
    }

    .material-icons {
      display: inline-flex;
      vertical-align: middle;
    }

    .float {
      position: fixed;
      width: 4rem;
      height: 4rem;
      bottom: 2rem;
      right: 2rem;
      background-color: blueviolet;
      color: #FFF;
      border-radius: 2rem;
      text-align: center;
      box-shadow: 1px 1px 2px gray;
    }

    .my-float {
      font-size: 4rem;
    }

    pre {
      margin: .25rem;
      border-radius: .5rem;
      padding: .25rem .5rem;
      font-size: .9rem;
      background-color: #073042;
      color: lightgray;
      width: fit-content;
    }

    strong {
      background-color: goldenrod;
      padding: 0rem .25rem;
      border-radius: .25rem;
      color: black;
      display: inline-flex;
      font-size: .9rem;
    }

    pre>strong {
      font-family: monospace;
    }

    .madang,
    .center {
      text-align: center;
    }

    .madang_number {
      font-size: 0.75em;
      color: tomato;
      text-decoration-line: underline;
    }

    h1>.titleNumber {
      color: white;
      background-color: tomato;
      padding: .25rem .5rem;
      margin-right: .5rem;
    }

    h2.title {
      border-width: 1px;
      border-bottom-style: dashed
    }

    h2>.titleNumber,
    h3.title {
      color: tomato;
      margin-right: .5rem;
    }

    ul.roundBox {
      border: 1px solid lightgray;
      border-radius: 0.5em;
      padding: .5rem 2rem;
    }

    table,
    th,
    td {
      border-collapse: collapse;
      border: 1px solid gray;
      padding: 0.25em;
    }

    table.noneLine,
    table .noneLine {
      border-collapse: collapse;
      border: 1px none;
      padding: 0.25em;
      margin: 0.25em;
      background-color: #EEE;
    }

    th {
      background-color: lightgray;
    }

    span.title {
      background-color: red;
      padding: 0.1rem 0.25em;
    }

    kbd {
      border: 1px solid gray;
      border-radius: .25rem;
      padding: 0.25em;
      background-color: lightgray;
      box-shadow: .05rem .05rem black;
    }

    img {
      max-width: 100%;
      height: auto;
    }

    a {
      text-decoration: none;
      border-bottom: 1px solid lightgray;
      padding-bottom: .1rem;
      cursor: pointer;
      color: inherit
    }

    a:hover {
      border-bottom: 1px solid black;
    }

    .number {
      font-family: D2Coding;
    }

    h4 {
      margin-bottom: .5rem;
    }

    .no-border {
      border: none;
    }

    table.no-border td {
      border: none;
    }

    table.no-border .border {
      border: 1px solid black;
    }

    code {
      font-size: 1rem;
      background-color: lightgray;
      padding: 0 .25rem;
      border-radius: 0.25rem;
    }
  </style>
  <title>Kotlin programming</title>
</head>

<body>
  <a href="#end" class="float">
    <span class="material-icons my-float">
      arrow_circle_down
    </span>
  </a>
  <h1 class="madang"><span class="madang_number">첫째 마당</span><br>Kotlin<br>기본 익히기</h1>
  <h1><span class="titleNumber">01</span>시작하기</h1>
  <h2 class="title"><span class="titleNumber">01-1</span> 탄생 배경</h2>
  <h3 class="title">소개합니다</h3>
  <p>IntelliJ IDEA라는 통합 개발 환경으로 유명한 JetBrains에서 개발했다.<br>
  <ul>
    <li><a href="https://kotlinlang.org/" target="_blank">Kotlinlang.org</a></li>
    <li><a href="https://github.com/JetBrains/kotlin/" target="_blank">Github Kotlin</a></li>
  </ul>
  </p>
  종류
  <ul>
    <li>Kotlin/JVM : Java 가상 Machine에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/JS : Javascript로 web browser에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/Native : LLVM compiler를 이용하여 여러 platform을 target으로 하는 application을 만들 수 있다.</li>
  </ul>
  사용 환경
  <ul>
    <li>Apple iOS (arm32, arm64, emulator x86_64)</li>
    <li>Apple Mac OS(x86_64)</li>
    <li>Android (arm32, arm64)</li>
    <li>Windows (MinGW x86_64)</li>
    <li>Linux (x86_64, arm32, MIPS, MIPS litter-endian)</li>
    <li>Web 전용(wasm32)</li>
  </ul>
  Java와 완벽하게 호환된다.
  <h3 class="title">장점</h3>
  <ul>
    <li>Compiled 자료형을 검사하여 확정하는 정적 언어로 자료형 오류를 초기에 발견할 수 있다.</li>
    <li>NPE <sub>Null pointer exception</sub>로 인한 program의 중단을 예방할 수 있다.</li>
    <li>아주 간결하고 효율적이다.</li>
    <li>함수형 programming과 객체 지향 programming이 모두 가능하다.</li>
    <li>';' 을 생략할 수도 있다.</li>
  </ul>
  <h3 class="title">Android 공식 언어로 채택된 Kotlin</h3>
  <h4>JDK 들</h4>
  <ul>
    <li><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank">Oracle JDK</a></li>
    <li><a href="https://openjdk.java.net/" target="_blank">Open JDK</a></li>
    <li><a href="https://www.azul.com/" target="_blank">Zulu</a></li>
  </ul>
  <h3 class="title">IntelliJ IDEA 설치하기</h3>
  <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ IDEA 2021.1.1 (211.7142.45 build)</a>
  <h2 class="title"><span class="titleNumber">01-3</span> Kotlin project 시작하기</h2>
  <h3 class="title">Kotlin project 만들기</h3>
  <h4>Hellokotlin project 만들기</h4>
  <img src="images/creatNewProject.png" width="582" height="414" alt="Create New Project" title="새 project 생성하기"><br>
  <img src="images/newProject.png" width="925" height="686" alt="New Project" title="Kotlin/JVM project 선택"><br>
  <img src="images/newProject2.png" width="952" height="423" alt="New Project2" title="Kotlin/JVM project 선택 2"><br>
  <img src="images/newProject3.png" width="735" height="197" alt="New Project3" title="Kotlin/JVM project 선택 3"><br>
  <img src="images/newProject4.png" width="334" height="261" alt="New Project4" title="Kotlin/JVM project 선택 4"><br>
  HelloKotlin.kt
  <pre>
fun main() {
  println("Hello Kotlin!")
}</pre>
  <code>Run > Run > HelloKotlinKt > Run</code> menu를 선택해서 실행한다.
  <pre>
// 결과
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Hello Kotlin!

Process finished with exit code 0</pre>
  <h3 class="title">Project 하나씩 뜯어보기</h3>
  <h4>Kotlin의 <code>main()</code> 함수는 program의 실행 진입점</h4>
  <ul>
    <li>Kotlin code는 JVM에서 실행되며, <code>main()</code> 함수가 있는 file 이름을 기준으로 Java class가 자동 생성된다.</li>
    <li>자동 생성된 class는 <code>Tools > Kotlin > Show Kotlin Bytecode</code>에서 <code>Decompile</code>(역compile) button을 누르면 확인할 수 있다.</li>
  </ul>
  <pre>
// compiler의 version에 따라 다를 수 있다. 
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

@Metadata(
    mv = {1, 5, 1},
    k = 2,
    d1 = {"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"},
    d2 = {"main", "", "args", "", "", "([Ljava/lang/String;)V", "HelloKotlin.main"}
)
public final class HelloKotlinKt {
    public static final void main(@NotNull String[] args) {
      Intrinsics.checkNotNullParameter(args, "args");
      String var1 = "Hello Kotlin!";
      boolean var2 = false;
      System.out.println(var1);
    }
}</pre>
  <h4>Program의 memory 영역</h4>
  <table>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
    <tr>
      <th>Code</th>
      <td>명령어가 저장된다.</td>
    </tr>
    <tr>
      <th>Data</th>
      <td>문자열, 정적 변수등이 저장된다. Method Static Area, 정적 memory 영역, literal pool</td>
    </tr>
    <tr>
      <th>Heap</th>
      <td>실행 중 생성되는 객체들이 저장된다. <span class="material-icons">arrow_downward</span> 아래쪽 방향으로 증가, 동적 memory 영역</td>
    </tr>
    <tr>
      <th>Stack</th>
      <td>지역 변수나 함수 호출 정보(매개변수)가 저장된다. <span class="material-icons">arrow_upward</span>위쪽 방향으로 증가</td>
    </tr>
  </table>
  <span class="material-icons">info</span><code>Garbage Collection</code> : JVM은 더 이상 참조하지 않는 객체들을 자동으로 memory에서 삭제해준다.
  <h4>Kotlin의 <code>main()</code> method에서 매개변수를 사용할 경우</h4>
  <code>main()</code>에 전달할 외부의 인자들을 가리키고, 명령행에서 입력받은 값들이 차례대로 배열에 저장된다.<br>
  <pre>
fun main(<strong>args: Array&lt;String></strong>) {
  for (str in args) {
      println(str)
  }
}</pre>
  <code>Run > Edit Configurations... > Program arguments</code> 에 'Good 안녕 123'을 입력한다.
  <pre>
// 실행 결과 화면
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Good
안녕
123

Process finished with exit code 0</pre>
  <hr>
  <h1><span class="titleNumber">02</span>변수와 자료형, 연산자</h1>
  <h2 class="title"><span class="titleNumber">02-1</span>코틀린 패키지</h2>
  Kotlin에서 Project는 Module, Package, File로 구성된다.
  <h3 class="title">Project, Module, Package, File의 관계 이해하기</h3>
  <ul>
    <li style="list-style: none;">HelloKotlin (Project)
      <ul>
        <li>HelloKotlin (Module 1)
          <ul>
            <li>default (Package)
              <ul>
                <li>HelloKotlin.kt (File)</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>OtherModule (Module 2)</li>
      </ul>
    </li>
  </ul>
  <ul>
    <li>default package는 src folder에 따로 package 이름을 지정하지 않은 file들이 포함된다.</li>
    <li>Kotlin file은 .kt 확장자를 가지며 compiler가 알 수 있도록 file의 맨 위에는 이 file이 속한 package 이름을 선언해야 한다.</li>
    <li>그렇지 않으면 자동으로 <strong>default</strong> package에 포함된다.</li>
    <li>file이 package folder 안에 있어도 package 이름을 선언하지 않으면 default package에 포함된 것으로 인식한다.</li><br>
    <li>File에 1개의 class가 정의되어 있다면 project 창 화면에 .kt 확장자가 빠진 class 이름만 보인다.</li>
    <li>File에 여러 개의 class를 정의한다면 file은 단순히 class를 묶는 역할을 하고 .kt 확장자가 붙게 된다.</li>
    <li>Kotlin에서는 file 이름과 class의 선언 개수에 큰 의미를 두지 않는다.</li>
    <li>같은 file에 들어 있는 class들은 모두 그 file에 지정한 package로 인식한다.</li>
    <li>Kotlin은 Java처럼 class 이름과 file 이름이 같아야 하고, plublic class는 하나만 사용해야 하는 규칙이 <strong>없다</strong>.</li>
  </ul>
  <h4>Package를 만들어야 하는 이유</h4>
  같은 이름의 file이라도 package가 다르면 다른 file로 인식되어 중복 오류가 발생하지 않는다.
  <h3 class="title">Kotlin project에 package 만들기</h3>
  <h4>Package 이름 정하기</h4>
  <ul>
    <li>이름은 file 첫 줄에 적는다.</li>
    <li><code><strong>package</strong></code> keyword를 앞에 붙인다.</li>
    <li>이름은 특수문자나 숫자로 시작하면 안된다.</li>
    <li>여러 단계의 분류가 필요하면 <strong>.</strong> 을 붙여 이름을 짓는다.</li>
  </ul>
  예) <code><strong>package com.acaroom.net.upload</strong></code>
  <h3 class="title">기본 package 활용하기</h3>
  <ul>
    <li>기본 package는 자주 사용하는 class와 함수 등을 미리 만들어 놓은 것이다.</li>
    <li><code><strong>import</strong></code> keyword로 package를 선언하지 않아도 바로 사용할 수 있다.</li>
  </ul>
  <table>
    <caption>기본 package</caption>
    <tr>
      <th>이름</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>kotlin.*</code></td>
      <td><code>Any, Int, Double</code> 등 핵심 함수와 자료형</td>
    </tr>
    <tr>
      <td><code>kotlin.text.*</code></td>
      <td>문자와 관련된 API</td>
    </tr>
    <tr>
      <td><code>kotlin.sequences.*</code></td>
      <td>Collection 자료형의 하나로 반복이 허용되는 개체를 열거</td>
    </tr>
    <tr>
      <td><code>kotlin.ranges.*</code></td>
      <td><code>if</code> 문이나 <code>for</code> 문에서 사용할 범위 관련 요소</td>
    </tr>
    <tr>
      <td><code>kotlin.io.*</code></td>
      <td>입출력 관련 API</td>
    </tr>
    <tr>
      <td><code>kotlin.collections.*</code></td>
      <td><code>List, Set, Map</code> 등의 collection</td>
    </tr>
    <tr>
      <td><code>kotlin.annotation.*</code></td>
      <td>주석 관련 API</td>
    </tr>
  </table>
  <sub>별표(*)는 해당 package에 포함된 모든 요소를 의미한다.</sub>
  <h4>IntelliJ 단축키</h4>
  <ul>
    <li style="line-height: 1.5rem;"><kbd>Ctr</kbd> + <kbd>B</kbd> : 선택한 class나 함수의 source file을 찾아 보여준다.</li>
    <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F10</kbd> : 현재 file 실행하기</li>
  </ul>
  <h3 class="title">사용자 class 가져오기</h3>
  <pre>
package com.example.edu.Person

class Person(val name: String, val age: Int) { ... }</pre>
  <pre>
package chap02.section1

// 같은 이름의 class가 있을 때 as 로 별명을 지정 할 수 있다.
<strong>import</strong> com.example.edu.Person <strong>as</strong> <span style="color:gold;">User</span>

fun main(args: Array&lt;String&gt;) {
    val user1 = <span style="color:gold;">User</span>("Kildong", 30)
    println(user1.name)
    println(user1.age)

    // 이 package에 선언된 Person
    val user2 = Person("A123", "Kildong") 
    println(user2.id)
    println(user2.name)
}

class Person(val id: String, val name: String) { ... }</pre>
  <h2 class="title"><span class="titleNumber">02-2</span>변수와 자료형</h2>
  <h3 class="title">변수를 선언하고 자료형 추론하기</h3>
  <ul>
    <li><code><strong>val</strong></code>ue : 읽기 전용, 변경 불가 변수</li>
    <li><strong><code>var</code></strong>iable : 변경 가능 변수</li>
  </ul>
  <h4>변수 이름 짓기 규칙</h4>
  <ul>
    <li>영문자, 숫자, _ 만 사용할 수 있다.</li>
    <li>숫자로 시작할 수 없다.</li>
    <li>keyword는 사용할 수 없다.</li>
    <li>여러 단어로 구성된 이름은 소문자로 시작하는 낙타표기법을 사용하면 좋다.<br>
      예) <code>lowerCamelCase</code></li>
  </ul>
  <h4>변수를 선언하는 방법</h4>
  <table>
    <tr>
      <th>방법</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>val username: String = "Kildong"</code></td>
      <td>선언 keyword 변수이름: 자료형 = 값</td>
    </tr>
    <tr>
      <td><code>val username = "Kildong"</code></td>
      <td>초기화 값을 보고 자료형을 추론한다.
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> : 추론한 자료형을 알려준다.
      </td>
    </tr>
    <tr>
      <td><code>val username</code></td>
      <td><span class="material-icons red">warning</span> 초기값이 없어서 자료형을 추론하지 못한다.</td>
    </tr>
    <tr>
      <td><code>val username: String</code></td>
      <td>이런 경우 자료형을 반드시 지정해야 한다.</td>
    </tr>
  </table>
  <h3 class="title">자료형 알아보기</h3>
  <h4>Kotlin의 자료형은 <strong>참조형</strong>을 사용한다</h4>
  <ul>
    <li>Primitive Data Type (기본형)</li>
    <li>Reference Type (참조형)<br>
      객체를 생성하고 heap<sub>(동적 memory 영역)</sub>에 data를 저장한 후 이것을 참조하는 자료형.<br>
      <small>(* Kotlin에서 참조형은 성능 최적화를 위해 컴파일러에서 다시 기본형으로 대체된다.)</small>
    </li>
  </ul>
  <h4>기본형과 참조형의 동작 원리</h4>
  Java에서 기본형은 stack에 값이 저장되고 참조형은 참조하는 객체가 heap에 저장되고 그 주소가 stack에 저장된다.
  <h4>정수 자료형</h4>
  <table class="center">
    <caption>부호가 있는 정수 자료형<sub>signed</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">정수 자료형</td>
      <td><code>Byte</code></td>
      <td>8</td>
      <td>-2<sup> 7</sup> ~ 2<sup> 7</sup>-1</td>
    </tr>
    <tr>
      <td><code>Short</code></td>
      <td>16</td>
      <td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>
    </tr>
    <tr>
      <td><code>Int</code></td>
      <td>32</td>
      <td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>
    </tr>
    <tr>
      <td><code>Long</code></td>
      <td>64</td>
      <td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>
    </tr>
  </table>
  <pre>
val a = 123               // 10진수 표현
val b = 123<strong>L</strong>	          // Long 형으로 추론
val c = <strong>0x</strong>0F	          // 16진수 표현
val d = <strong>0b</strong>00001111	  // 2진수 표현</pre>
  보통 숫자값은 <code>Int</code>형으로 추론되기 때문에 좀 더 작은 범위의 정수 자료형인 <code>Byte</code>형이나 <code>Short</code>형을 사용하기 위해서는 <strong>직접</strong> 자료형을 명시해야 한다.
  <p />
  <table class="center">
    <caption>부호가 없는 정수 자료형<sub>unsigned</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">부호 없는<br>정수 자료형</td>
      <td><code>UByte</code></td>
      <td>8</td>
      <td>0 ~ 2<sup> 8</sup>-1</td>
    </tr>
    <tr>
      <td><code>UShort</code></td>
      <td>16</td>
      <td>0 ~ 2<sup>16</sup>-1</td>
    </tr>
    <tr>
      <td><code>UInt</code></td>
      <td>32</td>
      <td>0 ~ 2<sup>32</sup>-1</td>
    </tr>
    <tr>
      <td><code>ULong</code></td>
      <td>64</td>
      <td>0 ~ 2<sup>64</sup>-1</td>
    </tr>
  </table><br>
  부호 없는 자료형에는 <strong>u</strong> 식별자를 사용해야 한다. 없으면 값을 할당할 수 없다.<br>
  <pre>
val a: UInt = 153<strong>u</strong>
val b: ULong = 46322342<strong>uL</strong></pre><br>
  <strong>_</strong>로 자리값을 구분할 수 있다. 값에 영향을 주지 않는다.
  <pre>
val million = 1_000_000
val cardNumber = 1234_1234_1234_1234
val hexVal = 0xAB_CD_EF_12
val binary = 0b1010_0101</pre>
  <h4>실수 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="2">실수 자료형</td>
      <td><code>Float</code></td>
      <td>32</td>
      <td>약 1.4E<sup>-45</sup> ~ 3.4E<sup>+38</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
    <tr>
      <td><code>Double</code></td>
      <td>64</td>
      <td>약 4.9E<sup>-324</sup> ~ 1.7E<sup>+308</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
  </table>
  <ul>
    <li>실수도 자료형을 명시하지 않으면 <code>Double</code>형으로 추론된다.</li>
    <li><code>Float</code>형으로 지정하고 싶다면 식별자 <strong>F</strong>를 값 뒤에 붙이면 된다.</li>
  </ul>
  <pre>
val a = 3.14	// Double형으로 추론. 기본
val b = 3.14<strong>F</strong>	// Float형으로 추론.</pre>
  <table>
    <tr>
      <th>일반 수학의 표현</th>
      <th>Source code상의 표현</th>
    </tr>
    <tr>
      <td>3.14<sub>가수</sub> x 10<sub>밑수</sub><sup>16<sub>지수</sub></sup></td>
      <td>3.14<sub>(소수점이 없을 수도 있다.)</sub>E<sub>(또는 e)</sub> +<sub>(- 또는 +, +는 생략 가능)</sub> 16</td>
    </tr>
  </table>
  <pre>
val exp1 = 3.14E-2 // 0.0314
val exp2 = 3.14e2  // 314
</pre>
  <h4>부동 소수점 제대로 이해하기<small>(IEEE 754 표준)</small></h4>
  <p><span class="material-icons red" style="float:left">info</span>지수부에 저장되는 값은 <strong>(지수 bias + 실제 지수 값)</strong> 이다.<br>
    <sub>값이 2의 보수로 저장 되는데 이 때 음수값의 비교를 쉽게 하기위해 지수 bias를 적용해 양수값으로 저장되게 한다.</sub>
  </p>
  <table class="center number">
    <caption>32 bits Float (지수 bias : 2<sup>7</sup>-1 = 127)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 8 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 23 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>31</td>
      <td>30...23</td>
      <td>22...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b0000_0001 ~ 0b1111_1110 : 실제 지수값 범위: -126 ~ 127</li>
          <li>0b1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table><br>
  <table class="center number">
    <caption>64 bits Float (지수 bias : 2<sup>10</sup>-1 = 1023)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 11 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 52 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>63</td>
      <td>62...52</td>
      <td>51...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b000_0000_0001 ~ 0b111_1111_1110 : 실제 지수값 범위: -1022 ~ 1023</li>
          <li>0b111_1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table>
  <h4>정수값을 2진수로 표현하기</h4>
  <ul>
    <li>정수값을 2로 나누어 나머지를 취한다.</li>
    <li>몫을 다음 정수값으로 사용한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>나머지</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>10 ÷ 2 = 5, 0</td>
      <td>0</td>
      <td rowspan="4">low<br><span class="material-icons">arrow_upward</span><br>hi</td>
    </tr>
    <tr>
      <td>5 ÷ 2 = 2, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2 ÷ 2 = 1, 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1 ÷ 2 = 0, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10<sub>10</sub></th>
      <th colspan="2">1010<sub>2</sub></th>
    </tr>
  </table><br>
  <h4>소수값을 2진수로 표현하기</h4>
  <ul>
    <li>소수값에 2를 곱한 결과값에서 정수 부분을 취한다.</li>
    <li>다음 소수값은 이 정수 값을 뺀 값으로 한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>정수부</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>0.375 x 2 = 0.75</td>
      <td>0</td>
      <td rowspan="3">hi<br><span class="material-icons">arrow_downward</span><br>low</td>
    </tr>
    <tr>
      <td>(0.75 - 0) x 2 = 1.5</td>
      <td>1</td>
    </tr>
    <tr>
      <td>(1.5 - 1) x 2 = 1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0.375<sub>10</sub></th>
      <th colspan="2">0.011<sub>2</sub></th>
    </tr>
  </table><br>
  <span class="material-icons red">info</span>정수부는 항상 1이 되게 정규화한 후 값을 저장한다.
  <pre>
예) -12.375<sub>10</sub>를 32bits의 float 형식으로 표현하면 음수이므로 부호 bit는 1이고,
절댓값 12.375<sub>10</sub>의 2진수는 1100.011<sub>2</sub>이다.
이 값을 정수부가 항상 1이 되게 정규화 하면 1.100011 x 2<sup>3</sup>이 된다.
항상 1인 정수부를 제외한 소수부 100011<sub>2</sub>만 가수부에 저장한다. 뒤쪽엔 0으로 채운다.
지수부는 (3 + 127<sub>지수 bias 값</sub>)인 130<sub>10</sub>의 2진수인 10000010<sub>2</sub>를 저장한다.
<div style="font-size: 1.5rem;">
<span style="background:#a11; padding:.3rem">1</span><span style="background:#191; padding:.3rem">10000010</span><span style="background:#77f; padding:.3rem">10001100000000000000000</span>
</div>
</pre><br>
  부동소수점을 사용할 때는 오차에 주의해야 한다.
  <pre>
fun main() {
  var num = 0.0
  for (i in 1..10)
      num += 0.1

  println(num) // 0.9999999999999999 <span class="material-icons red">warning</span>1.0이 아니다!
}</pre>
  <h4>정수 자료형과 실수 자료형의 최솟값과 최댓값 알아보기</h4>
  각 자료형에 <strong><code>MIN_VALUE, MAX_VALUE</code></strong> 상수가 정의되어 있다.
  <h4>2의 보수</h4>
  <table class="number">
    <caption>음수는 2의 보수로 표현한다.</caption>
    <tr>
      <th>0b0000_0001</th>
      <td>+1</td>
    </tr>
    <tr>
      <th>0b1111_1110</th>
      <td>1의 보수는 각 bit를 반대로 하면 된다.</td>
    </tr>
    <tr>
      <th>0b1111_1111</th>
      <td>1의 보수에 +1를 하면 2의 보수가 된다. -1</td>
    </tr>
  </table>
  <small>(* 컴퓨터는 뺄셈을 2의 보수와의 합으로 계산한다.)</small>
  <h4>논리 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>논리 자료형</td>
      <td>Boolean</td>
      <td>1<sub>Java에서</sub></td>
      <td>true, false</td>
    </tr>
  </table>
  <pre>
val isOpen = true       // Boolean으로 추론
val isUploaded: Boolean // 선언만 한 경우 자료형을 반드시 명시</pre>
  <h4>문자 자료형</h4>
  문자를 작은따옴표(')로 감싸 표현한다.
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>문자 자료형</td>
      <td>Char</td>
      <td>16</td>
      <td>0 ~ 2<sup>15</sup>-1 (\u0000 ~ \uffff)</td>
    </tr>
  </table>
  <pre>
val ch = 'A'
val ch1: Char

println(ch + 1) // 'B'

val ch2: Char = 65 // error!

val code: Int = 65
val ch3 = code.<strong>toChar()</strong> // 'A'

val ch4 = '<strong>\u</strong>D55C' // unicode '한'
</pre>
  <h3 class="title">문자열 자료형(<strong>String</strong>) 알아보기</h3>
  문자 자료형인 Char은 기본형으로 처리되지만, 문자열 자료형은 기본형에 속하지 않는 배열 형태로 되어 있는 특수한 자료형이다.<br>
  <h4>문자열 자료형 선언과 저장 방식 이해하기</h4>
  <pre>
fun main() {
  val str1: String = "Hello"
  val str2 = "World"
  val str3 = "Hello"

  // === : 참조 비교. 객체의 주소를 비교한다.
  println("str1 === str2 is ${str1 === str2}")
  println("str1 === str3 is ${str1 === str3}")
}
<hr>>>
str1 === str2 is false
str1 === str3 is true</pre>
  <table>
    <tr>
      <table style="background-color:lightgray;text-align: center; border-collapse: separate;">
        <caption style="caption-side: bottom;">Heap</caption>
        <tr>
          <td style="border:none">
            <table style="border:none">
              <caption style="caption-side: bottom">&nbsp;</caption>
              <tr>
                <th style="border:none">A1<span class="material-icons">arrow_forward</span></th>
              </tr>
              <tr>
                <th style="border:none">A2<span class="material-icons">arrow_forward</span></th>
              </tr>
            </table>
          </td>
          <td>
            <table>
              <tr>
                <table style="background-color:whitesmoke;width:7rem; border-collapse: separate; border:1px dashed black">
                  <tr>
                    <td style="background-color: gray;">Hello</td>
                  </tr>
                  <tr>
                    <td style="background-color: gray;">World</td>
                  </tr>
                  <tr>
                    <td style="width:fit-content; border:none;">String Pool</td>
                  </tr>
                </table>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </tr><br>
    <tr>
      <table style="border: none;">
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str3</td>
        </tr>
        <tr>
          <td>주소: A2</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str2</td>
        </tr>
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str1</td>
        </tr>
        <tr>
          <td style="text-align: center; border:none">Stack</td>
          <td style="border:none"></td>
        </tr>
      </table>
    </tr>
  </table>
  String 형 선언 및 할당에 사용되는 memory는 <strong>String Pool</strong>이다.<br>
  <h4>표현식과 <strong><code>$</code></strong> 기호 사용하여 문자열 출력하기</h4>
  <pre>
val a = 1
val s1 = "a is <strong>$a</strong>"             // a is 1
val s2 = "(a + 1) is <strong>${a + 1}</strong>" // (a + 1) is 2</pre>
  변수가 아니라 표현식을 문자열에 포함하려면 <strong><code>{}</code></strong> 를 사용한다.<br>
  Escape 문자 <strong><code>\</code></strong>를 사용해 문자열 안에 ", $를 표시할 수 있다.
  <pre>
val str = "<strong>\"</strong>hello\", I have <strong>\$</strong>15"
val str2 = "${'"'}hello${'"'}, I have ${'$'}15"
<hr>>>
"hello", I have $15
</pre>
  <h4>형식화된 다중 문자열 사용하기</h4>
  <pre>
val str5 = <strong>"""</strong>
    abc
        abc
            abc<strong>"""</strong>
println(str5)
<hr>>

    abc
        abc
            abc</pre>

  <h4>자료형에 별명 붙이기</h4>
  <pre>
<strong>typealias</strong> UserName = String
val userName: UserName = "Peter"</pre>
  <h2 class="title"><span class="titleNumber">02-3</span>자료형 검사하고 변환하기</h2>
  <ul>
    <li>변수를 사용할 때 반드시 값이 할당되어 있어야 한다.</li>
    <li>값이 없는 상태를 <strong>null</strong> 이라고 한다.</li>
    <li>null 상태인 변수를 허용하려면 <strong>?</strong>를 사용해 선언한다.<br>
      이 변수를 사용하려면 null을 검사하고 처리하는 방법을 고려해야 한다.</li>
  </ul>
  <h3 class="title">null을 허용한 변수 검사하기</h3>
  프로그램 실행 중 값이 null인 변수에 접근하면 NPE<sub>(Null Point Exception)</sub> 예외 오류가 발생한다.
  <h4>변수에 null 할당하기</h4>
  <pre>
fun main() {
  var str: String = "Hello"
  str = null // <span class="red">Error!</span>
  
  var str2: String<strong>?</strong> = "World"
  str2 = null // <span style="color:#0f0">OK</span>
}</pre>
  <h4>Safe call(<strong>?.</strong>)과 non-null 단정 기호(<strong>!!.</strong>)를 활용하여 null을 허용한 변수 사용하기</h4>
  <ul>
    <li>Safe call : null일 수 있는 변수를 검사하여 안전하게 호출할 수 있도록 도와준다.
      <pre>
// str2가 유효한 문자열이면 문자열의 길이, str2가 null 이면 null을 return 한다.
val length = str2<strong>?.</strong>length</pre>
    </li>
    <li>non-null 단정 : compile 때 null 검사를 하지 않는다. 하지만 값이 null 이면 실행시에 NPE가 발생한다.</li>
  </ul>
  <h4>조건문을 활용해 null을 허용한 변수 검사하기</h4>
  <pre>val length = if (str2 != null) str2.length else -1</pre>
  <h4>Safe call과 Elvis 연산자(<strong>?:</strong>)를 활용해 null을 허용한 변수 더 안전하게 사용하기</h4>
  <pre>val length = str2?.length <strong>?:</strong> -1</pre>
  <h3 class="title">자료형 비교하고 검사하고 변환하기</h3>
  자료형이 서로 다른 변수를 비교하거나 연산할 수 없다.
  <h4>자료형 변환</h4>
  <pre>
val a: Int = 1
val b: Double = a // <span class="red">Type mismatch error!</span>
val c: Int = 1.1  // <span class="red">Type mismatch error!</span>

// 변환 method 사용
val d: Double = a.toDouble() // <span style="color:#0f0">OK</span>

// 표현식에서는 자료형이 표현할 수 있는 범위가 큰 자료형으로 자동 형 변환하여 연산한다.
val result = 1L + 3 // Long형 + Int형 -> result는 Long형
</pre>
  자료형 변환 method 들
  <ul style="margin-top:0">
    <li>toByte: Byte</li>
    <li>toLong: Long</li>
    <li>toShort: Short</li>
    <li>toInt: Int</li>
    <li>toFloat: Float</li>
    <li>toDouble: Double</li>
    <li>toChar: Char</li>
  </ul>
  <h4>기본형과 참조형 자료형의 비교 원리</h4>
  <ul>
    <li>구조적 동등성(Structural equality). equals()를 이용한 비교
      <ul>
        <li>==, !=</li>
        <li>a == b 는 다음으로 해석된다.
          <pre>a?.equals(b) ?: (b === null)</pre>
        </li>
        <li>a가 null이 아니면 equals(Any?) 함수를 호출하고, null이면 b가 null인지 참조 동등성을 검사한다.</li>
        <li>a == null은 명시적으로 a === null로 자동으로 변환된다.</li>
        <li>사용자 정의로 같음을 구현하려면 <strong><code>open operator fun equals(other: Any?): Boolean</code></strong>를 overriding 하면된다.</li>
        <li>Comparable&lt;...> interface에서 정의된 비교와는 상관 없다.</li>
      </ul>
    </li>
    <li>참조 동등성(Referential equality). 두 개의 참조가 같은 객체를 가리키는지 비교
      <ul>
        <li>===, !==</li>
        <li>a === b는 a와 b가 같은 객체를 가리킬 때만 true이다.</li>
        <li>기본형의 === 비교는 == 비교와 같다.</li>
      </ul>
    </li>
  </ul>
  <span class="material-icons red" style="float:left">info</span>저장되는 값이 -128~127 사이의 값이면 cache에 저장되어 참조된다.<br>
  이 경우 기본형이 stack에 값으로 저장되지 않고 값이 저장된 cache의 주소를 참조하게 된다.
  <h4>Smart Cast 알아보기</h4>
  <ul>
    <li>Compiler가 자동으로 형 변환을 해주는 것이다.</li>
    <li><strong>Number</strong> 자료형에 적용된다.
      <pre>
fun main() {
  val a: <strong>Number</strong> = 3.14

  println(a is Number) // true
  println(a is Double) // true
  println(a is Float)  // false
}</pre>
    </li>
  </ul>
  <h4>자료형 검사하기 <strong>is, !is</strong></h4>
  is는 변수의 자료형을 검사한 다음 그 변수를 해당 자료형으로 변환하는 기능도 있다.
  <pre>
fun main() {
  val x: <strong>Any</strong> // 임의의 자료형
  x = "Hello"

  if (x <strong>is</strong> String) {
      println(x.length) // x는 String으로 smart cast 된다.
  }
}</pre>
  <h4><strong>as</strong>에 의한 Smart Cast</h4>
  as는 형 변환이 불가능하면 예외를 발생시킨다.
  <pre>
// y가 null 이거나 String으로 형 변환이 불가능하면 예외 발생.
val x: String = y as String 

// y가 null 이거나 String으로 형 변환이 불가능하면 null을 return.
val x: String<strong>?</strong> = y <strong>as?</strong> String</pre>
  <h4>묵시적 변환</h4>
  <ul>
    <li><strong>open class Any</strong>는 최상위 class 이다.</li>
    <li>Any형은 자료형이 특별히 정해지지 않은 경우에 사용한다.</li>
    <li>Any형은 무엇이든 될 수 있기 때문에 언제든 필요한 자료형으로 자동 변환할 수 있다.(묵시적 변환)</li>
    <li></li>
  </ul>
  <pre>
fun main() {
  var a: Any = 1 // Int형
  a = 20L        // Long 형

  println("a is $a, type is ${a.<strong>javaClass</strong>}") // .javaClass: Java 기본형을 출력
}
<hr>>> a is 20, type is class java.lang.Long</pre>
  <h2 class="title"><span class="titleNumber">02-4</span>코틀린 연산자</h2>
  <h3 class="title">기본 연산자</h3>
  <h4>수식의 구조</h4>
  <code>
  <table style="text-align: center;" class="no-border">
    <tr>    
      <td colspan="3"></td>
      <td colspan="3">표현식</td>
    </tr>
    <tr>
      <td colspan="3"></td>
      <td style="background-color: lightgray;">항</td>
      <td style="background-color: lightgray;"></td>
      <td style="background-color: lightgray;">항</td>
    </tr>
    <tr style="font-size: 1.3rem;">
      <td colspan="2">val result</td>
      <td>=</td>
      <td style="background-color: lightgray;border:1px solid red">num1</td>
      <td style="background-color: lightgray;">+</td>
      <td style="background-color: lightgray;border:1px solid red">num2</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td><sub>대입<br>이항 연산자</sub></td>
      <td></td>
      <td><sub>덧셈<br>이항 연산자</sub></td>
      <td></td>
    </tr>
  </table></code>
  <h4>산술 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>+</td>
      <td>덧셈</td>
    </tr>
    <tr>
      <td>-</td>
      <td>뺄셈</td>
    </tr>
    <tr>
      <td>*</td>
      <td>곱셈</td>
    </tr>
    <tr>
      <td>/</td>
      <td>나눗셈</td>
    </tr>
    <tr>
      <td>%</td>
      <td>나머지 <sub>Modulus</sub></td>
    </tr>
  </table>
  <h4>대입 연산자 =</h4>
  변수에 값을 할당하는 연산자. 이항 연산자 중 우선순위가 가장 낮다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>=</td>
      <td>a = b</td>
    </tr>
    <tr>
      <td>+=</td>
      <td>a += b, a = a + b</td>
    </tr>
    <tr>
      <td>-=</td>
      <td>a -= b, a = a - b</td>
    </tr>
    <tr>
      <td>*=</td>
      <td>a *= b, a = a * b</td>
    </tr>
    <tr>
      <td>/=</td>
      <td>a /= b, a = a / b</td>
    </tr>
    <tr>
      <td>%=</td>
      <td>a %= b, a = a % b</td>
    </tr>
  </table>
  <h4>증가 연산자와 감소 연산자</h4>
  단항 연산자
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col" colspan="2">의미</th>
    </tr>
    <tr>
      <td rowspan="2">++</td>
      <td>b = a++</td>
      <td>b = a, a = a + 1</td>
    </tr>
    <tr>
      <td>b = ++a</td>
      <td>a = a + 1, b = a</td>
    </tr>
    <tr>
      <td rowspan="2">--</td>
      <td>b = a--</td>
      <td>b = a, a = a - 1</td>
    </tr>
    <tr>
      <td>b = --a</td>
      <td>a = a - 1, b = a</td>
    </tr>
  </table>
  <h4>비교 연산자</h4>
  결과 값은 true 또는 false 이다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
    </tr>
    <tr>
      <td>>, >=, &lt;, &lt;=</td>
    </tr>
    <tr>
      <td>==, !=</td>
    </tr>
    <tr>
      <td>===, !==</td>
    </tr>
  </table>
  <h4>논리 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th>연산자</th>
      <th>의미</th>
    </tr>
    <tr>
      <td>&&</td>
      <td>AND</td>
    </tr>
    <tr>
      <td>||</td>
      <td>OR</td>
    </tr>
    <tr>
      <td>!</td>
      <td>NOT</td>
    </tr>
  </table>
  <span class="material-icons red">info</span>단축평가 <sub>Short Circuit Evaluation</sub>
  <pre>
// a 가 true 라면 b는 검사하지 않고 true를 return 한다.    
val x = a || b 

// a 가 false 라면 b는 검사하지 않고 false를 return 한다.
val y = a && b </pre>
  <h3 class="title">Bit 연산자</h3>
  <h4>Bit와 Bit 연산</h4>
  <h4>Bit 연산을 위한 Bit Method</h4>
  <pre>
val x = 4.shl(1)  // 함수 호출 형식
val y = 4 shl 1   // 중위 표현식. infix</pre>
  <code>
  <table>
    <caption>class Int의 Bit 연산자</caption>
    <tr>
      <th scope="col">예시</th>
      <th scope="col" colspan="2">설명</th>
    </tr>
    <tr>
      <td><code>shl(bits)</code></td>
  <td>shift left. 왼쪽으로 bits 만큼 이동. 부호 있음</td>
  <td rowspan="2">사라진 bit는 0으로 채우고 부호 bit는 그대로 둔다.</td>
  </tr>
  <tr>
    <td><code>shr(bits)</code></td>
    <td>shift right. 오른쪽으로 bits 만큼 이동. 부호 있음</td>
  </tr>
  <tr>
    <td><code>ushr(bits)</code></td>
    <td>unsigned shift right. 오른쪽으로 bits 만큼 이동. 부호 없음</td>
    <td>제일 왼쪽 bit에 0을 채운다.</td>
  </tr>
  <tr>
    <td><code>and(bits)</code></td>
    <td>bits와 논리곱 연산</td>
    <td>0b1100 and<br>0b1010
      <hr>0b1000
    </td>
  </tr>
  <tr>
    <td><code>or(bits)</code></td>
    <td>bits와 논리합 연산</td>
    <td>0b1100 or<br>0b1010
      <hr>0b1110
    </td>
  </tr>
  <tr>
    <td><code>xor(bits)</code></td>
    <td>bits와 배타적 연산</td>
    <td>0b1100 xor<br>0b1010
      <hr>0b0110
    </td>
  </tr>
  <tr>
    <td><code>inv()</code></td>
    <td>모든 bit를 반대로 한다. invert</td>
    <td>1.inv() == -2</td>
  </tr>
  </table></code>
  <span class="material-icons red">info</span>IntelliJ Debug 관련 단축키
  <ul style="line-height: 1.5rem;margin-top:0rem;">
    <li><kbd>Ctrl </kbd>+<kbd>F8</kbd> : Break Point Toggle 설정</li>
    <li><kbd>Shift</kbd>+<kbd>F9</kbd> : Debugging Run</li>
    <li><kbd>F8</kbd> : Step Over. 한 줄씩 실행.</li>
    <li>Debug > Variables 창에 있는 변수를 선택한 후 Pop-up menu에서 <strong>View As > Binary</strong>를 선택하면 2진수로 값을 볼 수 있다.</li>
  </ul>
  <span class="material-icons red">info</span>xor 3번으로 두 값 swap 하기
  <pre>
fun main() {
  var a = 12
  var b = 25

  a = a xor b
  b = a xor b
  a = a xor b

  println(a) // 25
  println(b) // 12
}</pre>
  <hr>
  <h1><span class="titleNumber">03</span>함수와 함수형 프로그래밍</h1>
  <h2 class="title"><span class="titleNumber">03-1</span>함수 선언하고 호출하기</h2>
  <h3 class="title mb-0">함수란 무엇일까?</h3>
  함수는 여러 값(인자)을 입력받아 기능을 수행하고 결괏값을 반환하는 code의 모음이다.
  <h3 class="title mb-0">함수의 구조 자세히 살펴보기</h3>
  <pre>
<span class="color-on-board">fun</span> sum(a: Int, b: Int): Int {
  val sum = a + b
  <span class="color-on-board">retrn</span> sum
}</pre>
  <ul>
    <li><strong><code>fun</code></strong> keyword로 함수 선언 시작하기</li>
    <li>함수 이름 짓기</li>
    <li>매개변수는 <strong>,</strong>와 함께 여러 개를 지정할 수 있다. 반드시 <strong>:</strong>과 함께 자료형을 명시해야 한다.</li>
    <li>함수가 반환하는 값이 있다면 반환값의 자료형도 반드시 명시해야 한다.</li>
    <li>함수의 본문 완성하기</li>
    <li><strong>return</strong> keyword와 함께 반환할 값을 명시한다. 반환할 값이 없다면 생략할 수 있다.</li>
  </ul>
  <pre>
// 함수의 기본형. [] 부분은 생략 가능.
<span class="color-on-board">fun</span> 함수_이름<span class="color-on-board">(</span>[매개변수이름:자료형, 매개변수이름:자료형...]<span class="color-on-board">)</span>[: 반환값의_자료형] <span class="color-on-board">{</span>
  표현식...
  [return 반환값]
<span class="color-on-board">}</span>
</pre>
  <h4 class="mb-0">간략하게 선언하기</h4>
  {} 안의 code가 한 줄이면 {}와 return문을 생략할 수 있다.
  <pre>fun sum(a: Int, b: Int) <span class="color-on-board">= a + b</span></pre>
  <h3 class="title mb-0">함수 호출과 Program의 실행 순서</h3>
  <ul class="mt-0">
    <li>Program의 진입점 main() 함수가 가장 먼저 실행된다.</li>
    <li>인자와 함께 함수를 호출한다.
      <ul>
        <li>매개변수 <sub>Parameter</sub> - 함수를 선언할 때 사용하는 변수</li>
        <li>인자 <sub>Argument</sub> - 함수를 호출할 때 사용하는 실제 값</li>
      </ul>
    </li>
    <li>Program의 실행 흐름이 함수로 이동한다.</li>
    <li>함수가 반환되면 실행 흐름이 다시 main()으로 돌아온다.</li>
  </ul>
  <h3 class="title mb-0">함수의 호출과 Memory</h3>
  <pre>
fun main() {
  val num1 = 10
  val num2 = 3

  val result = max(num1, num2)
  println(result)
}

fun max(a: Int, b: Int): Int = if (a > b) a else b</pre>
  <h4 class="mb-0">함수와 Stack Frame</h4>
  함수의 각 정보는 Frame이라는 정보로 Stack memory의 높은 주소부터 거꾸로 자라듯이 채워져 간다.
  <code>
  <table class="no-border" style="text-align: center; border: 1px solid black">
    <caption>Stack과 각 함수의 Stack Frame</caption>
    <tr style="background-color: yellowgreen;">
      <td colspan="2">낮은 주소</td>
      <td>Heap</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="bg-lg border">&nbsp;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td><span class="material-icons red">vertical_align_bottom</span></td>
      <td class="bg-lg border"></td>
      <td></td>
    </tr>
    <tr>
      <td colspan="4"><hr style="border-top: 1px dashed black;"></td>
    </tr>
    <tr>
      <td rowspan="3">max() 함수의 stack frame</td>
      <td><span class="material-icons red">vertical_align_top</span><br>생성<br>방향</td>
      <td class="bg-lg border">3</td>
      <td style="text-align: left;"><span class="material-icons">west</span> b</td>
    </tr>
    <tr>
      <td rowspan="8"></td>
      <td class="bg-lg border">10</td>
      <td style="text-align: left;"><span class="material-icons">west</span> a</td>
    </tr>
    <tr>
      <td><sup>지역 변수</sup></td>
      <td></td>
    </tr>
    <tr>
      <td colspan="4"></td>
    </tr>
    <tr>
      <td rowspan="5">main() 함수의 stack frame
        <ul class="mt-0" style="text-align: left;">
          <li>지역 변수</li>
          <li>항(Operand) Stack</li>
          <li>상수 Pool</li>
        </ul>
      </td>
      <td class="bg-lg border">?</td>
      <td style="text-align: left;"><span class="material-icons">west</span> result</td>
    </tr>
    <tr>
      <td class="bg-lg border">3</td>
      <td style="text-align: left;"><span class="material-icons">west</span> num2</td>
    </tr>
    <tr>
      <td class="bg-lg border">10</td>
      <td style="text-align: left;"><span class="material-icons">west</span> num1</td>
    </tr>
    <tr>
      <td class="bg-lg border">0</td>
      <td style="text-align: left;"><span class="material-icons">west</span> args</td>
    </tr>
    <tr>
      <td><sup>지역 변수</sup></td>
      <td></td>
    </tr>
    <tr style="background-color: green; color:white;">
      <td colspan="2">높은 주소</td>
      <td>Stack</td>
      <td></td>
    </tr>
  </table></code>
  지역 변수 - 함수가 종료되면 stack frame과 함께 사라지는 임시 변수.
  <h4 class="mb-0">Stack Frame의 생성과 소멸</h4>
  함수가 호출될 때마다 해당 정보는 stack memory에 쌓이는데 이것을 <strong>stack frame</strong>이라고 부른다.
  <ul style="list-style-type: decimal;">
    <li>함수가 호출되면 stack에 frame이 생긴다.</li>
    <li>Stack frame은 각각 분리되어 있다.</li>
    <li>Frame으로 분리된 변수들을 지역 변수라고 부른다.</li>
    <li>함수 호출 순서대로 stack에 생성되고 역순으로 소멸한다.</li>
    <li>Stack의 내용이 최대 영역을 초과하면 <strong>Stack Overflow</strong>가 발생한다.</li>
  </ul>
  <h3 class="title mb-0">반환값이 없는 함수</h3>
  반환값의 자료형을 <strong><code>Unit</code></strong>으로 지정하거나 <strong>생략</strong>한다.<br>
  Unit은 Java의 void형에 대응되지만 void는 정말로 아무것도 반환하지 않고 Unit은 특수한 객체를 반환한다.
  <h3 class="title mb-0">매개변수 제대로 활용하기</h3>
  매개변수에 기본값을 설정할 수 있다.
  <pre>
fun add(name: String, email: String = "nothing") {
  // name, email을 회원 목록에 저장한다.
  // email에 전달된 인자가 없으면 기본값으로 설정된 "nothing"를 사용한다.
}

add("peter", "peter@superhero.com")
add("parker") // email 값으로 "nothing"이 사용된다.
</pre>
  <h4>매개변수 이름과 함께 함수 호출하기</h4>
  <pre>
fun main() {
  namedParam(x = 10, y = 20)
}

fun namedParam(x: Int, y: Int) { }
</pre>
  <h4>매개변수의 개수가 고정되지 않은 함수 사용하기 <strong><code>vararg</code></strong></h4>
  가변 인자 <sub>Variable Argument</sub>를 사용한다.
  <pre>
fun main() {
  show(1, 2, 3)
}

fun show(<strong>vararg</strong> counts: Int) {
  for (i <strong style="line-height: 1rem;">in</strong> counts)
      print(i)
}<hr>>> 123
</pre>
  <h2 class="title"><span class="titleNumber">03-2</span>함수형 <sub>Functional</sub> Programming</h2>
  <h3 class="title mb-0">함수형 Programming이란?</h3>
  순수 함수를 작성하여 program의 부작용을 줄이는 programming 기법이다.
  <h4>순수 함수</h4>
  <ul class="mt-0">
    <li>함수가 같은 인자에 대하여 항상 같은 결과를 반환하면 '<b>부작용이 없는 함수</b>'라고 한다.</li>
    <li>이런 함수가 함수 외부의 어떤 상태도 바꾸지 않는다면 순수 함수<sub>Pure Function</sub>라고 한다.</li>
    <li>이런 특성 덕분에 순수 함수는 thread에 사용해도 안전하고 code를 test하기도 쉽다.</li>
  </ul>
  <h4>일급 객체 <sub>First Class Citizen</sub></h4>
  <ul class="mt-0">특징
    <li>함수의 인자로 전달할 수 있다.</li>
    <li>함수의 반환값에 사용할 수 있다.</li>
    <li>변수에 담을 수 있다.</li>
  </ul>
  함수가 일급 객체면 일급 함수라고 부른다.<br>일급 함수에 이름이 없는 경우 Lambda 함수 혹은 Lambda식이라고 부른다.
  <h4>람다식 <sub>Lambda Express</sub></h4>
  <ul class="mt-0">
    <li>일급 객체의 특징을 가진 이름 없는 함수
      <ul>
        <li>다른 함수의 인자로 넘기는 함수</li>
        <li>함수의 결괏값으로 반환하는 함수</li>
        <li>변수에 저장하는 함수</li>
      </ul>
    </li>
  </ul>
  <h4 class="mb-0">고차 함수 <sub>High Order Function</sub></h4>
  인자나 반환값으로 함수를 사용할 수 있다.
  <pre>
fun main() {
  val x = highFunc(<strong>{ a, b -> a + b }</strong>, 1, 2)
  println(x)
}

fun highFunc(sum: <strong>(Int, Int) -> Int</strong>, a: Int, b: Int) = sum(a, b)</pre>
  <h4>함수형 Programming의 정의와 특징</h4>
  <ul class="mt-0">
    <li>순수 함수를 사용해야 한다.</li>
    <li>Lambda식을 사용할 수 있다.</li>
    <li>고차 함수를 사용할 수 있다.</li>
  </ul>
  <h2 class="title"><span class="titleNumber">03-3</span>고차 함수와 Lambda식</h2>
  <h3 class="title">고차 함수의 형태</h3>
  <h4><i>일반 함수</i> 를 인자나 반환값으로 사용하는 고차 함수</h4>
  <pre>
fun main() {
  val res = sum(3, 2)
  val res2 = mul(<strong>sum(3, 3)</strong>, 3)

  println("$res, $res2")
}

fun sum(a: Int, b: Int) = a + b
fun mul(a: Int, b: Int) = a * b

fun test(): Int {
  return <strong>sum(2, 2)</strong>
}</pre>
  <h4><i>Lambda식</i> 을 인자나 반환값으로 사용하는 고차 함수</h4>
  <h4 class="mt-0"><i>Lambda식</i> 을 변수에 할당하는 경우</h4>
  <pre>
fun main() {
  val multi: (Int, Int) -> Int = <strong>{ x: Int, y: Int -> x * y }</strong> // 일반 변수에 lambda식 할당.
  val res: Int = <strong style="line-height: 1rem;">multi</strong>(10, 20) // Lambda식이 할당 된 변수는 함수처럼 사용할 수 있다.
}</pre>
  <code>
<table class="no-border" style="text-align: center; background-color: skyblue; border-radius: .25rem;">
  <caption style="font-size: 1rem;">Lambda식의 선언과 할당</caption>
  <tr>
    <td rowspan="3"></td>
    <td></td>
    <td rowspan="3"></td>
    <td>lambda식의 자료형 선언</td>
    <td></td>
    <td>lambda식의 매개변수</td>
    <td></td>
    <td>lambda식의 처리 내용</td>
    <td></td>
  </tr>  
  <tr style="font-size: 1.25rem; font-weight: bolder;">
    <td class="bg-ws" style="border-radius: .25rem;">val multi</td>
    <td class="bg-ws" style="border-radius: .25rem;">: (Int, Int) -> Int</td>
    <td>= {</td>
    <td class="bg-ws" style="border-radius: .25rem;">x: Int, y: Int</td>
    <td>-></td>
    <td class="bg-ws" style="border-radius: .25rem;">x * y</td>
    <td>}</td>
  </tr>
  <tr>
    <td>변수를<br>함수처럼<br>사용 가능</td>
    <td>lambda식 매개변수에<br>자료형이 명시된 경우<br>생략 가능</td>
    <td></td>
    <td>자료형이<br>선언되어 있으면<br>생략 가능</td>
    <td></td>
    <td>함수의 내용과 결과 반환,<br>표현식이 여러 줄인 경우<br>마지막 표현식이 반환</td>
    <td></td>
  </tr>  
</table></code>
  <pre>
val multi:(Int, Int) -> Int = { x: Int, y: Int -> x * y }
val multi:(Int, Int) -> Int = { x, y -> x * y }
val multi = { x: Int, y: Int -> x * y }

val multi = { x, y -> x * y } // <span class="red">Error!</span> 자료형을 추론할 수 없다!

val greet: <strong>() -> Unit</strong> = { println("Hello") } // 매개변수가 없으므로 lambda 식에서 매개변수 선언 부분과 '->' 생략.
val greet = { println("Hello") } // 추론 가능

val square: <strong>(Int) -> Int</strong> = { x -> x * x }
val square = { x<strong style="line-height: 1rem;">: Int</strong> -> x * x }

val nestedLambda: <strong>() -> () -> Unit</strong> = { { println("중첩") } }
val nestedLambda = { { println("중첩") } } // 추론 가능</pre>
  <pre>
val multi2 = { x: Int, y: Int ->
  print("x * y = ")
  <strong>x * y</strong> // 마지막 표현식이 반환
}

println(multi2(3, 4))</pre>
  <h4><i>Lambda식</i> 을 매개변수에 사용하는 경우</h4>
  <pre>
  fun main() {
    val result = highOrder(<strong>{ x, y -> x + y }</strong>, 10, 20)
    println(result) // 30
}

fun highOrder(<strong>sum: (Int, Int) -> Int</strong>, a: Int, b: Int): Int = sum(a, b)</pre>
  <h4>인자와 반환값이 없는 lambda식</h4>
  <pre>
fun main() {
  // val out: () -> Unit = { println("Hello") }
  val out = { println("Hello") }
  out()

  val out2 = out
  out2()
}</pre>
  <h3 class="title">Lambda식과 고차 함수 호출하기</h3>
  <ul class="mt-0">
    <li>기본형 변수로 할당된 값은 stack에 있다.</li>
    <li>다른 함수에 인자로 전달하는 경우에는 해당 값이 복사되어 전달된다.</li>
    <li>참조형 변수로 할당된 객체는 참조 주소가 stack에 있고 객체는 heap에 있다.</li>
    <li>참조형 객체는 함수에 전달될 때 참조된 주소가 복사되어 전달된다.</li>
    <li>JVM에서 실행되는 Java나 Kotlin은 함수를 호출할 때 인자의 값을 복사하는 '값에 의한 호출' <sub>Call by value</sub> 방식을 사용한다.</li>
  </ul>
  <h4>값에 의한 호출</h4>
  함수가 인자로 전달될 경우 lambda식 함수는 값으로 처리되어 그 즉시 함수가 수행된 후 그 결과 값을 전달한다.
  <pre>
fun main() {
  val result = callByValue(<strong>lambda()</strong>) // lambda식 함수를 호출
  println(result)
}

// 일반 변수 자료형으로 선언된 매개변수
fun callByValue(<strong>b: Boolean</strong>): Boolean {
  println("callByValue function")
  return b
}

val <strong>lambda: () -> Boolean</strong> = {
  println("lambda function")
  true
}<hr>>>
lambda function
callByValue function
true</pre>
  <h4>이름에 의한 Lambda식 호출</h4>
  <pre>
fun main() {
  val result = callByName(<strong>otherLambda</strong>) // lambda식 이름으로 호출
  println(result)
}

// lambda식 자료형으로 선언된 매개변수
fun callByName(b: <strong>() -> Boolean</strong>): Boolean {
  println("callByName function")
  return <strong>b()</strong> // 여기서 lambda식 함수를 호출
}

val otherLambda: () -> Boolean = {
  println("otherLambda function")
  true
}<hr>>>
callByName function
otherLambda function
true</pre>
  <h4>다른 함수의 참조에 의한 일반 함수 호출 <strong>::</strong></h4>
  <pre>
fun main() {
  val result = funcParam(3, 2, <strong>::sum</strong>)
  println("result = $result")
}

fun sum(a: Int, b: Int) = a + b

fun funcParam(a: Int, b: Int, c: <strong>(Int, Int) -> Int</strong>): Int {
  return c(a, b)
}<hr>>>
result = 5</pre>
  <pre>
fun main() {
  // 인자와 반환값이 있는 함수
  val res1 = funcParam(3, 2, <strong>::sum</strong>)
  println(res1)

  // 반환값이 없는 함수
  hello(<strong>::text</strong>)
  hello({ a, b -> text(a, b) }) // lambda식 표현
  hello { a, b -> text(a, b) }  // 소괄호 생략 가능

  // 일반 변수에 값처럼 할당
  val likeLambda = <strong>::sum</strong>
  println(likeLambda(6, 6))
}

fun sum(a: Int, b: Int) = a + b

fun funcParam(a: Int, b: Int, <strong>c: (Int, Int) -> Int</strong>): Int {
  return c(a, b)
}

fun text(a: String, b: String) = "Hi! $a $b"

fun hello(<strong>body: (String, String) -> String</strong>): Unit {
  println(body("Hello", "World"))
}<hr>>>
5
Hi! Hello World
Hi! Hello World
Hi! Hello World
12</pre>
  <h3 class="title">Lambda식의 매개변수</h3>
  <h4 class="mt-0">Lambda식에 매개변수가 없는 경우</h4>
  <pre>
fun main() {
  noParam({ "Hello World!" })
  noParam <strong>{ "Hello World!" }</strong> // () 생략 가능
}

fun noParam(out: <strong>() -> String</strong>) = println(<strong>out()</strong>)<hr>>>
Hello World!
Hello World!</pre>
  <h4>Lambda식의 매개변수가 1개인 경우</h4>
  <pre>
fun main() {
  oneParam({ a -> "Hello World! $a" })
  oneParam { a -> "Hello World! $a" }
  oneParam { "Hello World! <strong>$it</strong>" }
}

fun oneParam(out: <strong>(String) -> String</strong>) {
  println(out("One param"))
}<hr>>>
Hello World! One param
Hello World! One param
Hello World! One param</pre>
  <h4>Lambda식의 매개변수가 2개 이상인 경우</h4>
  <pre>
fun main() {
  moreParam { <strong>a, b</strong> -> "Hello World! <strong>$a $b</strong>" }
}

fun moreParam(out: <strong>(String, String) -> String</strong>) {
  println(out("OneParam", "TwoParam"))
}<hr>>>
Hello World! OneParam TwoParam</pre><br>
  Lambda식의 특정 매개변수를 사용하고 싶지 않을 때는 이름 대신에 '_' <sub>underscore</sub>로 대체할 수 있다.
  <pre>
moreParam { <strong>_</strong>, b -> "Hello World! $b" }
</pre>
  <h4>일반 매개변수와 Lambda식 매개변수를 같이 사용하기</h4>
  <pre>
fun main() {
  withArgs("Arg1", "Arg2", { x, y -> "Hello World! $x $y" })

  <strong>// 함수의 마지막 인자가 lambda식인 경우 () 바깥으로 분리 가능</strong>
  withArgs("Arg1", "Arg2") { x, y -> "Hello World! $x $y" }
}

fun withArgs(a: String, b: String, out: (String, String) -> String) = println(out(a, b))<hr>>>
Hello World! Arg1 Arg2
Hello World! Arg1 Arg2</pre>
  <h4>일반 함수에 Lambda식 매개변수를 2개 이상 사용하기</h4>
  <pre>
fun main() {
  twoLambda({ a, b -> "First $a $b" }, { "Second $it" })

  // 함수의 마지막 인자가 lambda식인 경우 () 바깥으로 분리 가능
  twoLambda({ a, b -> "First $a $b" }) { "Second $it" }
}

fun twoLambda(first: <strong>(String, String) -> String</strong>, second: <strong>(String) -> String</strong>) {
  println(first("OneParam", "TwoParam"))
  println(second("OneParam"))
}<hr>>>    
First OneParam TwoParam
Second OneParam
First OneParam TwoParam
Second OneParam</pre>
  <h2 class="title"><span class="titleNumber">03-4</span>고차 함수와 Lambda식의 사례 알아보기</h2>
  <h3 class="title mb-0">동기화를 위한 code 구현 구경하기</h3>
  <pre>
import java.util.concurrent.locks.ReentrantLock

var <strong>sharable</strong> = 1 // 보호가 필요한 공유 자원.

fun main() {
    val reLock = ReentrantLock()

    // 아래 3 표현식은 모두 같다.
    lock(reLock, { criticalFun() })
    lock(reLock) { criticalFun() }
    lock(reLock, ::criticalFun)

    println(sharable)
}

// 공유 자원을 변경하는 함수
fun criticalFun() {
    ++sharable 
}

// T는 Generic의 형식 매개변수
fun &lt;T> lock(reLock: ReentrantLock, body: <strong>() -> T</strong>): T {
    reLock.lock()
    try {
        return body()
    } finally {
        reLock.unlock()
    }
}<hr>>> 4</pre>
  <p>
    <span class="material-icons red" style="float:left">info</span><strong>Callback 함수</strong> : 특정 event가 발생하기 전까지 처리되지 않다가 event가 발생하면 즉시 호출되어 처리되는 함수.<br>
    사용자가 아닌 system이나 event에 따라 호출 시점이 결정된다.
  </p>
  <h2 class="title"><span class="titleNumber">03-5</span>Kotlin의 다양한 함수 알아보기</h2>
  <h3 class="title mb-0">익명 함수 <sub>Anonymous Function</sub></h3>
  이름이 없는 일반 함수.
  <pre>
<strong>fun</strong>(x: Int, y: Int): Int = x + y

// 동일한 표현
val add: (Int, Int) -> Int = fun(x, y) = x + y
val add = fun(x: Int, y: Int) = x + y

// 동일한 lambda식 표현
val add = { x: Int, y: Int -> x + y }</pre>
  Lambda식에서는 <code>return, break, continue</code> 같은 제어문을 사용하기 어려워서 익명함수를 사용한다.
  <h3 class="title mb-0">Inline 함수 <sub>Inline Function</sub></h3>
  함수가 호출되는 곳에 함수 본문의 내용을 모두 복사해 넣어 함수의 분기 없이 처리되기 때문에 성능을 높일 수 있다.
  <pre>
fun main() {
  shortFunc(3) { println("First call: $it") }
  shortFunc(5) { println("Second call: $it") }
}

<strong>inline</strong> fun shortFunc(a: Int, out: (Int)->Unit) {
  println("Before calling out()")
  out(a)
  println("After calling out()")
}</pre>
  <h4 class="mb-0">역컴파일 <sub>Decompile</sub>된 내용으로 inline 함수 살펴보기</h4>
  IntelliJ IDEA의 <kbd style="line-height: 1.5rem;">Tools > Kotlin > Show Kotlin Bytecode</kbd> 메뉴를 선택하고 Kotlin Bytecode 창에서 <kbd>Decompile</kbd> button을 누른다.<br>
  Decompile된 file이 .java인 이유는 현재 Kotlin이 JVM에서 수행되고 있어 내부적으로 Java code와 동일한 실행 문맥을 가지기 때문이다.
  <h4 class="mb-0">Inline 함수 제한하기 <strong>noinline</strong></h4>
  Inline 함수의 매개변수로 사용한 lambda식의 code가 너무 길거나 함수의 본문 자체가 너무 길면 compiler에서 성능 경고를 할 수 있다.<br>
  또 inline 함수가 너무 많이 호출되면 오히려 code 양만 늘어나서 좋지 않을 수 있다.
  <pre>
// 매개변수 lambda식들도 그대로 복사가 된다.
<strong>inline</strong> fun sub(out1: () -> Unit, out2: () -> Unit)

// out1만 복사가 되고, out2는 호출 방식으로 사용된다.
<strong>inline</strong> fun sub(out1: () -> Unit, <strong>noinline</strong> out2: () -> Unit)</pre>
  <h4 class="mb-0">Inline 함수와 비지역 반환 <sub>Non-local Return</sub></h4>
  <ul class="mt-0 mb-0">
    <li>Kotlin에서는 익명 함수를 종료하기 위해 <code>return</code>을 사용할 수 있다.<br>이때 특정 반환값 없이 <code>return</code>만 사용해야 한다.</li>
    <li><code>return</code>문은 lambda식 본문에 사용할 수 없다.</li>
    <li>Inline 함수에서 사용한 lambda식에서는 <code>return</code>을 사용할 수 있다.</li>
  </ul>
  <pre>
fun main() {
  shortFunc(3) {
      println("First call: $it")
      <strong>return</strong> // Non-local Return
  }
}

<strong>inline</strong> fun shortFunc(a: Int, out: (Int) -> Unit) {
  println("Before calling out()")
  out(a)
  println("After calling out()") // 실행이 안된다.
}<hr>>>
Before calling out()
First call: 3</pre>
  Lambda식에서 <code>return</code>문을 만났지만 바깥 함수인 shortFunc()가 반환되었다.<br><br>
  <pre>
  fun main() {
    shortFunc(3) {
        println("First call: $it")
        <strong>return@shortFunc</strong>
    }
}

inline fun shortFunc(a: Int, out: (Int) -> Unit) {
    println("Before calling out()")
    out(a)
    println("After calling out()")
}<hr>>>
Before calling out()
First call: 3
After calling out()</pre><br>
  out()을 직접 호출해 사용하지 않고 또 다른 함수로 전달하면 실행 문맥이 달라져서 <code>return</code>을 사용할 수 없다.<br>
  이때 비지역 반환을 금지하기 위해 <strong>crossinline</strong>을 사용한다.
  <pre>
fun main() {
  shortFunc(3) {
      println("First call: $it")
      return@shortFunc // 그냥 return은 사용불가.
  }
}

inline fun shortFunc(a: Int, <strong>crossinline</strong> out: (Int) -> Unit) {
  println("Before calling out()")
  <strong>nestedFunc { out(a) }</strong>
  println("After calling out()")
}

fun nestedFunc(body: () -> Unit) {
  body()
}<hr>>>
Before calling out()
First call: 3
After calling out()</pre>
  <h3 class="title mb-0">확장 함수 <sub>Extension Function</sub></h3>
  Class처럼 필요한 대상에 함수를 더 추가할 수 있다.
  <pre>
fun 확장대상.함수이름(매개변수, ...): 반환값 {
  ...
  return 값
}</pre>
  <h4 class="mb-0">String class에 나만의 확장 함수 추가하기</h4>
  <pre>
fun main() {
  println("Hello World!".getLongerString("Kotlin"))
}

// 더 긴 문자열을 반환하는 함수
fun <strong>String.</strong><span style="color:#0f0">getLongerString</span>(other: String): String {
  return when (length > other.length) {
      true -> this
      else -> other
  }
}<hr>>> Hello World!</pre>
  확장 대상에 확장 함수와 같은 이름의 member method가 있다면 항상 member method가 먼저 호출된다.
  <h3 class="title mb-0">중위 함수 <sub>Infix Function</sub> : <strong><code>infix</code></strong></h3>
  중위 표현법 <sub>Infix Notation</sub> 이란 class의 member를 호출할 때 사용하는 '.'을 생략하고 함수 이름 뒤에 ()를 붙이지 않아 직관적인 이름을 사용할 수 있는 표현법이다.<br>
  일종의 연산자를 구현할 수 있는 함수를 말한다.
  <ul><b>중위 함수의 조건</b>
    <li>Member method 또는 확장 함수여야 한다.</li>
    <li>하나의 매개변수를 가져야 한다.</li>
    <li><strong>infix</strong> keyword를 사용해서 정의한다.</li>
  </ul>
  <pre>
fun main() {
  val a = 3.multiply(4) // 12
  val b = <strong>3 multiply 4</strong> // 12
}

<strong>infix</strong> fun Int<strong>.multiply</strong>(other: Int): Int {
  return this * other
}</pre>
  <h3 class="title mb-0">꼬리 재귀 함수 <sub>Tail Recursive Function</sub> : <strong><code>tailrec</code></strong></h3>
  <b>재귀 <sub>Recursion</sub></b> : 자기 자신을 다시 참조하는 방법
  <ul><b>재귀 함수의 조건</b>
    <li>무한 호출에 빠지지 않도록 탈출 조건을 만들어 준다. Stack Overflow 주의!</li>
    <li>Stack 영역을 이용하므로 호출 횟수를 무리하게 많이 지정해 연산하지 않는다.</li>
    <li>Code를 복잡하지 않게 한다.</li>
  </ul>
  <h4 class="mb-0">factorial 재귀 함수로 stack overflow 경험하기</h4>
  <pre>
fun main() {
  val n = 4
  val result = factorial(n)

  println("$n! = $result")
}

fun <strong>factorial</strong>(n: Int): Long {
  return when {
      n &lt; 2 -> 1L
      else -> n * <strong>factorial</strong>(n - 1)
  }
}<hr>>> 4! = 24</pre>
  <h4 class="mb-0">꼬리 재귀로 stack overflow 방지하기</h4>
  <pre>
<strong>tailrec</strong> fun factorial(n: Int, result: Int = 1): Long {
  return when {
      n &lt; 2 -> result.toLong()
      
      // 인자 안에서 factorial의 도중 값을 계산하고 호출한다.
      else -> <strong>factorial(n - 1, result * n)</strong> 
  }
}

fun main() {
  val n = 4
  val result = <strong>factorial(n)</strong>

  println("$n! = $result")
}<hr>>> 4! = 24</pre>
  <h4 class="mb-0">fibonacci 수열 재귀 함수와 꼬리 재귀 함수</h4>
  <pre>
import java.math.BigInteger

fun main() {
    val n = 100
    val first = BigInteger("0")
    val second = BigInteger("1")
    val result = fibonacci(n, first, second)
    println("Fibonacci($n) = $result")

}

<strong>tailrec</strong> fun fibonacci(n: Int, first: BigInteger, second: BigInteger): BigInteger {
    return when(n) {
        0 -> first
        else -> fibonacci(n - 1, second, first + second)
    }
}<hr>>> Fibonacci(100) = 354224848179261915075</pre>
  <h2 class="title"><span class="titleNumber">03-6</span>함수와 변수의 범위</h2>
  <h3 class="title">함수의 범위</h3>
  <h4>최상위 함수 <sub>Top-Level Function</sub>와 지역 함수 <sub>Local Function</sub></h4>
  <pre>
/* SampleFile.kt */

// 사용자가 만든 최상위 함수 선언
fun userFunc1() {
  ...
}

// 최상위 함수
<strong>fun main()</strong> {
  ...

  // 지역 함수 선언. 사용하기 전에 반드시 먼저 선언해야 한다.
  fun localFunc() {
    ...
  }

  // 사용자 함수 사용 : 선언부의 위치에 상관없이 사용 가능.
  userFunc1()   
  userFunc2()

  // 지역 함수 사용 : 지역 함수를 먼저 선언해야 한다.
  localFunc() 
}

// 사용자가 만든 최상위 함수 선언
fun userFunc2() {
  ...
}</pre>
  사용자가 만든 최상위 함수는 <code>main()</code> 함수의 앞이나 뒤에 선언해도 <code>main()</code> 함수 안에서 사용할 수 있다.
  <h4>최상위 및 지역 함수의 사용 범위</h4>
  <pre>
// SampleFile.kt

fun a() = b()
fun b() = {}

fun c() {
  fun d() = e() // <span class="red">Error!</span> e 함수를 먼저 선언해야 한다.
  fun <strong>e()</strong> = {}
}

fun main() {
  a()
  e() // <span class="red">Error!</span> c 함수 안에서만 유효한 지역 함수다.
}</pre>
  <h3 class="title">변수의 범위</h3>
  <h4>지역 변수 <sub>Local Variable</sub>와 전역 변수 <sub>Global Variable</sub></h4>
  <ul>
    <li>지역 변수 : 특정 code block 안에 있는 변수. Block을 벗어나면 memory에서 삭제된다.</li>
    <li>전역 변수 : 최상위에 있는 변수. Program이 실행되는 동안 삭제되지 않고 memory에 유지된다.</li>
  </ul>
  <pre>
// SampleFile.kt
package com.sample

// com.sample package에서 모두 접근할 수 있는 전역 변수.
// 파일이 달라도 package가 같다면 접근할 수 있다.
var global = 10 

fun main() {
    // main() 안에서만 유지되는 지역 변수.
    val localOne = 10
    val localTwo = 20

    fun localFunc() {
        global += 1
        val localOne = 30 // main()의 localOne을 가린다.

        println(localOne)
        println(localTwo)
        println(global)
    }

    localFunc()
    topFunc()

    println(localOne)
    println(localTwo)
    println(global)
}

fun topFunc() {
    global += 1
    val outVal = "outside"

    println(global)
    println(outVal)
}</pre>
  <hr>
  <h1><span class="titleNumber">04</span>프로그램의 흐름 제어</h1>
  <h2 class="title"><span class="titleNumber">04-1</span>조건문</h2>
  <h3 class="title">if문과 if~else문</h3>
  <h4>if문과 if~else문을 이용한 큰 수 판단하기</h4>
  <pre>
var max: Int
if (a > b)
    max = a // 수행할 문장이 한 줄이면 {}를 생략할 수 있다.
els
    max = b<hr>val max = if (a > b) a else b</pre>
  <h4>Block의 표현식이 길어질 때 <code>{}</code>로 감싸야 한다.</h4>
  <pre>
fun main() {
  val a = 12
  val b = 7

  val max = if (a > b) {
      println("a 선택")
      a // 마지막 식이 반환되어 max에 할당된다.
  } else {
      println("b 선택")
      b
  }

  println("max = $max")
}<hr>>>
a 선택
max = 12</pre>
  <h3 class="title mb-0"><code>else if</code>문으로 조건문 중첩하기</h3>
  <pre>
val number = 0
val result = if (number > 0)
    "양수"
else if (number &lt; 0)
    "음수"
else
    "0"</pre>
  <pre>
fun main() {
  print("Enter the score: ")

  val score = try {
    // console로부터 문자열을 입력받는 함수. 표준 library.
      <strong>readLine()</strong>?.toDouble() ?: 0.0
  } catch (e: <strong style="line-height: 1rem;">NumberFormatException</strong>) {
      0.0
  }

  val grade = if (score > 89.9)
      'A'
  else if (score <strong>in</strong> 80.0<strong>..</strong>89.9)
      'B'
  else if (score in 70.0..79.9)
      'C'
  else
      'F'

  println("Score: $score, Grade: $grade")
}<hr>>> Enter the score: 88
Score: 88.0, Grade: B</pre>
  <h4><strong>in</strong> 연산자의 범위 연산자로 조건식 간략하게 만들기</h4>
  <pre>변수이름 <strong>in</strong> 시작값<strong>..</strong>마지막값</pre>
  <h3 class="title"><code>when</code>문으로 다양한 조건 처리하기</h3>
  <h4>인자를 사용하는 when문</h4>
  <pre>
<strong>when</strong> (x) {
  1 <strong>-></strong> print("x is One")
  2 -> print("x is Two")
  <strong>else</strong> -> print("x is not One, Two")
}<hr>when (x) {
  1<strong>,</strong> 2 -> print("x is One or Two")
  else -> print("x is etc")
}</pre>
  <h4><code>when</code>문에 함수의 반환값 사용하기</h4>
  <pre>
when (x) {
  parseInt(s) -> print("일치!") // 함수의 반환값이 x와 같은 경우.
  else -> print("기타")
}</pre>
  <h4><code>when</code>문에 <code>in</code> 연산자와 범위 지정자 사용하기</h4>
  <pre>
when (x) {
  <strong>in</strong> 1..10 -> print("x는 1과 10 사이의 값이다.")
  <strong style="line-height: 1rem;">!in</strong> 10..20 -> print("x는 10과 20사이의 값이 아니다.")
  else -> print("x는 어떤 ")
}</pre>
  <h4 class="mb-0"><code>when</code>과 <code>is</code> keyword 함께 사용하기</h4>
  <code>is</code>를 사용하면 특정 자료형을 검사할 수 있다.
  <pre>
val str: Any = "Hello"
val result = when (str) {
  <strong>is</strong> String -> "문자열"
  else -> false
}</pre>
  <h4 class="mb-0">인자가 없는 <code>when</code>문</h4>
  조건이나 표현식을 직접 만들 수 있다.
  <pre>
fun main() {
  print("Enter the score: ")

  val score = try {
      readLine()?.toDouble() ?: 0.0
  } catch (e: NumberFormatException) {
      0.0
  }

  val grade = when {
      <strong>score >= 90.0</strong> -> 'A'
      score in 80.0..89.9 -> 'B'
      score in 70.0..79.9 -> 'C'
      else -> 'F'
  }

  println("Score: $score, Grade: $grade")
}</pre>
  <h4>다양한 자료형의 인자 받기</h4>
  <pre>
fun main() {
  cases("Hello")
  cases(1)
  cases(System.currentTimeMillis())
  cases("something")
  cases(MyClass())
}

fun cases(obj: <strong>Any</strong>) {
  println(
      when (obj) {
          1 -> "Int: $obj"
          "Hello" -> "String: $obj"
          is Long -> "Long: $obj"
          !is String -> "Not a String: $obj"
          else -> "Unknown: $obj"
      })
}

class MyClass {}<hr>>>
String: Hello
Int: 1
Long: 1622544178239
Unknown: something
Not a String: MyClass@610455d6</pre>
  <h2 class="title"><span class="titleNumber">04-2</span>반복문</h2>
  <h3 class="title mb-0"><code>for</code>문</h3>
  <pre>
// Java
for (int i = 0; i &lt; 5; ++i) { ... }

// Kotlin
for (i in 0..4) { ... }</pre>
  <h4 class="mb-0">값 증감에 따른 다양한 반복 방법</h4>
  <pre>
for (i in 1<strong>..</strong>5) print(i) // 12345

for (i in 5 <strong>downTo</strong> 1) print(i) // 54321

for (i in 1..5 <strong>step</strong> 2) print(i) // 135</pre>
  <h3 class="title mb-0"><code>while</code>문</h3>
  <pre>
// 조건식이 true인 동안 반복한다.
// 처음부터 조건이 false면 한번도 실행하지 않는다.
<strong>while</strong> (조건식) {
  ...
}</pre>
  <h3 class="title mb-0"><code>do-while</code>문</h3>
  <pre>
// 최소 한번은 실행한다.
<strong>do</strong> {
  ...
} <strong>while</strong> (조건식)</pre>
  <h2 class="title"><span class="titleNumber">04-3</span>흐름의 중단과 반환</h2>
  <ul><b>흐름 제어문</b>
    <li><code>return</code> : 함수에서 결괏값을 반환하거나 지정된 label로 이동한다.</li>
    <li><code>break</code> : 반복문의 조건식에 상관없이 반복문을 끝낸다.</li>
    <li><code>continue</code> : 반복문의 나머지 본문을 수행하지 않고 바로 조건식 검사로 넘어간다.</li>
  </ul>
  <ul><b>예외 처리문</b>
    <li><code>try {...} catch {...}</code> : <code>try</code> block을 수행하는 도중 예외가 발생하면 <code>catch</code> block을 실행한다.</li>
    <li><code>try {...} catch {...} finally {...}</code> : 예외 발생 여부와 상관 없이 <code>finally</code> block는 항상 실행한다.</li>
  </ul>
  <h3 class="title mb-0"><code>return</code>문</h3>
  <h4 class="mb-0 mt-0"><code>return</code>으로 값 반환하기</h4>
  <pre>
fun add(a: Int, b: Int): Int {
  <strong>return</strong> a + b

  println("이 줄은 실행되지 않는다!")
}</pre>
  <h4><code>return</code>으로 <code>Unit</code> 반환하기</h4>
  <pre>
// 아래 3경우는 모두 같다.

fun hello(name: String)<strong>: Unit</strong> {
  println(name)
  <strong>return Unit</strong>
}

fun hello(name: String)<strong>: Unit</strong> {
  println(name)
  <strong>return</strong>
}

// 둘다 생략
fun hello(name: String) {
  println(name)
}</pre>
생략할 경우 Kotlin compiler는 <code>Unit</code>을 반환하는 것으로 가정한다.
<p><span class="material-icons red">info</span>Lambda식에서 <code>return</code>은 label 표기와 함께 사용해야 하고 <code>break</code>와 <code>continue</code>는 아직 지원하지 않는다.</p>
  <h4>Lambda식에서 <code>return</code> 사용하기</h4>
  <ul>
    <li><code>inline</code>으로 선언되지 않는 lambda식에는 <code>return</code>을 그냥 사용할 수 없다.</li>
    <li><code>return@label</code>과 같이 label 표기와 함께 사용해야 한다.</li>
    <li><b>Label</b>이란 code에서 특정한 위치를 임의로 표시한 것으로 <strong>@ 기호와 이름</strong>을 붙여서 사용한다.</li>
    <li>inline으로 선언된 함수에서 lambda식을 매개변수로 사용하면 lambda식에서 <code>return</code>을 사용할 수 있다. <strong>Non-Local Return</strong>
      <pre>
fun main() {
  retFunc()
}

inline fun 
      </pre>
    </li>
  </ul>
  <h4>Lambda식에서 label과 함께 <code>return</code> 사용하기</h4>
  <h4>암묵적 label</h4>
  <h4>익명 함수를 사용한 반환</h4>
  <h3 class="title"><code>break</code>문과 <code>continue</code>문</h3>
  <h4><code>break</code>와 <code>continue</code>에 label 함께 사용하기</h4>
  <h3 class="title">예외 처리</h3>
  <h4>특정 예외 처리</h4>
  <h4>Stack의 추적</h4>
  <h4>예외 발생시키기</h4>
  <h4>사용자 정의 예외</h4>


  <p id="end">END</p>
</body>

</html>
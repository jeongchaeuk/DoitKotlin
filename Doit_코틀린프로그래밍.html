<!DOCTYPE html>
<html lang="ko" class="night-mode">
<!-- <html lang="ko"> -->

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    html.night-mode {
      background-color: black;
      color: whitesmoke;
    }

    html.night-mode code {
      color: black;
    }

    html.night-mode code.no-bgc {
      color: white;
    }

    html.night-mode th {
      color: black;
    }

    span.error {
      color: red;
    }

    .info {
      color: red;
    }

    .lh-1 {
      line-height: 1rem;
    }

    .no-bgc {
      background-color: transparent;
    }

    .red {
      color: red
    }

    .mb-0 {
      margin-bottom: 0;
    }

    .mb-25 {
      margin-bottom: .25rem;
    }

    .mt-0 {
      margin-top: 0;
    }

    .bg-lg {
      background-color: lightgray;
    }

    .bg-ws {
      background-color: whitesmoke;
    }

    .color-on-board {
      color: #0f0;
      font-weight: bolder;
      font-style: italic;
      font-size: 1rem;
    }

    .material-icons {
      display: inline-flex;
      vertical-align: middle;
    }

    .top {
      position: fixed;
      width: 4rem;
      height: 4rem;
      bottom: 6.5rem;
      right: 2rem;
      background-color: #a11;
      color: whitesmoke;
      box-shadow: 0rem .1rem .1rem black;
      border-radius: 2rem;
      border: none;
      text-align: center;
    }

    .bottom {
      position: fixed;
      width: 4rem;
      height: 4rem;
      bottom: 2rem;
      right: 2rem;
      background-color: #11a;
      color: whitesmoke;
      box-shadow: 0rem .1rem .1rem black;
      border-radius: 2rem;
      border: none;
      text-align: center;
    }


    .my-float {
      font-size: 4rem;
      line-height: 4.5rem;
    }

    pre {
      margin: .25rem;
      border-radius: .5rem;
      padding: .25rem .5rem;
      font-size: .9rem;
      background-color: #073042;
      color: lightgray;
      width: min-content;
    }

    pre.no-bgc {
      background-color: transparent;
      color: black;
    }

    pre.border-line {
      border-radius: .25rem;
      background-color: transparent;
      color: black;
      border: 1px solid black;
    }

    html.night-mode pre.border-line {
      color: white;
      border: 1px solid white;
    }

    pre .keyword {
      color: #cc7832;
    }

    pre .annotation-name {
      color: #bbb529;
    }

    pre .comment {
      color: #629755FF;
    }

    pre .func-decl {
      color: #ffc66d;
    }

    pre .property {
      color: #9876aa;
    }

    strong {
      background-color: goldenrod;
      padding: 0rem 0.25rem;
      border-radius: .25rem;
      color: black;
      display: inline-flex;
      font-size: .9rem;
      font-family: D2Coding;
    }

    strong>code {
      background-color: transparent;
    }

    code {
      font-weight: bolder;
    }

    .madang,
    .center {
      text-align: center;
    }

    .madang_number {
      font-size: 0.75em;
      color: tomato;
      text-decoration-line: underline;
    }

    h1>.titleNumber {
      color: white;
      background-color: tomato;
      padding-top: .25rem;
      padding-left: .5rem;
      padding-right: .5rem;
      margin-right: .5rem;
      border-radius: .25rem;
    }

    h2.title {
      border-width: .1rem;
      border-bottom-style: dashed
    }

    h2>.titleNumber,
    h3.title {
      color: tomato;
      margin-right: .5rem;
    }

    table,
    th,
    td {
      border-collapse: collapse;
      border: .05rem solid gray;
      padding: 0.25rem;
    }

    table.noneLine,
    table .noneLine {
      border-collapse: collapse;
      border: .05rem none;
      padding: 0.25rem;
      margin: 0.25rem;
      background-color: #EEE;
    }

    table.th-ta-r th {
      text-align: right;
    }

    table.td-ta-r td:first-child {
      text-align: right;
      padding-right: .5rem;
    }

    th {
      background-color: lightgray;
    }

    span.title {
      background-color: red;
      padding: 0.1rem 0.25em;
    }

    kbd {
      border: 1px solid gray;
      border-radius: .25rem;
      padding: 0.25em;
      background-color: lightgray;
      box-shadow: .05rem .05rem black;
    }

    img {
      max-width: 100%;
      height: auto;
    }

    a {
      text-decoration: inherit;
      border-bottom: 1px solid lightgray;
      cursor: pointer;
      color: inherit
    }

    a:hover {
      border-bottom: 1px solid black;
    }

    .number {
      font-family: D2Coding;
    }

    h4 {
      margin-bottom: .5rem;
    }

    .no-border {
      border: none;
    }

    table.no-border td {
      border: none;
    }

    table.no-border .border {
      border: 1px solid black;
    }

    code {
      font-size: 1rem;
      background-color: lightgray;
      padding: 0 .25rem;
      border-radius: 0.25rem;
    }

    .keyword {
      color: #c83;
      font-weight: bolder;
    }

    .keyword-on-light {
      color: #008;
      font-weight: bolder;
      font-size: 1rem;
    }

    .custom {
      color: #ee3
    }
  </style>
  <title>Kotlin programming</title>
</head>

<body>
  <a href="#top" class="top"><span class="material-icons my-float">publish</span></a>
  <a href="#end" class="bottom"><span class="material-icons my-float">download</span></a>
  <h1 id="top" class="madang"><span class="madang_number">첫째 마당</span><br>Kotlin<br>기본 익히기</h1>
  <h1><span class="titleNumber">01</span>시작하기</h1>
  <h2 class="title"><span class="titleNumber">01-1</span> 탄생 배경</h2>
  <h3 class="title">소개합니다</h3>
  <p>IntelliJ IDEA라는 통합 개발 환경으로 유명한 JetBrains에서 개발했다.<br>
  <ul>
    <li style="line-height: 1.5rem;"><a href="https://kotlinlang.org/" target="_blank">Kotlinlang.org</a></li>
    <li><a href="https://github.com/JetBrains/kotlin/" target="_blank">Github Kotlin</a></li>
  </ul>
  </p>
  종류
  <ul>
    <li>Kotlin/JVM : Java 가상 Machine에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/JS : Javascript로 web browser에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/Native : LLVM compiler를 이용하여 여러 platform을 target으로 하는 application을 만들 수 있다.</li>
  </ul>
  사용 환경
  <ul>
    <li>Apple iOS (arm32, arm64, emulator x86_64)</li>
    <li>Apple Mac OS(x86_64)</li>
    <li>Android (arm32, arm64)</li>
    <li>Windows (MinGW x86_64)</li>
    <li>Linux (x86_64, arm32, MIPS, MIPS litter-endian)</li>
    <li>Web 전용(wasm32)</li>
  </ul>
  Java와 완벽하게 호환된다.
  <h3 class="title">장점</h3>
  <ul>
    <li>Compiled 자료형을 검사하여 확정하는 정적 언어로 자료형 오류를 초기에 발견할 수 있다.</li>
    <li>NPE <sub>Null pointer exception</sub>로 인한 program의 중단을 예방할 수 있다.</li>
    <li>아주 간결하고 효율적이다.</li>
    <li>함수형 programming과 객체 지향 programming이 모두 가능하다.</li>
    <li>';' 을 생략할 수도 있다.</li>
  </ul>
  <h3 class="title">Android 공식 언어로 채택된 Kotlin</h3>
  <h4>JDK 들</h4>
  <ul>
    <li style="line-height: 1.5rem;"><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank">Oracle JDK</a></li>
    <li style="line-height: 1.5rem;"><a href="https://openjdk.java.net/" target="_blank">Open JDK</a></li>
    <li><a href="https://www.azul.com/" target="_blank">Zulu</a></li>
  </ul>
  <h3 class="title">IntelliJ IDEA 설치하기</h3>
  <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ IDEA 2021.1.1 (211.7142.45 build)</a>
  <h2 class="title"><span class="titleNumber">01-3</span> Kotlin project 시작하기</h2>
  <h3 class="title">Kotlin project 만들기</h3>
  <h4>Hellokotlin project 만들기</h4>
  <img src="images/creatNewProject.png" width="582" height="414" alt="Create New Project" title="새 project 생성하기"><br>
  <img src="images/newProject.png" width="925" height="686" alt="New Project" title="Kotlin/JVM project 선택"><br>
  <img src="images/newProject2.png" width="952" height="423" alt="New Project2" title="Kotlin/JVM project 선택 2"><br>
  <img src="images/newProject3.png" width="735" height="197" alt="New Project3" title="Kotlin/JVM project 선택 3"><br>
  <img src="images/newProject4.png" width="334" height="261" alt="New Project4" title="Kotlin/JVM project 선택 4"><br>
  HelloKotlin.kt
  <pre>
fun main() {
  println("Hello Kotlin!")
}</pre>
  <code>Run > Run > HelloKotlinKt > Run</code> menu를 선택해서 실행한다.
  <pre>
// 결과
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Hello Kotlin!

Process finished with exit code 0</pre>
  <h3 class="title">Project 하나씩 뜯어보기</h3>
  <h4>Kotlin의 <code>main()</code> 함수는 program의 실행 진입점</h4>
  <ul>
    <li>Kotlin code는 JVM에서 실행되며, <code>main()</code> 함수가 있는 file 이름을 기준으로 Java class가 자동 생성된다.</li>
    <li>자동 생성된 class는 <code>Tools > Kotlin > Show Kotlin Bytecode</code>에서 <code>Decompile</code>(역compile) button을 누르면 확인할 수 있다.</li>
  </ul>
  <pre>
// compiler의 version에 따라 다를 수 있다. 
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

@Metadata(
    mv = {1, 5, 1},
    k = 2,
    d1 = {"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n"+
          "\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b"+
          "\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"},
    d2 = {"main", "", "args", "", "", "([Ljava/lang/String;)V", "HelloKotlin.main"}
)
public final class HelloKotlinKt {
    public static final void main(@NotNull String[] args) {
      Intrinsics.checkNotNullParameter(args, "args");
      String var1 = "Hello Kotlin!";
      boolean var2 = false;
      System.out.println(var1);
    }
}</pre>
  <h4>Program의 memory 영역</h4>
  <table>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
    <tr>
      <th>Code</th>
      <td>명령어가 저장된다.</td>
    </tr>
    <tr>
      <th>Data</th>
      <td>문자열, 정적 변수등이 저장된다. Method Static Area, 정적 memory 영역, literal pool</td>
    </tr>
    <tr>
      <th>Heap</th>
      <td>실행 중 생성되는 객체들이 저장된다. <span class="material-icons">arrow_downward</span> 아래쪽 방향으로 증가, 동적 memory 영역</td>
    </tr>
    <tr>
      <th>Stack</th>
      <td>지역 변수나 함수 호출 정보(매개변수)가 저장된다. <span class="material-icons">arrow_upward</span>위쪽 방향으로 증가</td>
    </tr>
  </table>
  <span class="material-icons">info</span><code>Garbage Collection</code> : JVM은 더 이상 참조하지 않는 객체들을 자동으로 memory에서 삭제해준다.
  <h4>Kotlin의 <code>main()</code> method에서 매개변수를 사용할 경우</h4>
  <code>main()</code>에 전달할 외부의 인자들을 가리키고, 명령행에서 입력받은 값들이 차례대로 배열에 저장된다.<br>
  <pre>
fun main(<strong>args: Array&lt;String></strong>) {
  for (str in args) {
      println(str)
  }
}</pre>
  <code>Run > Edit Configurations... > Program arguments</code> 에 'Good 안녕 123'을 입력한다.
  <pre>
// 실행 결과 화면
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Good
안녕
123

Process finished with exit code 0</pre>
  <hr>
  <h1><span class="titleNumber">02</span>변수와 자료형, 연산자</h1>
  <h2 class="title"><span class="titleNumber">02-1</span>코틀린 패키지</h2>
  Kotlin에서 Project는 Module, Package, File로 구성된다.
  <h3 class="title">Project, Module, Package, File의 관계 이해하기</h3>
  <ul>
    <li style="list-style: none;">HelloKotlin (Project)
      <ul>
        <li>HelloKotlin (Module 1)
          <ul>
            <li>default (Package)
              <ul>
                <li>HelloKotlin.kt (File)</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>OtherModule (Module 2)</li>
      </ul>
    </li>
  </ul>
  <ul>
    <li>default package는 src folder에 따로 package 이름을 지정하지 않은 file들이 포함된다.</li>
    <li>Kotlin file은 .kt 확장자를 가지며 compiler가 알 수 있도록 file의 맨 위에는 이 file이 속한 package 이름을 선언해야 한다.</li>
    <li>그렇지 않으면 자동으로 <strong>default</strong> package에 포함된다.</li>
    <li>file이 package folder 안에 있어도 package 이름을 선언하지 않으면 default package에 포함된 것으로 인식한다.</li><br>
    <li>File에 1개의 class가 정의되어 있다면 project 창 화면에 .kt 확장자가 빠진 class 이름만 보인다.</li>
    <li>File에 여러 개의 class를 정의한다면 file은 단순히 class를 묶는 역할을 하고 .kt 확장자가 붙게 된다.</li>
    <li>Kotlin에서는 file 이름과 class의 선언 개수에 큰 의미를 두지 않는다.</li>
    <li>같은 file에 들어 있는 class들은 모두 그 file에 지정한 package로 인식한다.</li>
    <li>Kotlin은 Java처럼 class 이름과 file 이름이 같아야 하고, plublic class는 하나만 사용해야 하는 규칙이 <strong>없다</strong>.</li>
  </ul>
  <h4>Package를 만들어야 하는 이유</h4>
  같은 이름의 file이라도 package가 다르면 다른 file로 인식되어 중복 오류가 발생하지 않는다.
  <h3 class="title">Kotlin project에 package 만들기</h3>
  <h4>Package 이름 정하기</h4>
  <ul class="mt-0">
    <li>이름은 file 첫 줄에 적는다.</li>
    <li><strong>package</strong> keyword를 앞에 붙인다.</li>
    <li>이름은 특수문자나 숫자로 시작하면 안된다.</li>
    <li>여러 단계의 분류가 필요하면 <strong>.</strong> 을 붙여 이름을 짓는다.</li>
  </ul>
  <pre>package com.acaroom.net.upload</pre>
  <span class="material-icons red">info</span> IntelliJ에서 Kotlin/JVM project는 <code>/src/main/kotlin</code> folder를 기준으로 package, file들을 만든다.
  <h3 class="title">기본 package 활용하기</h3>
  <ul>
    <li>기본 package는 자주 사용하는 class와 함수 등을 미리 만들어 놓은 것이다.</li>
    <li><code>import</code> keyword로 package를 선언하지 않아도 바로 사용할 수 있다.</li>
  </ul>
  <table>
    <caption>기본 package</caption>
    <tr>
      <th>이름</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>kotlin.*</code></td>
      <td><code>Any, Int, Double</code> 등 핵심 함수와 자료형</td>
    </tr>
    <tr>
      <td><code>kotlin.text.*</code></td>
      <td>문자와 관련된 API</td>
    </tr>
    <tr>
      <td><code>kotlin.sequences.*</code></td>
      <td>Collection 자료형의 하나로 반복이 허용되는 개체를 열거</td>
    </tr>
    <tr>
      <td><code>kotlin.ranges.*</code></td>
      <td><code>if</code> 문이나 <code>for</code> 문에서 사용할 범위 관련 요소</td>
    </tr>
    <tr>
      <td><code>kotlin.io.*</code></td>
      <td>입출력 관련 API</td>
    </tr>
    <tr>
      <td><code>kotlin.collections.*</code></td>
      <td><code>List, Set, Map</code> 등의 collection</td>
    </tr>
    <tr>
      <td><code>kotlin.annotation.*</code></td>
      <td>주석 관련 API</td>
    </tr>
  </table>
  <sub>별표(*)는 해당 package에 포함된 모든 요소를 의미한다.</sub>
  <h4>IntelliJ 단축키</h4>
  <ul>
    <li style="line-height: 1.5rem;"><kbd>Ctr</kbd> + <kbd>B</kbd> : 선택한 class나 함수의 source file을 찾아 보여준다.</li>
    <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F10</kbd> : 현재 file 실행하기</li>
  </ul>
  <h3 class="title">사용자 class 가져오기</h3>
  <pre>
package com.example.edu.Person

class Person(val name: String, val age: Int) { ... }</pre>
  <pre>
package chap02.section1

// 같은 이름의 class가 있을 때 as 로 별명을 지정 할 수 있다.
<strong>import</strong> com.example.edu.Person <strong>as</strong> <span style="color:gold;">User</span>

fun main(args: Array&lt;String&gt;) {
    val user1 = <span style="color:gold;">User</span>("Kildong", 30)
    println(user1.name)
    println(user1.age)

    // 이 package에 선언된 Person
    val user2 = Person("A123", "Kildong") 
    println(user2.id)
    println(user2.name)
}

class Person(val id: String, val name: String) { ... }</pre>
  <h2 class="title"><span class="titleNumber">02-2</span>변수와 자료형</h2>
  <h3 class="title">변수를 선언하고 자료형 추론하기</h3>
  <ul>
    <li><code><strong>val</strong></code>ue : 읽기 전용, 변경 불가 변수</li>
    <li><strong><code>var</code></strong>iable : 변경 가능 변수</li>
  </ul>
  <h4>변수 이름 짓기 규칙</h4>
  <ul>
    <li>영문자, 숫자, _ 만 사용할 수 있다.</li>
    <li>숫자로 시작할 수 없다.</li>
    <li>keyword는 사용할 수 없다.</li>
    <li>여러 단어로 구성된 이름은 소문자로 시작하는 낙타표기법을 사용하면 좋다.<br>
      예) <code>lowerCamelCase</code></li>
  </ul>
  <h4>변수를 선언하는 방법</h4>
  <table>
    <tr>
      <th>방법</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>val username: String = "Kildong"</code></td>
      <td>선언 keyword 변수이름: 자료형 = 값</td>
    </tr>
    <tr>
      <td><code>val username = "Kildong"</code></td>
      <td>초기화 값을 보고 자료형을 추론한다.
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> : 추론한 자료형을 알려준다.
      </td>
    </tr>
    <tr>
      <td><code>val username</code></td>
      <td><span class="material-icons red">warning</span> 초기값이 없어서 자료형을 추론하지 못한다.</td>
    </tr>
    <tr>
      <td><code>val username: String</code></td>
      <td>이런 경우 자료형을 반드시 지정해야 한다.</td>
    </tr>
  </table>
  <h3 class="title">자료형 알아보기</h3>
  <h4>Kotlin의 자료형은 <strong>참조형</strong>을 사용한다</h4>
  <ul>
    <li>Primitive Data Type (기본형)</li>
    <li>Reference Type (참조형)<br>
      객체를 생성하고 heap<sub>(동적 memory 영역)</sub>에 data를 저장한 후 이것을 참조하는 자료형.<br>
      <small>(* Kotlin에서 참조형은 성능 최적화를 위해 컴파일러에서 다시 기본형으로 대체된다.)</small>
    </li>
  </ul>
  <h4>기본형과 참조형의 동작 원리</h4>
  Java에서 기본형은 stack에 값이 저장되고 참조형은 참조하는 객체가 heap에 저장되고 그 주소가 stack에 저장된다.
  <h4>정수 자료형</h4>
  <table class="center">
    <caption>부호가 있는 정수 자료형<sub>signed</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">정수 자료형</td>
      <td><code>Byte</code></td>
      <td>8</td>
      <td>-2<sup> 7</sup> ~ 2<sup> 7</sup>-1</td>
    </tr>
    <tr>
      <td><code>Short</code></td>
      <td>16</td>
      <td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>
    </tr>
    <tr>
      <td><code>Int</code></td>
      <td>32</td>
      <td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>
    </tr>
    <tr>
      <td><code>Long</code></td>
      <td>64</td>
      <td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>
    </tr>
  </table>
  <pre>
val a = 123               // 10진수 표현
val b = 123<strong>L</strong>	          // Long 형으로 추론
val c = <strong>0x</strong>0F	          // 16진수 표현
val d = <strong>0b</strong>00001111	  // 2진수 표현</pre>
  보통 숫자값은 <code>Int</code>형으로 추론되기 때문에 좀 더 작은 범위의 정수 자료형인 <code>Byte</code>형이나 <code>Short</code>형을 사용하기 위해서는 <strong>직접</strong> 자료형을 명시해야 한다.
  <p />
  <table class="center">
    <caption>부호가 없는 정수 자료형<sub>unsigned</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">부호 없는<br>정수 자료형</td>
      <td><code>UByte</code></td>
      <td>8</td>
      <td>0 ~ 2<sup> 8</sup>-1</td>
    </tr>
    <tr>
      <td><code>UShort</code></td>
      <td>16</td>
      <td>0 ~ 2<sup>16</sup>-1</td>
    </tr>
    <tr>
      <td><code>UInt</code></td>
      <td>32</td>
      <td>0 ~ 2<sup>32</sup>-1</td>
    </tr>
    <tr>
      <td><code>ULong</code></td>
      <td>64</td>
      <td>0 ~ 2<sup>64</sup>-1</td>
    </tr>
  </table><br>
  부호 없는 자료형에는 <strong>u</strong> 식별자를 사용해야 한다. 없으면 값을 할당할 수 없다.<br>
  <pre>
val a: UInt = 153<strong>u</strong>
val b: ULong = 46322342<strong>uL</strong></pre><br>
  <strong>_</strong>로 자리값을 구분할 수 있다. 값에 영향을 주지 않는다.
  <pre>
val million = 1_000_000
val cardNumber = 1234_1234_1234_1234
val hexVal = 0xAB_CD_EF_12
val binary = 0b1010_0101</pre>
  <h4>실수 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="2">실수 자료형</td>
      <td><code>Float</code></td>
      <td>32</td>
      <td>약 1.4E<sup>-45</sup> ~ 3.4E<sup>+38</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
    <tr>
      <td><code>Double</code></td>
      <td>64</td>
      <td>약 4.9E<sup>-324</sup> ~ 1.7E<sup>+308</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
  </table>
  <ul>
    <li>실수도 자료형을 명시하지 않으면 <code>Double</code>형으로 추론된다.</li>
    <li><code>Float</code>형으로 지정하고 싶다면 식별자 <strong>F</strong>를 값 뒤에 붙이면 된다.</li>
  </ul>
  <pre>
val a = 3.14	// Double형으로 추론. 기본
val b = 3.14<strong>F</strong>	// Float형으로 추론.</pre>
  <table>
    <tr>
      <th>일반 수학의 표현</th>
      <th>Source code상의 표현</th>
    </tr>
    <tr>
      <td>3.14<sub>가수</sub> x 10<sub>밑수</sub><sup>16<sub>지수</sub></sup></td>
      <td>3.14<sub>(소수점이 없을 수도 있다.)</sub>E<sub>(또는 e)</sub> +<sub>(- 또는 +, +는 생략 가능)</sub> 16</td>
    </tr>
  </table>
  <pre>
val exp1 = 3.14E-2 // 0.0314
val exp2 = 3.14e2  // 314
</pre>
  <h4>부동 소수점 제대로 이해하기<small>(IEEE 754 표준)</small></h4>
  <p><span class="material-icons red" style="float:left">info</span>지수부에 저장되는 값은 <strong>(지수 bias + 실제 지수 값)</strong> 이다.<br>
    <sub>값이 2의 보수로 저장 되는데 이 때 음수값의 비교를 쉽게 하기위해 지수 bias를 적용해 양수값으로 저장되게 한다.</sub>
  </p>
  <table class="center number">
    <caption>32 bits Float (지수 bias : 2<sup>7</sup>-1 = 127)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 8 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 23 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>31</td>
      <td>30...23</td>
      <td>22...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b0000_0001 ~ 0b1111_1110 : 실제 지수값 범위: -126 ~ 127</li>
          <li>0b1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table><br>
  <table class="center number">
    <caption>64 bits Float (지수 bias : 2<sup>10</sup>-1 = 1023)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 11 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 52 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>63</td>
      <td>62...52</td>
      <td>51...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b000_0000_0001 ~ 0b111_1111_1110 : 실제 지수값 범위: -1022 ~ 1023</li>
          <li>0b111_1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table>
  <h4>정수값을 2진수로 표현하기</h4>
  <ul>
    <li>정수값을 2로 나누어 나머지를 취한다.</li>
    <li>몫을 다음 정수값으로 사용한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>나머지</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>10 ÷ 2 = 5, 0</td>
      <td>0</td>
      <td rowspan="4">low<br><span class="material-icons">arrow_upward</span><br>hi</td>
    </tr>
    <tr>
      <td>5 ÷ 2 = 2, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2 ÷ 2 = 1, 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1 ÷ 2 = 0, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10<sub>10</sub></th>
      <th colspan="2">1010<sub>2</sub></th>
    </tr>
  </table><br>
  <h4>소수값을 2진수로 표현하기</h4>
  <ul>
    <li>소수값에 2를 곱한 결과값에서 정수 부분을 취한다.</li>
    <li>다음 소수값은 이 정수 값을 뺀 값으로 한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>정수부</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>0.375 x 2 = 0.75</td>
      <td>0</td>
      <td rowspan="3">hi<br><span class="material-icons">arrow_downward</span><br>low</td>
    </tr>
    <tr>
      <td>(0.75 - 0) x 2 = 1.5</td>
      <td>1</td>
    </tr>
    <tr>
      <td>(1.5 - 1) x 2 = 1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0.375<sub>10</sub></th>
      <th colspan="2">0.011<sub>2</sub></th>
    </tr>
  </table><br>
  <span class="material-icons red">info</span>정수부는 항상 1이 되게 정규화한 후 값을 저장한다.
  <pre>
예) -12.375<sub>10</sub>를 32bits의 float 형식으로 표현하면 음수이므로 부호 bit는 1이고,
절댓값 12.375<sub>10</sub>의 2진수는 1100.011<sub>2</sub>이다.
이 값을 정수부가 항상 1이 되게 정규화 하면 1.100011 x 2<sup>3</sup>이 된다.
항상 1인 정수부를 제외한 소수부 100011<sub>2</sub>만 가수부에 저장한다. 뒤쪽엔 0으로 채운다.
지수부는 (3 + 127<sub>지수 bias 값</sub>)인 130<sub>10</sub>의 2진수인 10000010<sub>2</sub>를 저장한다.
<div style="font-size: 1.5rem;">
<span style="background:#a11; padding:.3rem">1</span><span style="background:#191; padding:.3rem">10000010</span><span style="background:#77f; padding:.3rem">10001100000000000000000</span>
</div>
</pre><br>
  부동소수점을 사용할 때는 오차에 주의해야 한다.
  <pre>
fun main() {
  var num = 0.0
  for (i in 1..10)
      num += 0.1

  println(num) // 0.9999999999999999 <span class="material-icons red">warning</span>1.0이 아니다!
}</pre>
  <h4>정수 자료형과 실수 자료형의 최솟값과 최댓값 알아보기</h4>
  각 자료형에 <strong><code>MIN_VALUE, MAX_VALUE</code></strong> 상수가 정의되어 있다.
  <h4>2의 보수</h4>
  <table class="number">
    <caption>음수는 2의 보수로 표현한다.</caption>
    <tr>
      <th>0b0000_0001</th>
      <td>+1</td>
    </tr>
    <tr>
      <th>0b1111_1110</th>
      <td>1의 보수는 각 bit를 반대로 하면 된다.</td>
    </tr>
    <tr>
      <th>0b1111_1111</th>
      <td>1의 보수에 +1를 하면 2의 보수가 된다. -1</td>
    </tr>
  </table>
  <small>(* 컴퓨터는 뺄셈을 2의 보수와의 합으로 계산한다.)</small>
  <h4>논리 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>논리 자료형</td>
      <td>Boolean</td>
      <td>1<sub>Java에서</sub></td>
      <td>true, false</td>
    </tr>
  </table>
  <pre>
val isOpen = true       // Boolean으로 추론
val isUploaded: Boolean // 선언만 한 경우 자료형을 반드시 명시</pre>
  <h4>문자 자료형</h4>
  문자를 작은따옴표(')로 감싸 표현한다.
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>문자 자료형</td>
      <td>Char</td>
      <td>16</td>
      <td>0 ~ 2<sup>15</sup>-1 (\u0000 ~ \uffff)</td>
    </tr>
  </table>
  <pre>
val ch = 'A'
val ch1: Char

println(ch + 1) // 'B'

val ch2: Char = 65 // error!

val code: Int = 65
val ch3 = code.<strong>toChar()</strong> // 'A'

val ch4 = '<strong>\u</strong>D55C' // unicode '한'
</pre>
  <h3 class="title">문자열 자료형(<strong>String</strong>) 알아보기</h3>
  문자 자료형인 Char은 기본형으로 처리되지만, 문자열 자료형은 기본형에 속하지 않는 배열 형태로 되어 있는 특수한 자료형이다.<br>
  <h4>문자열 자료형 선언과 저장 방식 이해하기</h4>
  <pre>
fun main() {
  val str1: String = "Hello"
  val str2 = "World"
  val str3 = "Hello"

  // === : 참조 비교. 객체의 주소를 비교한다.
  println("str1 === str2 is ${str1 === str2}")
  println("str1 === str3 is ${str1 === str3}")
}
<hr>>>
str1 === str2 is false
str1 === str3 is true</pre>
  <table>
    <tr>
      <table style="background-color:lightgray;text-align: center; border-collapse: separate;">
        <caption style="caption-side: bottom;">Heap</caption>
        <tr>
          <td style="border:none">
            <table style="border:none">
              <caption style="caption-side: bottom">&nbsp;</caption>
              <tr>
                <th style="border:none">A1<span class="material-icons">arrow_forward</span></th>
              </tr>
              <tr>
                <th style="border:none">A2<span class="material-icons">arrow_forward</span></th>
              </tr>
            </table>
          </td>
          <td>
            <table>
              <tr>
                <table style="background-color:whitesmoke;width:7rem; border-collapse: separate; border:1px dashed black">
                  <tr>
                    <td style="background-color: gray;">Hello</td>
                  </tr>
                  <tr>
                    <td style="background-color: gray;">World</td>
                  </tr>
                  <tr>
                    <td style="width:fit-content; border:none;">String Pool</td>
                  </tr>
                </table>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </tr><br>
    <tr>
      <table style="border: none;">
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str3</td>
        </tr>
        <tr>
          <td>주소: A2</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str2</td>
        </tr>
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str1</td>
        </tr>
        <tr>
          <td style="text-align: center; border:none">Stack</td>
          <td style="border:none"></td>
        </tr>
      </table>
    </tr>
  </table>
  String 형 선언 및 할당에 사용되는 memory는 <strong>String Pool</strong>이다.<br>
  <h4>표현식과 <strong><code>$</code></strong> 기호 사용하여 문자열 출력하기</h4>
  <pre>
val a = 1
val s1 = "a is <strong>$a</strong>"             // a is 1
val s2 = "(a + 1) is <strong>${a + 1}</strong>" // (a + 1) is 2</pre>
  변수가 아니라 표현식을 문자열에 포함하려면 <strong><code>{}</code></strong> 를 사용한다.<br>
  Escape 문자 <strong><code>\</code></strong>를 사용해 문자열 안에 ", $를 표시할 수 있다.
  <pre>
val str = "<strong>\"</strong>hello\", I have <strong>\$</strong>15"
val str2 = "${'"'}hello${'"'}, I have ${'$'}15"
<hr>>>
"hello", I have $15
</pre>
  <h4>형식화된 다중 문자열 사용하기</h4>
  <pre>
val str5 = <strong>"""</strong>
    abc
        abc
            abc<strong>"""</strong>
println(str5)
<hr>>

    abc
        abc
            abc</pre>

  <h4>자료형에 별명 붙이기</h4>
  <pre>
<strong>typealias</strong> UserName = String
val userName: UserName = "Peter"</pre>
  <h2 class="title"><span class="titleNumber">02-3</span>자료형 검사하고 변환하기</h2>
  <ul>
    <li>변수를 사용할 때 반드시 값이 할당되어 있어야 한다.</li>
    <li>값이 없는 상태를 <strong>null</strong> 이라고 한다.</li>
    <li>null 상태인 변수를 허용하려면 <strong>?</strong>를 사용해 선언한다.<br>
      이 변수를 사용하려면 null을 검사하고 처리하는 방법을 고려해야 한다.</li>
  </ul>
  <h3 class="title">null을 허용한 변수 검사하기</h3>
  프로그램 실행 중 값이 null인 변수에 접근하면 NPE<sub>(Null Point Exception)</sub> 예외 오류가 발생한다.
  <h4>변수에 null 할당하기</h4>
  <pre>
fun main() {
  var str: String = "Hello"
  str = null // <span class="red">Error!</span>
  
  var str2: String<strong>?</strong> = "World"
  str2 = null // <span style="color:#0f0">OK</span>
}</pre>
  <h4>Safe call(<strong>?.</strong>)과 non-null 단정 기호(<strong>!!.</strong>)를 활용하여 null을 허용한 변수 사용하기</h4>
  <ul>
    <li>Safe call : null일 수 있는 변수를 검사하여 안전하게 호출할 수 있도록 도와준다.
      <pre>
// str2가 유효한 문자열이면 문자열의 길이, str2가 null 이면 null을 return 한다.
val length = str2<strong>?.</strong>length</pre>
    </li>
    <li>non-null 단정 : compile 때 null 검사를 하지 않는다. 하지만 값이 null 이면 실행시에 NPE가 발생한다.</li>
  </ul>
  <h4>조건문을 활용해 null을 허용한 변수 검사하기</h4>
  <pre>val length = if (str2 != null) str2.length else -1</pre>
  <h4>Safe call과 Elvis 연산자(<strong>?:</strong>)를 활용해 null을 허용한 변수 더 안전하게 사용하기</h4>
  <pre>val length = str2?.length <strong>?:</strong> -1</pre>
  <h3 class="title">자료형 비교하고 검사하고 변환하기</h3>
  자료형이 서로 다른 변수를 비교하거나 연산할 수 없다.
  <h4>자료형 변환</h4>
  <pre>
val a: Int = 1
val b: Double = a // <span class="red">Type mismatch error!</span>
val c: Int = 1.1  // <span class="red">Type mismatch error!</span>

// 변환 method 사용
val d: Double = a.toDouble() // <span style="color:#0f0">OK</span>

// 표현식에서는 자료형이 표현할 수 있는 범위가 큰 자료형으로 자동 형 변환하여 연산한다.
val result = 1L + 3 // Long형 + Int형 -> result는 Long형
</pre>
  자료형 변환 method 들
  <ul style="margin-top:0">
    <li>toByte: Byte</li>
    <li>toLong: Long</li>
    <li>toShort: Short</li>
    <li>toInt: Int</li>
    <li>toFloat: Float</li>
    <li>toDouble: Double</li>
    <li>toChar: Char</li>
  </ul>
  <h4>기본형과 참조형 자료형의 비교 원리</h4>
  <ul>
    <li>구조적 동등성(Structural equality). equals()를 이용한 비교
      <ul>
        <li>==, !=</li>
        <li>a == b 는 다음으로 해석된다.
          <pre>a?.equals(b) ?: (b === null)</pre>
        </li>
        <li>a가 null이 아니면 equals(Any?) 함수를 호출하고, null이면 b가 null인지 참조 동등성을 검사한다.</li>
        <li>a == null은 명시적으로 a === null로 자동으로 변환된다.</li>
        <li>사용자 정의로 같음을 구현하려면 <strong><code>open operator fun equals(other: Any?): Boolean</code></strong>를 overriding 하면된다.</li>
        <li>Comparable&lt;...> interface에서 정의된 비교와는 상관 없다.</li>
      </ul>
    </li>
    <li>참조 동등성(Referential equality). 두 개의 참조가 같은 객체를 가리키는지 비교
      <ul>
        <li>===, !==</li>
        <li>a === b는 a와 b가 같은 객체를 가리킬 때만 true이다.</li>
        <li>기본형의 === 비교는 == 비교와 같다.</li>
      </ul>
    </li>
  </ul>
  <span class="material-icons red" style="float:left">info</span>저장되는 값이 -128~127 사이의 값이면 cache에 저장되어 참조된다.<br>
  이 경우 기본형이 stack에 값으로 저장되지 않고 값이 저장된 cache의 주소를 참조하게 된다.
  <h4>Smart Cast 알아보기</h4>
  <ul>
    <li>Compiler가 자동으로 형 변환을 해주는 것이다.</li>
    <li><strong>Number</strong> 자료형에 적용된다.
      <pre>
fun main() {
  val a: <strong>Number</strong> = 3.14

  println(a is Number) // true
  println(a is Double) // true
  println(a is Float)  // false
}</pre>
    </li>
  </ul>
  <h4>자료형 검사하기 <strong>is, !is</strong></h4>
  is는 변수의 자료형을 검사한 다음 그 변수를 해당 자료형으로 변환하는 기능도 있다.
  <pre>
fun main() {
  val x: <strong>Any</strong> // 임의의 자료형
  x = "Hello"

  if (x <strong>is</strong> String) {
      println(x.length) // x는 String으로 smart cast 된다.
  }
}</pre>
  <h4><strong>as</strong>에 의한 Smart Cast</h4>
  as는 형 변환이 불가능하면 예외를 발생시킨다.
  <pre>
// y가 null 이거나 String으로 형 변환이 불가능하면 예외 발생.
val x: String = y as String 

// y가 null 이거나 String으로 형 변환이 불가능하면 null을 return.
val x: String<strong>?</strong> = y <strong>as?</strong> String</pre>
  <h4>묵시적 변환</h4>
  <ul>
    <li><strong>open class Any</strong>는 최상위 class 이다.</li>
    <li>Any형은 자료형이 특별히 정해지지 않은 경우에 사용한다.</li>
    <li>Any형은 무엇이든 될 수 있기 때문에 언제든 필요한 자료형으로 자동 변환할 수 있다.(묵시적 변환)</li>
    <li></li>
  </ul>
  <pre>
fun main() {
  var a: Any = 1 // Int형
  a = 20L        // Long 형

  println("a is $a, type is ${a.<strong>javaClass</strong>}") // .javaClass: Java 기본형을 출력
}
<hr>>> a is 20, type is class java.lang.Long</pre>
  <h2 class="title"><span class="titleNumber">02-4</span>코틀린 연산자</h2>
  <h3 class="title">기본 연산자</h3>
  <h4>수식의 구조</h4>
  <code class="no-bgc">
  <table style="text-align: center;" class="no-border">
    <tr>    
      <td colspan="3"></td>
      <td colspan="3">표현식</td>
    </tr>
    <tr>
      <td colspan="3"></td>
      <td style="background-color: lightgray;">항</td>
      <td style="background-color: lightgray;"></td>
      <td style="background-color: lightgray;">항</td>
    </tr>
    <tr style="font-size: 1.3rem;">
      <td colspan="2">val result</td>
      <td>=</td>
      <td style="background-color: lightgray;border:1px solid red">num1</td>
      <td style="background-color: lightgray;">+</td>
      <td style="background-color: lightgray;border:1px solid red">num2</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td><sub>대입<br>이항 연산자</sub></td>
      <td></td>
      <td><sub>덧셈<br>이항 연산자</sub></td>
      <td></td>
    </tr>
  </table></code>
  <h4>산술 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>+</td>
      <td>덧셈</td>
    </tr>
    <tr>
      <td>-</td>
      <td>뺄셈</td>
    </tr>
    <tr>
      <td>*</td>
      <td>곱셈</td>
    </tr>
    <tr>
      <td>/</td>
      <td>나눗셈</td>
    </tr>
    <tr>
      <td>%</td>
      <td>나머지 <sub>Modulus</sub></td>
    </tr>
  </table>
  <h4>대입 연산자 =</h4>
  변수에 값을 할당하는 연산자. 이항 연산자 중 우선순위가 가장 낮다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>=</td>
      <td>a = b</td>
    </tr>
    <tr>
      <td>+=</td>
      <td>a += b, a = a + b</td>
    </tr>
    <tr>
      <td>-=</td>
      <td>a -= b, a = a - b</td>
    </tr>
    <tr>
      <td>*=</td>
      <td>a *= b, a = a * b</td>
    </tr>
    <tr>
      <td>/=</td>
      <td>a /= b, a = a / b</td>
    </tr>
    <tr>
      <td>%=</td>
      <td>a %= b, a = a % b</td>
    </tr>
  </table>
  <h4>증가 연산자와 감소 연산자</h4>
  단항 연산자
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col" colspan="2">의미</th>
    </tr>
    <tr>
      <td rowspan="2">++</td>
      <td>b = a++</td>
      <td>b = a, a = a + 1</td>
    </tr>
    <tr>
      <td>b = ++a</td>
      <td>a = a + 1, b = a</td>
    </tr>
    <tr>
      <td rowspan="2">--</td>
      <td>b = a--</td>
      <td>b = a, a = a - 1</td>
    </tr>
    <tr>
      <td>b = --a</td>
      <td>a = a - 1, b = a</td>
    </tr>
  </table>
  <h4>비교 연산자</h4>
  결과 값은 true 또는 false 이다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
    </tr>
    <tr>
      <td>>, >=, &lt;, &lt;=</td>
    </tr>
    <tr>
      <td>==, !=</td>
    </tr>
    <tr>
      <td>===, !==</td>
    </tr>
  </table>
  <h4>논리 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th>연산자</th>
      <th>의미</th>
    </tr>
    <tr>
      <td>&&</td>
      <td>AND</td>
    </tr>
    <tr>
      <td>||</td>
      <td>OR</td>
    </tr>
    <tr>
      <td>!</td>
      <td>NOT</td>
    </tr>
  </table>
  <span class="material-icons red">info</span>단축평가 <sub>Short Circuit Evaluation</sub>
  <pre>
// a 가 true 라면 b는 검사하지 않고 true를 return 한다.    
val x = a || b 

// a 가 false 라면 b는 검사하지 않고 false를 return 한다.
val y = a && b </pre>
  <h3 class="title">Bit 연산자</h3>
  <h4>Bit와 Bit 연산</h4>
  <h4>Bit 연산을 위한 Bit Method</h4>
  <pre>
val x = 4.shl(1)  // 함수 호출 형식
val y = 4 shl 1   // 중위 표현식. infix</pre>
  <code>
  <table>
    <caption>class Int의 Bit 연산자</caption>
    <tr>
      <th scope="col">예시</th>
      <th scope="col" colspan="2">설명</th>
    </tr>
    <tr>
      <td><code>shl(bits)</code></td>
  <td>shift left. 왼쪽으로 bits 만큼 이동. 부호 있음</td>
  <td rowspan="2">사라진 bit는 0으로 채우고 부호 bit는 그대로 둔다.</td>
  </tr>
  <tr>
    <td><code>shr(bits)</code></td>
    <td>shift right. 오른쪽으로 bits 만큼 이동. 부호 있음</td>
  </tr>
  <tr>
    <td><code>ushr(bits)</code></td>
    <td>unsigned shift right. 오른쪽으로 bits 만큼 이동. 부호 없음</td>
    <td>제일 왼쪽 bit에 0을 채운다.</td>
  </tr>
  <tr>
    <td><code>and(bits)</code></td>
    <td>bits와 논리곱 연산</td>
    <td>0b1100 and<br>0b1010
      <hr>0b1000
    </td>
  </tr>
  <tr>
    <td><code>or(bits)</code></td>
    <td>bits와 논리합 연산</td>
    <td>0b1100 or<br>0b1010
      <hr>0b1110
    </td>
  </tr>
  <tr>
    <td><code>xor(bits)</code></td>
    <td>bits와 배타적 연산</td>
    <td>0b1100 xor<br>0b1010
      <hr>0b0110
    </td>
  </tr>
  <tr>
    <td><code>inv()</code></td>
    <td>모든 bit를 반대로 한다. invert</td>
    <td>1.inv() == -2</td>
  </tr>
  </table></code>
  <span class="material-icons red">info</span>IntelliJ Debug 관련 단축키
  <ul style="line-height: 1.5rem;margin-top:0rem;">
    <li><kbd>Ctrl </kbd>+<kbd>F8</kbd> : Break Point Toggle 설정</li>
    <li><kbd>Shift</kbd>+<kbd>F9</kbd> : Debugging Run</li>
    <li><kbd>F8</kbd> : Step Over. 한 줄씩 실행.</li>
    <li>Debug > Variables 창에 있는 변수를 선택한 후 Pop-up menu에서 <strong>View As > Binary</strong>를 선택하면 2진수로 값을 볼 수 있다.</li>
  </ul>
  <span class="material-icons red">info</span>xor 3번으로 두 값 swap 하기
  <pre>
fun main() {
  var a = 12
  var b = 25

  a = a xor b
  b = a xor b
  a = a xor b

  println(a) // 25
  println(b) // 12
}</pre>
  <hr>
  <h1><span class="titleNumber">03</span>함수와 함수형 프로그래밍</h1>
  <h2 class="title"><span class="titleNumber">03-1</span>함수 선언하고 호출하기</h2>
  <h3 class="title mb-0">함수란 무엇일까?</h3>
  함수는 여러 값(인자)을 입력받아 기능을 수행하고 결괏값을 반환하는 code의 모음이다.
  <h3 class="title mb-0">함수의 구조 자세히 살펴보기</h3>
  <pre>
<span class="color-on-board">fun</span> sum(a: Int, b: Int): Int {
  val sum = a + b
  <span class="color-on-board">retrn</span> sum
}</pre>
  <ul>
    <li><strong><code>fun</code></strong> keyword로 함수 선언 시작하기</li>
    <li>함수 이름 짓기</li>
    <li>매개변수는 <strong>,</strong>와 함께 여러 개를 지정할 수 있다. 반드시 <strong>:</strong>과 함께 자료형을 명시해야 한다.</li>
    <li>함수가 반환하는 값이 있다면 반환값의 자료형도 반드시 명시해야 한다.</li>
    <li>함수의 본문 완성하기</li>
    <li><strong>return</strong> keyword와 함께 반환할 값을 명시한다. 반환할 값이 없다면 생략할 수 있다.</li>
  </ul>
  <pre>
// 함수의 기본형. [] 부분은 생략 가능.
<span class="color-on-board">fun</span> 함수_이름<span class="color-on-board">(</span>[매개변수이름:자료형, 매개변수이름:자료형...]<span class="color-on-board">)</span>[: 반환값의_자료형] <span class="color-on-board">{</span>
  표현식...
  [return 반환값]
<span class="color-on-board">}</span>
</pre>
  <h4 class="mb-0">간략하게 선언하기</h4>
  {} 안의 code가 한 줄이면 {}와 return문을 생략할 수 있다.
  <pre>fun sum(a: Int, b: Int) <span class="color-on-board">= a + b</span></pre>
  <h3 class="title mb-0">함수 호출과 Program의 실행 순서</h3>
  <ul class="mt-0">
    <li>Program의 진입점 main() 함수가 가장 먼저 실행된다.</li>
    <li>인자와 함께 함수를 호출한다.
      <ul>
        <li>매개변수 <sub>Parameter</sub> - 함수를 선언할 때 사용하는 변수</li>
        <li>인자 <sub>Argument</sub> - 함수를 호출할 때 사용하는 실제 값</li>
      </ul>
    </li>
    <li>Program의 실행 흐름이 함수로 이동한다.</li>
    <li>함수가 반환되면 실행 흐름이 다시 main()으로 돌아온다.</li>
  </ul>
  <h3 class="title mb-0">함수의 호출과 Memory</h3>
  <pre>
fun main() {
  val num1 = 10
  val num2 = 3

  val result = max(num1, num2)
  println(result)
}

fun max(a: Int, b: Int): Int = if (a > b) a else b</pre>
  <h4 class="mb-0">함수와 Stack Frame</h4>
  함수의 각 정보는 Frame이라는 정보로 Stack memory의 높은 주소부터 거꾸로 자라듯이 채워져 간다.
  <code>
  <table class="no-border" style="text-align: center; border: 1px solid black">
    <caption>Stack과 각 함수의 Stack Frame</caption>
    <tr style="background-color: yellowgreen;">
      <td colspan="2">낮은 주소</td>
      <td>Heap</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td class="bg-lg border">&nbsp;</td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td><span class="material-icons red">vertical_align_bottom</span></td>
      <td class="bg-lg border"></td>
      <td></td>
    </tr>
    <tr>
      <td colspan="4"><hr style="border-top: 1px dashed black;"></td>
    </tr>
    <tr>
      <td rowspan="3">max() 함수의 stack frame</td>
      <td><span class="material-icons red">vertical_align_top</span><br>생성<br>방향</td>
      <td class="bg-lg border">3</td>
      <td style="text-align: left;"><span class="material-icons">west</span> b</td>
    </tr>
    <tr>
      <td rowspan="8"></td>
      <td class="bg-lg border">10</td>
      <td style="text-align: left;"><span class="material-icons">west</span> a</td>
    </tr>
    <tr>
      <td><sup>지역 변수</sup></td>
      <td></td>
    </tr>
    <tr>
      <td colspan="4"></td>
    </tr>
    <tr>
      <td rowspan="5">main() 함수의 stack frame
        <ul class="mt-0" style="text-align: left;">
          <li>지역 변수</li>
          <li>항(Operand) Stack</li>
          <li>상수 Pool</li>
        </ul>
      </td>
      <td class="bg-lg border">?</td>
      <td style="text-align: left;"><span class="material-icons">west</span> result</td>
    </tr>
    <tr>
      <td class="bg-lg border">3</td>
      <td style="text-align: left;"><span class="material-icons">west</span> num2</td>
    </tr>
    <tr>
      <td class="bg-lg border">10</td>
      <td style="text-align: left;"><span class="material-icons">west</span> num1</td>
    </tr>
    <tr>
      <td class="bg-lg border">0</td>
      <td style="text-align: left;"><span class="material-icons">west</span> args</td>
    </tr>
    <tr>
      <td><sup>지역 변수</sup></td>
      <td></td>
    </tr>
    <tr style="background-color: green; color:white;">
      <td colspan="2">높은 주소</td>
      <td>Stack</td>
      <td></td>
    </tr>
  </table></code>
  지역 변수 - 함수가 종료되면 stack frame과 함께 사라지는 임시 변수.
  <h4 class="mb-0">Stack Frame의 생성과 소멸</h4>
  함수가 호출될 때마다 해당 정보는 stack memory에 쌓이는데 이것을 <strong>stack frame</strong>이라고 부른다.
  <ul style="list-style-type: decimal;">
    <li>함수가 호출되면 stack에 frame이 생긴다.</li>
    <li>Stack frame은 각각 분리되어 있다.</li>
    <li>Frame으로 분리된 변수들을 지역 변수라고 부른다.</li>
    <li>함수 호출 순서대로 stack에 생성되고 역순으로 소멸한다.</li>
    <li>Stack의 내용이 최대 영역을 초과하면 <strong>Stack Overflow</strong>가 발생한다.</li>
  </ul>
  <h3 class="title mb-0">반환값이 없는 함수</h3>
  반환값의 자료형을 <strong><code>Unit</code></strong>으로 지정하거나 <strong>생략</strong>한다.<br>
  Unit은 Java의 void형에 대응되지만 void는 정말로 아무것도 반환하지 않고 Unit은 특수한 객체를 반환한다.
  <h3 class="title mb-0">매개변수 제대로 활용하기</h3>
  매개변수에 기본값을 설정할 수 있다.
  <pre>
fun add(name: String, email: String = "nothing") {
  // name, email을 회원 목록에 저장한다.
  // email에 전달된 인자가 없으면 기본값으로 설정된 "nothing"를 사용한다.
}

add("peter", "peter@superhero.com")
add("parker") // email 값으로 "nothing"이 사용된다.
</pre>
  <h4>매개변수 이름과 함께 함수 호출하기</h4>
  <pre>
fun main() {
  namedParam(x = 10, y = 20)
}

fun namedParam(x: Int, y: Int) { }
</pre>
  <h4>매개변수의 개수가 고정되지 않은 함수 사용하기 <strong><code>vararg</code></strong></h4>
  가변 인자 <sub>Variable Argument</sub>를 사용한다.
  <pre>
fun main() {
  show(1, 2, 3)
}

fun show(<strong>vararg</strong> counts: Int) {
  for (i <strong style="line-height: 1rem;">in</strong> counts)
      print(i)
}<hr>>> 123
</pre>
  <h2 class="title"><span class="titleNumber">03-2</span>함수형 <sub>Functional</sub> Programming</h2>
  <h3 class="title mb-0">함수형 Programming이란?</h3>
  순수 함수를 작성하여 program의 부작용을 줄이는 programming 기법이다.
  <h4>순수 함수</h4>
  <ul class="mt-0">
    <li>함수가 같은 인자에 대하여 항상 같은 결과를 반환하면 '<b>부작용이 없는 함수</b>'라고 한다.</li>
    <li>이런 함수가 함수 외부의 어떤 상태도 바꾸지 않는다면 순수 함수<sub>Pure Function</sub>라고 한다.</li>
    <li>이런 특성 덕분에 순수 함수는 thread에 사용해도 안전하고 code를 test하기도 쉽다.</li>
  </ul>
  <h4>일급 객체 <sub>First Class Citizen</sub></h4>
  <ul class="mt-0">특징
    <li>함수의 인자로 전달할 수 있다.</li>
    <li>함수의 반환값에 사용할 수 있다.</li>
    <li>변수에 담을 수 있다.</li>
  </ul>
  함수가 일급 객체면 일급 함수라고 부른다.<br>일급 함수에 이름이 없는 경우 Lambda 함수 혹은 Lambda식이라고 부른다.
  <h4>람다식 <sub>Lambda Express</sub></h4>
  <ul class="mt-0">
    <li>일급 객체의 특징을 가진 이름 없는 함수
      <ul>
        <li>다른 함수의 인자로 넘기는 함수</li>
        <li>함수의 결괏값으로 반환하는 함수</li>
        <li>변수에 저장하는 함수</li>
      </ul>
    </li>
  </ul>
  <h4 class="mb-0">고차 함수 <sub>High Order Function</sub></h4>
  인자나 반환값으로 함수를 사용할 수 있다.
  <pre>
fun main() {
  val x = highFunc(<strong>{ a, b -> a + b }</strong>, 1, 2)
  println(x)
}

fun highFunc(sum: <strong>(Int, Int) -> Int</strong>, a: Int, b: Int) = sum(a, b)</pre>
  <h4>함수형 Programming의 정의와 특징</h4>
  <ul class="mt-0">
    <li>순수 함수를 사용해야 한다.</li>
    <li>Lambda식을 사용할 수 있다.</li>
    <li>고차 함수를 사용할 수 있다.</li>
  </ul>
  <h2 class="title"><span class="titleNumber">03-3</span>고차 함수와 Lambda식</h2>
  <h3 class="title">고차 함수의 형태</h3>
  <h4><i>일반 함수</i> 를 인자나 반환값으로 사용하는 고차 함수</h4>
  <pre>
fun main() {
  val res = sum(3, 2)
  val res2 = mul(<strong>sum(3, 3)</strong>, 3)

  println("$res, $res2")
}

fun sum(a: Int, b: Int) = a + b
fun mul(a: Int, b: Int) = a * b

fun test(): Int {
  return <strong>sum(2, 2)</strong>
}</pre>
  <h4><i>Lambda식</i> 을 인자나 반환값으로 사용하는 고차 함수</h4>
  <h4 class="mt-0"><i>Lambda식</i> 을 변수에 할당하는 경우</h4>
  <pre>
fun main() {
  val multi: (Int, Int) -> Int = <strong>{ x: Int, y: Int -> x * y }</strong> // 일반 변수에 lambda식 할당.
  val res: Int = <strong style="line-height: 1rem;">multi</strong>(10, 20) // Lambda식이 할당 된 변수는 함수처럼 사용할 수 있다.
}</pre>
  <code>
<table class="no-border" style="text-align: center; background-color: skyblue; border-radius: .25rem;">
  <caption style="font-size: 1rem;">Lambda식의 선언과 할당</caption>
  <tr>
    <td rowspan="3"></td>
    <td></td>
    <td rowspan="3"></td>
    <td>lambda식의 자료형 선언</td>
    <td></td>
    <td>lambda식의 매개변수</td>
    <td></td>
    <td>lambda식의 처리 내용</td>
    <td></td>
  </tr>  
  <tr style="font-size: 1.25rem; font-weight: bolder;">
    <td class="bg-ws" style="border-radius: .25rem;">val multi</td>
    <td class="bg-ws" style="border-radius: .25rem;">: (Int, Int) -> Int</td>
    <td>= {</td>
    <td class="bg-ws" style="border-radius: .25rem;">x: Int, y: Int</td>
    <td>-></td>
    <td class="bg-ws" style="border-radius: .25rem;">x * y</td>
    <td>}</td>
  </tr>
  <tr>
    <td>변수를<br>함수처럼<br>사용 가능</td>
    <td>lambda식 매개변수에<br>자료형이 명시된 경우<br>생략 가능</td>
    <td></td>
    <td>자료형이<br>선언되어 있으면<br>생략 가능</td>
    <td></td>
    <td>함수의 내용과 결과 반환,<br>표현식이 여러 줄인 경우<br>마지막 표현식이 반환</td>
    <td></td>
  </tr>  
</table></code>
  <pre>
val multi:(Int, Int) -> Int = { x: Int, y: Int -> x * y }
val multi:(Int, Int) -> Int = { x, y -> x * y }
val multi = { x: Int, y: Int -> x * y }

val multi = { x, y -> x * y } // <span class="red">Error!</span> 자료형을 추론할 수 없다!

val greet: <strong>() -> Unit</strong> = { println("Hello") } // 매개변수가 없으므로 lambda 식에서 매개변수 선언 부분과 '->' 생략.
val greet = { println("Hello") } // 추론 가능

val square: <strong>(Int) -> Int</strong> = { x -> x * x }
val square = { x<strong style="line-height: 1rem;">: Int</strong> -> x * x }

val nestedLambda: <strong>() -> () -> Unit</strong> = { { println("중첩") } }
val nestedLambda = { { println("중첩") } } // 추론 가능</pre>
  <pre>
val multi2 = { x: Int, y: Int ->
  print("x * y = ")
  <strong>x * y</strong> // 마지막 표현식이 반환
}

println(multi2(3, 4))</pre>
  <h4><i>Lambda식</i> 을 매개변수에 사용하는 경우</h4>
  <pre>
  fun main() {
    val result = highOrder(<strong>{ x, y -> x + y }</strong>, 10, 20)
    println(result) // 30
}

fun highOrder(<strong>sum: (Int, Int) -> Int</strong>, a: Int, b: Int): Int = sum(a, b)</pre>
  <h4>인자와 반환값이 없는 lambda식</h4>
  <pre>
fun main() {
  // val out: () -> Unit = { println("Hello") }
  val out = { println("Hello") }
  out()

  val out2 = out
  out2()
}</pre>
  <h3 class="title">Lambda식과 고차 함수 호출하기</h3>
  <ul class="mt-0">
    <li>기본형 변수로 할당된 값은 stack에 있다.</li>
    <li>다른 함수에 인자로 전달하는 경우에는 해당 값이 복사되어 전달된다.</li>
    <li>참조형 변수로 할당된 객체는 참조 주소가 stack에 있고 객체는 heap에 있다.</li>
    <li>참조형 객체는 함수에 전달될 때 참조된 주소가 복사되어 전달된다.</li>
    <li>JVM에서 실행되는 Java나 Kotlin은 함수를 호출할 때 인자의 값을 복사하는 '값에 의한 호출' <sub>Call by value</sub> 방식을 사용한다.</li>
  </ul>
  <h4>값에 의한 호출</h4>
  함수가 인자로 전달될 경우 lambda식 함수는 값으로 처리되어 그 즉시 함수가 수행된 후 그 결과 값을 전달한다.
  <pre>
fun main() {
  val result = callByValue(<strong>lambda()</strong>) // lambda식 함수를 호출
  println(result)
}

// 일반 변수 자료형으로 선언된 매개변수
fun callByValue(<strong>b: Boolean</strong>): Boolean {
  println("callByValue function")
  return b
}

val <strong>lambda: () -> Boolean</strong> = {
  println("lambda function")
  true
}<hr>>>
lambda function
callByValue function
true</pre>
  <h4>이름에 의한 Lambda식 호출</h4>
  <pre>
fun main() {
  val result = callByName(<strong>otherLambda</strong>) // lambda식 이름으로 호출
  println(result)
}

// lambda식 자료형으로 선언된 매개변수
fun callByName(b: <strong>() -> Boolean</strong>): Boolean {
  println("callByName function")
  return <strong>b()</strong> // 여기서 lambda식 함수를 호출
}

val otherLambda: () -> Boolean = {
  println("otherLambda function")
  true
}<hr>>>
callByName function
otherLambda function
true</pre>
  <h4>다른 함수의 참조에 의한 일반 함수 호출 <strong>::</strong></h4>
  <pre>
fun main() {
  val result = funcParam(3, 2, <strong>::sum</strong>)
  println("result = $result")
}

fun sum(a: Int, b: Int) = a + b

fun funcParam(a: Int, b: Int, c: <strong>(Int, Int) -> Int</strong>): Int {
  return c(a, b)
}<hr>>>
result = 5</pre>
  <pre>
fun main() {
  // 인자와 반환값이 있는 함수
  val res1 = funcParam(3, 2, <strong>::sum</strong>)
  println(res1)

  // 반환값이 없는 함수
  hello(<strong>::text</strong>)
  hello({ a, b -> text(a, b) }) // lambda식 표현
  hello { a, b -> text(a, b) }  // 소괄호 생략 가능

  // 일반 변수에 값처럼 할당
  val likeLambda = <strong>::sum</strong>
  println(likeLambda(6, 6))
}

fun sum(a: Int, b: Int) = a + b

fun funcParam(a: Int, b: Int, <strong>c: (Int, Int) -> Int</strong>): Int {
  return c(a, b)
}

fun text(a: String, b: String) = "Hi! $a $b"

fun hello(<strong>body: (String, String) -> String</strong>): Unit {
  println(body("Hello", "World"))
}<hr>>>
5
Hi! Hello World
Hi! Hello World
Hi! Hello World
12</pre>
  <h3 class="title">Lambda식의 매개변수</h3>
  <h4 class="mt-0">Lambda식에 매개변수가 없는 경우</h4>
  <pre>
fun main() {
  noParam({ "Hello World!" })
  noParam <strong>{ "Hello World!" }</strong> // () 생략 가능
}

fun noParam(out: <strong>() -> String</strong>) = println(<strong>out()</strong>)<hr>>>
Hello World!
Hello World!</pre>
  <h4>Lambda식의 매개변수가 1개인 경우</h4>
  <pre>
fun main() {
  oneParam({ a -> "Hello World! $a" })
  oneParam { a -> "Hello World! $a" }
  oneParam { "Hello World! <strong>$it</strong>" }
}

fun oneParam(out: <strong>(String) -> String</strong>) {
  println(out("One param"))
}<hr>>>
Hello World! One param
Hello World! One param
Hello World! One param</pre>
  <h4>Lambda식의 매개변수가 2개 이상인 경우</h4>
  <pre>
fun main() {
  moreParam { <strong>a, b</strong> -> "Hello World! <strong>$a $b</strong>" }
}

fun moreParam(out: <strong>(String, String) -> String</strong>) {
  println(out("OneParam", "TwoParam"))
}<hr>>>
Hello World! OneParam TwoParam</pre><br>
  Lambda식의 특정 매개변수를 사용하고 싶지 않을 때는 이름 대신에 '_' <sub>underscore</sub>로 대체할 수 있다.
  <pre>
moreParam { <strong>_</strong>, b -> "Hello World! $b" }
</pre>
  <h4>일반 매개변수와 Lambda식 매개변수를 같이 사용하기</h4>
  <pre>
fun main() {
  withArgs("Arg1", "Arg2", { x, y -> "Hello World! $x $y" })

  <strong>// 함수의 마지막 인자가 lambda식인 경우 () 바깥으로 분리 가능</strong>
  withArgs("Arg1", "Arg2") { x, y -> "Hello World! $x $y" }
}

fun withArgs(a: String, b: String, out: (String, String) -> String) = println(out(a, b))<hr>>>
Hello World! Arg1 Arg2
Hello World! Arg1 Arg2</pre>
  <h4>일반 함수에 Lambda식 매개변수를 2개 이상 사용하기</h4>
  <pre>
fun main() {
  twoLambda({ a, b -> "First $a $b" }, { "Second $it" })

  // 함수의 마지막 인자가 lambda식인 경우 () 바깥으로 분리 가능
  twoLambda({ a, b -> "First $a $b" }) { "Second $it" }
}

fun twoLambda(first: <strong>(String, String) -> String</strong>, second: <strong>(String) -> String</strong>) {
  println(first("OneParam", "TwoParam"))
  println(second("OneParam"))
}<hr>>>    
First OneParam TwoParam
Second OneParam
First OneParam TwoParam
Second OneParam</pre>
  <h2 class="title"><span class="titleNumber">03-4</span>고차 함수와 Lambda식의 사례 알아보기</h2>
  <h3 class="title mb-0">동기화를 위한 code 구현 구경하기</h3>
  <pre>
import java.util.concurrent.locks.ReentrantLock

var <strong>sharable</strong> = 1 // 보호가 필요한 공유 자원.

fun main() {
    val reLock = ReentrantLock()

    // 아래 3 표현식은 모두 같다.
    lock(reLock, { criticalFun() })
    lock(reLock) { criticalFun() }
    lock(reLock, ::criticalFun)

    println(sharable)
}

// 공유 자원을 변경하는 함수
fun criticalFun() {
    ++sharable 
}

// T는 Generic의 형식 매개변수
fun &lt;T> lock(reLock: ReentrantLock, body: <strong>() -> T</strong>): T {
    reLock.lock()
    try {
        return body()
    } finally {
        reLock.unlock()
    }
}<hr>>> 4</pre>
  <p>
    <span class="material-icons red" style="float:left">info</span><strong>Callback 함수</strong> : 특정 event가 발생하기 전까지 처리되지 않다가 event가 발생하면 즉시 호출되어 처리되는 함수.<br>
    사용자가 아닌 system이나 event에 따라 호출 시점이 결정된다.
  </p>
  <h2 class="title"><span class="titleNumber">03-5</span>Kotlin의 다양한 함수 알아보기</h2>
  <h3 class="title mb-0">익명 함수 <sub>Anonymous Function</sub></h3>
  이름이 없는 일반 함수.
  <pre>
<strong>fun</strong>(x: Int, y: Int): Int = x + y

// 동일한 표현
val add: (Int, Int) -> Int = fun(x, y) = x + y
val add = fun(x: Int, y: Int) = x + y

// 동일한 lambda식 표현
val add = { x: Int, y: Int -> x + y }</pre>
  Lambda식에서는 <code>return, break, continue</code> 같은 제어문을 사용하기 어려워서 익명함수를 사용한다.
  <h3 class="title mb-0">Inline 함수 <sub>Inline Function</sub></h3>
  함수가 호출되는 곳에 함수 본문의 내용을 모두 복사해 넣어 함수의 분기 없이 처리되기 때문에 성능을 높일 수 있다.
  <pre>
fun main() {
  shortFunc(3) { println("First call: $it") }
  shortFunc(5) { println("Second call: $it") }
}

<strong>inline</strong> fun shortFunc(a: Int, out: (Int)->Unit) {
  println("Before calling out()")
  out(a)
  println("After calling out()")
}</pre>
  <h4 class="mb-0">역컴파일 <sub>Decompile</sub>된 내용으로 inline 함수 살펴보기</h4>
  IntelliJ IDEA의 <kbd style="line-height: 1.5rem;">Tools > Kotlin > Show Kotlin Bytecode</kbd> 메뉴를 선택하고 Kotlin Bytecode 창에서 <kbd>Decompile</kbd> button을 누른다.<br>
  Decompile된 file이 .java인 이유는 현재 Kotlin이 JVM에서 수행되고 있어 내부적으로 Java code와 동일한 실행 문맥을 가지기 때문이다.
  <h4 class="mb-0">Inline 함수 제한하기 <strong>noinline</strong></h4>
  Inline 함수의 매개변수로 사용한 lambda식의 code가 너무 길거나 함수의 본문 자체가 너무 길면 compiler에서 성능 경고를 할 수 있다.<br>
  또 inline 함수가 너무 많이 호출되면 오히려 code 양만 늘어나서 좋지 않을 수 있다.
  <pre>
// 매개변수 lambda식들도 그대로 복사가 된다.
<strong>inline</strong> fun sub(out1: () -> Unit, out2: () -> Unit)

// out1만 복사가 되고, out2는 호출 방식으로 사용된다.
<strong>inline</strong> fun sub(out1: () -> Unit, <strong>noinline</strong> out2: () -> Unit)</pre>
  <h4 class="mb-0">Inline 함수와 비지역 반환 <sub>Non-local Return</sub></h4>
  <ul class="mt-0 mb-0">
    <li>Kotlin에서는 익명 함수를 종료하기 위해 <code>return</code>을 사용할 수 있다.<br>이때 특정 반환값 없이 <code>return</code>만 사용해야 한다.</li>
    <li><code>return</code>문은 lambda식 본문에 사용할 수 없다.</li>
    <li>Inline 함수에서 사용한 lambda식에서는 <code>return</code>을 사용할 수 있다.</li>
  </ul>
  <pre>
fun main() {
  shortFunc(3) {
      println("First call: $it")
      <strong>return</strong> // Non-local Return
  }
}

<strong>inline</strong> fun shortFunc(a: Int, out: (Int) -> Unit) {
  println("Before calling out()")
  out(a)
  println("After calling out()") // 실행이 안된다.
}<hr>>>
Before calling out()
First call: 3</pre>
  Lambda식에서 <code>return</code>문을 만났지만 바깥 함수인 shortFunc()가 반환되었다.<br><br>
  <pre>
  fun main() {
    shortFunc(3) {
        println("First call: $it")
        <strong>return@shortFunc</strong>
    }
}

inline fun shortFunc(a: Int, out: (Int) -> Unit) {
    println("Before calling out()")
    out(a)
    println("After calling out()")
}<hr>>>
Before calling out()
First call: 3
After calling out()</pre><br>
  out()을 직접 호출해 사용하지 않고 또 다른 함수로 전달하면 실행 문맥이 달라져서 <code>return</code>을 사용할 수 없다.<br>
  이때 비지역 반환을 금지하기 위해 <strong>crossinline</strong>을 사용한다.
  <pre>
fun main() {
  shortFunc(3) {
      println("First call: $it")
      return@shortFunc // 그냥 return은 사용불가.
  }
}

inline fun shortFunc(a: Int, <strong>crossinline</strong> out: (Int) -> Unit) {
  println("Before calling out()")
  <strong>nestedFunc { out(a) }</strong>
  println("After calling out()")
}

fun nestedFunc(body: () -> Unit) {
  body()
}<hr>>>
Before calling out()
First call: 3
After calling out()</pre>
  <h3 class="title mb-0">확장 함수 <sub>Extension Function</sub></h3>
  Class처럼 필요한 대상에 함수를 더 추가할 수 있다.
  <pre>
fun 확장대상.함수이름(매개변수, ...): 반환값 {
  ...
  return 값
}</pre>
  <h4 class="mb-0">String class에 나만의 확장 함수 추가하기</h4>
  <pre>
fun main() {
  println("Hello World!".getLongerString("Kotlin"))
}

// 더 긴 문자열을 반환하는 함수
fun <strong>String.</strong><span style="color:#0f0">getLongerString</span>(other: String): String {
  return when (length > other.length) {
      true -> this
      else -> other
  }
}<hr>>> Hello World!</pre>
  확장 대상에 확장 함수와 같은 이름의 member method가 있다면 항상 member method가 먼저 호출된다.
  <h3 class="title mb-0">중위 함수 <sub>Infix Function</sub> : <strong><code>infix</code></strong></h3>
  중위 표현법 <sub>Infix Notation</sub> 이란 class의 member를 호출할 때 사용하는 '.'을 생략하고 함수 이름 뒤에 ()를 붙이지 않아 직관적인 이름을 사용할 수 있는 표현법이다.<br>
  일종의 연산자를 구현할 수 있는 함수를 말한다.
  <ul><b>중위 함수의 조건</b>
    <li>Member method 또는 확장 함수여야 한다.</li>
    <li>하나의 매개변수를 가져야 한다.</li>
    <li><strong>infix</strong> keyword를 사용해서 정의한다.</li>
  </ul>
  <pre>
fun main() {
  val a = 3.multiply(4) // 12
  val b = <strong>3 multiply 4</strong> // 12
}

<strong>infix</strong> fun Int<strong>.multiply</strong>(other: Int): Int {
  return this * other
}</pre>
  <h3 class="title mb-0">꼬리 재귀 함수 <sub>Tail Recursive Function</sub> : <strong><code>tailrec</code></strong></h3>
  <b>재귀 <sub>Recursion</sub></b> : 자기 자신을 다시 참조하는 방법
  <ul><b>재귀 함수의 조건</b>
    <li>무한 호출에 빠지지 않도록 탈출 조건을 만들어 준다. Stack Overflow 주의!</li>
    <li>Stack 영역을 이용하므로 호출 횟수를 무리하게 많이 지정해 연산하지 않는다.</li>
    <li>Code를 복잡하지 않게 한다.</li>
  </ul>
  <h4 class="mb-0">factorial 재귀 함수로 stack overflow 경험하기</h4>
  <pre>
fun main() {
  val n = 4
  val result = factorial(n)

  println("$n! = $result")
}

fun <strong>factorial</strong>(n: Int): Long {
  return when {
      n &lt; 2 -> 1L
      else -> n * <strong>factorial</strong>(n - 1)
  }
}<hr>>> 4! = 24</pre>
  <h4 class="mb-0">꼬리 재귀로 stack overflow 방지하기</h4>
  <pre>
<strong>tailrec</strong> fun factorial(n: Int, result: Int = 1): Long {
  return when {
      n &lt; 2 -> result.toLong()
      
      // 인자 안에서 factorial의 도중 값을 계산하고 호출한다.
      else -> <strong>factorial(n - 1, result * n)</strong> 
  }
}

fun main() {
  val n = 4
  val result = <strong>factorial(n)</strong>

  println("$n! = $result")
}<hr>>> 4! = 24</pre>
  <h4 class="mb-0">fibonacci 수열 재귀 함수와 꼬리 재귀 함수</h4>
  <pre>
import java.math.BigInteger

fun main() {
    val n = 100
    val first = BigInteger("0")
    val second = BigInteger("1")
    val result = fibonacci(n, first, second)
    println("Fibonacci($n) = $result")

}

<strong>tailrec</strong> fun fibonacci(n: Int, first: BigInteger, second: BigInteger): BigInteger {
    return when(n) {
        0 -> first
        else -> fibonacci(n - 1, second, first + second)
    }
}<hr>>> Fibonacci(100) = 354224848179261915075</pre>
  <h2 class="title"><span class="titleNumber">03-6</span>함수와 변수의 범위</h2>
  <h3 class="title">함수의 범위</h3>
  <h4>최상위 함수 <sub>Top-Level Function</sub>와 지역 함수 <sub>Local Function</sub></h4>
  <pre>
/* SampleFile.kt */

// 사용자가 만든 최상위 함수 선언
fun userFunc1() {
  ...
}

// 최상위 함수
<strong>fun main()</strong> {
  ...

  // 지역 함수 선언. 사용하기 전에 반드시 먼저 선언해야 한다.
  fun localFunc() {
    ...
  }

  // 사용자 함수 사용 : 선언부의 위치에 상관없이 사용 가능.
  userFunc1()   
  userFunc2()

  // 지역 함수 사용 : 지역 함수를 먼저 선언해야 한다.
  localFunc() 
}

// 사용자가 만든 최상위 함수 선언
fun userFunc2() {
  ...
}</pre>
  사용자가 만든 최상위 함수는 <code>main()</code> 함수의 앞이나 뒤에 선언해도 <code>main()</code> 함수 안에서 사용할 수 있다.
  <h4>최상위 및 지역 함수의 사용 범위</h4>
  <pre>
// SampleFile.kt

fun a() = b()
fun b() = {}

fun c() {
  fun d() = e() // <span class="red">Error!</span> e 함수를 먼저 선언해야 한다.
  fun <strong>e()</strong> = {}
}

fun main() {
  a()
  e() // <span class="red">Error!</span> c 함수 안에서만 유효한 지역 함수다.
}</pre>
  <h3 class="title">변수의 범위</h3>
  <h4>지역 변수 <sub>Local Variable</sub>와 전역 변수 <sub>Global Variable</sub></h4>
  <ul>
    <li>지역 변수 : 특정 code block 안에 있는 변수. Block을 벗어나면 memory에서 삭제된다.</li>
    <li>전역 변수 : 최상위에 있는 변수. Program이 실행되는 동안 삭제되지 않고 memory에 유지된다.</li>
  </ul>
  <pre>
// SampleFile.kt
package com.sample

// com.sample package에서 모두 접근할 수 있는 전역 변수.
// 파일이 달라도 package가 같다면 접근할 수 있다.
var global = 10 

fun main() {
    // main() 안에서만 유지되는 지역 변수.
    val localOne = 10
    val localTwo = 20

    fun localFunc() {
        global += 1
        val localOne = 30 // main()의 localOne을 가린다.

        println(localOne)
        println(localTwo)
        println(global)
    }

    localFunc()
    topFunc()

    println(localOne)
    println(localTwo)
    println(global)
}

fun topFunc() {
    global += 1
    val outVal = "outside"

    println(global)
    println(outVal)
}</pre>
  <hr>
  <h1><span class="titleNumber">04</span>프로그램의 흐름 제어</h1>
  <h2 class="title"><span class="titleNumber">04-1</span>조건문</h2>
  <h3 class="title">if문과 if~else문</h3>
  <h4>if문과 if~else문을 이용한 큰 수 판단하기</h4>
  <pre>
var max: Int
if (a > b)
    max = a // 수행할 문장이 한 줄이면 {}를 생략할 수 있다.
els
    max = b<hr>val max = if (a > b) a else b</pre>
  <h4>Block의 표현식이 길어질 때 <code>{}</code>로 감싸야 한다.</h4>
  <pre>
fun main() {
  val a = 12
  val b = 7

  val max = if (a > b) {
      println("a 선택")
      a // 마지막 식이 반환되어 max에 할당된다.
  } else {
      println("b 선택")
      b
  }

  println("max = $max")
}<hr>>>
a 선택
max = 12</pre>
  <h3 class="title mb-0"><code>else if</code>문으로 조건문 중첩하기</h3>
  <pre>
val number = 0
val result = if (number > 0)
    "양수"
else if (number &lt; 0)
    "음수"
else
    "0"</pre>
  <pre>
fun main() {
  print("Enter the score: ")

  val score = try {
    // console로부터 문자열을 입력받는 함수. 표준 library.
      <strong>readLine()</strong>?.toDouble() ?: 0.0
  } catch (e: <strong style="line-height: 1rem;">NumberFormatException</strong>) {
      0.0
  }

  val grade = if (score > 89.9)
      'A'
  else if (score <strong>in</strong> 80.0<strong>..</strong>89.9)
      'B'
  else if (score in 70.0..79.9)
      'C'
  else
      'F'

  println("Score: $score, Grade: $grade")
}<hr>>> Enter the score: 88
Score: 88.0, Grade: B</pre>
  <h4><strong>in</strong> 연산자의 범위 연산자로 조건식 간략하게 만들기</h4>
  <pre>변수이름 <strong>in</strong> 시작값<strong>..</strong>마지막값</pre>
  <h3 class="title"><code>when</code>문으로 다양한 조건 처리하기</h3>
  <h4>인자를 사용하는 when문</h4>
  <pre>
<strong>when</strong> (x) {
  1 <strong>-></strong> print("x is One")
  2 -> print("x is Two")
  <strong>else</strong> -> print("x is not One, Two")
}<hr>when (x) {
  1<strong>,</strong> 2 -> print("x is One or Two")
  else -> print("x is etc")
}</pre>
  <h4><code>when</code>문에 함수의 반환값 사용하기</h4>
  <pre>
when (x) {
  parseInt(s) -> print("일치!") // 함수의 반환값이 x와 같은 경우.
  else -> print("기타")
}</pre>
  <h4><code>when</code>문에 <code>in</code> 연산자와 범위 지정자 사용하기</h4>
  <pre>
when (x) {
  <strong>in</strong> 1..10 -> print("x는 1과 10 사이의 값이다.")
  <strong style="line-height: 1rem;">!in</strong> 10..20 -> print("x는 10과 20사이의 값이 아니다.")
  else -> print("x는 어떤 ")
}</pre>
  <h4 class="mb-0"><code>when</code>과 <code>is</code> keyword 함께 사용하기</h4>
  <code>is</code>를 사용하면 특정 자료형을 검사할 수 있다.
  <pre>
val str: Any = "Hello"
val result = when (str) {
  <strong>is</strong> String -> "문자열"
  else -> false
}</pre>
  <h4 class="mb-0">인자가 없는 <code>when</code>문</h4>
  조건이나 표현식을 직접 만들 수 있다.
  <pre>
fun main() {
  print("Enter the score: ")

  val score = try {
      readLine()?.toDouble() ?: 0.0
  } catch (e: NumberFormatException) {
      0.0
  }

  val grade = when {
      <strong>score >= 90.0</strong> -> 'A'
      score in 80.0..89.9 -> 'B'
      score in 70.0..79.9 -> 'C'
      else -> 'F'
  }

  println("Score: $score, Grade: $grade")
}</pre>
  <h4>다양한 자료형의 인자 받기</h4>
  <pre>
fun main() {
  cases("Hello")
  cases(1)
  cases(System.currentTimeMillis())
  cases("something")
  cases(MyClass())
}

fun cases(obj: <strong>Any</strong>) {
  println(
      when (obj) {
          1 -> "Int: $obj"
          "Hello" -> "String: $obj"
          is Long -> "Long: $obj"
          !is String -> "Not a String: $obj"
          else -> "Unknown: $obj"
      })
}

class MyClass {}<hr>>>
String: Hello
Int: 1
Long: 1622544178239
Unknown: something
Not a String: MyClass@610455d6</pre>
  <h2 class="title"><span class="titleNumber">04-2</span>반복문</h2>
  <h3 class="title mb-0"><code>for</code>문</h3>
  <pre>
// Java
for (int i = 0; i &lt; 5; ++i) { ... }

// Kotlin
for (i in 0..4) { ... }</pre>
  <h4 class="mb-0">값 증감에 따른 다양한 반복 방법</h4>
  <pre>
for (i in 1<strong>..</strong>5) print(i) // 12345

for (i in 5 <strong>downTo</strong> 1) print(i) // 54321

for (i in 1..5 <strong>step</strong> 2) print(i) // 135</pre>
  <h3 class="title mb-0"><code>while</code>문</h3>
  <pre>
// 조건식이 true인 동안 반복한다.
// 처음부터 조건이 false면 한번도 실행하지 않는다.
<strong>while</strong> (조건식) {
  ...
}</pre>
  <h3 class="title mb-0"><code>do-while</code>문</h3>
  <pre>
// 최소 한번은 실행한다.
<strong>do</strong> {
  ...
} <strong>while</strong> (조건식)</pre>
  <h2 class="title"><span class="titleNumber">04-3</span>흐름의 중단과 반환</h2>
  <ul><b>흐름 제어문</b>
    <li><code>return</code> : 함수에서 결괏값을 반환하거나 지정된 label로 이동한다.</li>
    <li><code>break</code> : 반복문의 조건식에 상관없이 반복문을 끝낸다.</li>
    <li><code>continue</code> : 반복문의 나머지 본문을 수행하지 않고 바로 조건식 검사로 넘어간다.</li>
  </ul>
  <ul><b>예외 처리문</b>
    <li><code>try {...} catch {...}</code> : <code>try</code> block을 수행하는 도중 예외가 발생하면 <code>catch</code> block을 실행한다.</li>
    <li><code>try {...} catch {...} finally {...}</code> : 예외 발생 여부와 상관 없이 <code>finally</code> block는 항상 실행한다.</li>
  </ul>
  <h3 class="title mb-0"><code>return</code>문</h3>
  <h4 class="mb-0 mt-0"><code>return</code>으로 값 반환하기</h4>
  <pre>
fun add(a: Int, b: Int): Int {
  <strong>return</strong> a + b

  println("이 줄은 실행되지 않는다!")
}</pre>
  <h4><code>return</code>으로 <code>Unit</code> 반환하기</h4>
  <pre>
// 아래 3경우는 모두 같다.

fun hello(name: String)<strong>: Unit</strong> {
  println(name)
  <strong>return Unit</strong>
}

fun hello(name: String)<strong>: Unit</strong> {
  println(name)
  <strong>return</strong>
}

// 둘다 생략
fun hello(name: String) {
  println(name)
}</pre>
  생략할 경우 Kotlin compiler는 <code>Unit</code>을 반환하는 것으로 가정한다.
  <p><span class="material-icons red">info</span>Lambda식에서 <code>return</code>은 label 표기와 함께 사용해야 하고 <code>break</code>와 <code>continue</code>는 아직 지원하지 않는다.</p>
  <h4>Lambda식에서 <code>return</code> 사용하기</h4>
  <ul>
    <li><code>inline</code>으로 선언되지 않는 lambda식에는 <code>return</code>을 그냥 사용할 수 없다.</li>
    <li><code>return@label</code>과 같이 label 표기와 함께 사용해야 한다.</li>
    <li><b>Label</b>이란 code에서 특정한 위치를 임의로 표시한 것으로 <strong>@ 기호와 이름</strong>을 붙여서 사용한다.</li>
    <li>inline으로 선언된 함수에서 lambda식을 매개변수로 사용하면 lambda식에서 <code>return</code>을 사용할 수 있다. <strong>Non-local Return</strong>
      <pre>
fun main() {
  myFunc()
}

<strong>inline</strong> fun inlineLambda(a: Int, b: Int, <strong>out: (Int, Int) -> Unit</strong>) {
  out(a, b)
}

fun myFunc() {
  println("Start myFunc()")

  inlineLambda(10, 3) {
      a, b ->
      if (a + b > 10)
          <strong>return</strong> // Non-local Return. inlineLambda()가 아니라 myFunc()에서 나간다. ↙①로 이동.

      println("a + b = ${a + b}")
  }

  println("End myFunc()")
} // ---------------- ①
<hr>>> Start myFunc()</pre>
    </li>
  </ul>
  <h4>Lambda식에서 label과 함께 <code>return</code> 사용하기</h4>
  <pre>
람다식_함수이름 <strong>Label이름@</strong> {
  ...
  <strong>return@Label이름</strong>
}</pre>
  <pre>
fun main() {
  myFunc()
}

// inline 함수가 아니다.
fun inlineLambda(a: Int, b: Int, <strong>out: (Int, Int) -> Unit</strong>) {
  out(a, b)
}
  
fun myFunc() {
  println("Start myFunc()")

  inlineLambda(10, 3) <strong>lit@</strong> {
      a, b ->
      if (a + b > 10)
          <strong>return@lit</strong> // inlineLambda()에서 나간다. ↙①로 이동한다. 

      println("a + b = ${a + b}")
  } // ---------------- ①

  println("End myFunc()")
}<hr>>>
Start myFunc()
End myFunc()</pre>
  <h4 class="mb-0">암묵적 label</h4>
  Lambda식을 인자로 가진 함수 이름을 그대로 label처럼 사용할 수 있다.
  <pre>
fun myFunc() {
  println("Start myFunc()")

  <strong>inlineLambda</strong>(10, 3) {
      a, b ->
      if (a + b > 10)
          <strong>return@inlineLambda</strong> // inlineLambda()에서 나간다. ↙①로 이동한다.

      println("a + b = ${a + b}")
  } // ---------------- ①

  println("End myFunc()")
}</pre>
  <h4 class="mb-0">익명 함수를 사용한 반환</h4>
  <pre>
fun myFunc() {
  println("Start myFunc()")

  inlineLambda(10, 3, <strong>fun (a, b)</strong> {
    if (a + b > 10)
      <strong>return</strong> // inlineLambda()에서 나간다. ↙①로 이동한다. 

    println("a + b = ${a + b}")
  }) // ---------------- ①

  println("End myFunc()")
}

// Lambda식을 사용한 반환
val getMessage = <strong>lambda@</strong> {
  num: Int ->
    if (num !in 1..100)
      <strong>return@lambda "Error"</strong> // label을 통한 값 반환

    <strong>"Success"</strong> // 마지막 식이 반환
}

// 익명 함수를 사용한 반환
val getMessage = fun (num: Int) {
  if (num !in 1.. 100)
    <strong>return</strong> "Error"
  
  <strong>return</strong> "Success"
}

val result = getMessage()</pre>
  <h4 class="mb-0">Lambda식과 익명 함수를 함수에 할당할 때 주의할 점</h4>
  <pre>
// 함수에 lambda식 할당
fun greet() = { println("Hello") }
greet() // do nothing! 그냥 lambda식 자체.
greet()() // "Hello!"

// 함수가 할당됨을 명시적으로 표현하려면 익명 함수를 사용하는게 더 읽기 좋다.
fun greet() = <strong>fun()</strong> { println("Hello!") }
greet() // Hello!</pre>
  <h3 class="title mb-0"><code>break</code>문과 <code>continue</code>문</h3>
  <pre>
for (i in 1..5) {
  if (i == 3) <strong>break</strong> // ↙①
  print(i)
} // ①
println()
print("outside")<hr>>>
12
outside</pre>
  <pre>
for (i in 1..5) { // ①
  if (i == 3) <strong>continue</strong> // ↖①
  print(i)
}
println()
print("outside")<hr>>>
1245
outside</pre>
  <h4><code>break</code>와 <code>continue</code>에 label 함께 사용하기</h4>
  <pre>
fun myFunc() {
  println("start myFunc")
  for (i in 1..5) {
      for (j in 1..5) {
          if (j == 3) <strong>break</strong> // ↙①
          println("i=$i, j=$j")
      } // ---------------- ①
      println("after for j")
  }
  println("after for i")
}<hr>>>
start myFunc
i=1, j=1
i=1, j=2
after for j
i=2, j=1
i=2, j=2
after for j
i=3, j=1
i=3, j=2
after for j
i=4, j=1
i=4, j=2
after for j
i=5, j=1
i=5, j=2
after for j
after for i</pre>
  <pre>
// 2중 for문을 한번에 나갈때 편하다.
fun myFunc() {
  println("start myFunc")
  <strong>first@</strong> for (i in 1..5) {
      for (j in 1..5) {
          if (j == 3) <strong>break@first</strong> // ↙①
          println("i=$i, j=$j")
      }
      println("after for j")
  } // ---------------- ①
  println("after for i")
}<hr>>>
start myFunc
i=1, j=1
i=1, j=2
after for i</pre>
  <pre>
fun myFunc() {
  println("start myFunc")
  <strong>first@</strong> for (i in 1..5) {
      for (j in 1..5) {
          if (j == 3) <strong>continue@first</strong>
          println("i=$i, j=$j")
      }
      println("after for j")
  }
  println("after for i")
}<hr>>>
start myFunc
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
i=4, j=1
i=4, j=2
i=5, j=1
i=5, j=2
after for i</pre>
  <h3 class="title mb-0">예외 <sub>Exception</sub> 처리</h3>
  Program이 제대로 작동하지 못하고 중단되는 현상을 <b>예외</b>라고 한다.<br>
  대부분의 Error는 code 작성하는 도중에 compiler가 잡아낼 수 있지만 실행 도중의 잠재적 오류(Memory 부족, file 손상 같은)까지 검사할 수 없다.
  <ul><b>예외를 발생시키는 상황들</b>
    <li>운영체제의 문제. 잘못된 system 호출의 문제.</li>
    <li>입력값의 문제. 존재하지 않는 file 또는 숫자 입력란에 문자 입력 등.</li>
    <li>받아 들일 수 없는 연산. <code class="no-bgc">0</code>으로 나누기 등.</li>
    <li>Memory 할당 실패 및 부족</li>
    <li>Computer 자체의 문제. 전원, 망가진 기억 장치 등.</li>
  </ul>
  <pre>
// 예외 처리
<strong>try</strong> {
  예외 발생 가능성 있는 문장
} <strong>catch</strong> (e: 예외 처리 class 이름) {
  예외를 처리하기 위한 문장
} <strong>finally</strong> {
  반드시 실행되어야 하는 문장
}</pre>
  <pre>
fun main() {
  try {
      val c = 6 / 0
      println(c)
  } catch (e: Exception) {
      println(e)
  } finally {
      println("finally block은 반드시 실행된다.")
  }
}<hr>>>
java.lang.ArithmeticException: / by zero
finally block은 반드시 실행된다.  
</pre>
  <h4 class="mb-0">특정 예외 처리</h4>
  <pre>
...
} catch (e: <strong>ArithmeticException</strong>) {
  println(e.message)
}</pre>
  <h4 class="mb-0">Stack의 추적</h4>
  <pre>
...
} catch (e: Exception) {
  e.printStackTrace()
}<hr>>>
java.lang.ArithmeticException: / by zero
	at HelloKotlinKt.main(HelloKotlin.kt:3)
	at HelloKotlinKt.main(HelloKotlin.kt)
finally block은 반드시 실행된다.</pre>
  <span class="material-icons red">info</span><code class="no-bgc">println()</code>은 <code>System.out</code>을 사용하고 오류 출력은 <code>System.err</code>을 사용한다.
  <h4>예외 발생시키기 : <strong>throw</strong></h4>
  <pre><strong>throw</strong> Exception(message: String)</pre>
  <pre>
fun main() {
  val amount = 500

  try {
      checkAmount(amount)
  } catch (e: Exception) {
      println(e.message)
  }

  println("amount = $amount")
}

fun checkAmount(amount: Int) {
  if (amount &lt; 1000)
      <strong>throw Exception("잔고가 ${amount}으로 1000 이하입니다.")</strong>
}<hr>>>
잔고가 500으로 1000 이하입니다.
amount = 500</pre>
  <h4 class="mb-0">사용자 정의 예외</h4>
  <pre>class 사용자_예외_class_이름(message: String) : Exception(message)</pre>
  <pre>
import java.lang.Exception

class <strong>InvalidNameException</strong>(message: String) : Exception(message)

fun main() {
    try {
        validateName("peter parker 1962")
    } catch (e: <strong>InvalidNameException</strong>) { // 숫자가 포함된 이름 예외 처리
        println(e)
    } catch(e: Exception) { // 기타 예외 처리
        println(e)
    }
}

fun validateName(name: String) {
    if (name.matches(Regex(".*\\d+.*"))) {
        <strong>throw</strong> <strong>InvalidNameException</strong>("Your name is $name, contains number.")
    }
}<hr>>>
InvalidNameException: Your name is peter parker 1962, contains number.  
</pre>
  <hr>
  <h1 class="madang"><span class="madang_number">둘째 마당</span><br>객체 지향 프로그래밍 <sub>OOP</sub><br><sub>Object Oriented Programming</sub></h1>
  <h1><span class="titleNumber">05</span>Class와 객체</h1>
  <h2 class="title"><span class="titleNumber">05-1</span>Class와 객체의 정의</h2>
  객체 지향 Programming : Program의 구조를 객체 간 상호작용으로서 표현하는 programming 방식이다.<br>
  <table>
    <tr>
      <th>개념</th>
      <th>설명</th>
    </tr>
    <tr>
      <td>추상화 <sub>Abstraction</sub></td>
      <td>특정 class를 만들 때 기본 형식을 규정하는 방법</td>
    </tr>
    <tr>
      <td>Instance</td>
      <td>Class로부터 생성한 객체</td>
    </tr>
    <tr>
      <td>상속 <sub>Inheritance</sub></td>
      <td>부모 class의 내용을 자식 class가 그대로 물려 받는 것</td>
    </tr>
    <tr>
      <td>다형성 <sub>Polymorphism</sub></td>
      <td>하나의 이름으로 다양한 처리를 제공</td>
    </tr>
    <tr>
      <td>캡슐화 <sub>Encapsulation</sub></td>
      <td>내용을 숨기고 필요한 부분만 사용</td>
    </tr>
    <tr>
      <td>메시지 전송 <sub>Message Sending</sub></td>
      <td>객체 간에 주고받는 message</td>
    </tr>
    <tr>
      <td>연관 <sub>Association</sub></td>
      <td>Class 간의 관계</td>
    </tr>
  </table>
  <h3 class="title mb-0">객체 지향 Programming과 용어</h3>
  <table>
    <tr>
      <th>Kotlin에서 사용하는 용어</th>
      <th>다른 언어에서 사용하는 용어</th>
    </tr>
    <tr>
      <td>Class</td>
      <td>분류, 범주</td>
    </tr>
    <tr>
      <td>Property</td>
      <td>속성 <sub>Attribute</sub>, 변수 <sub>Variable</sub>, Field, Data</td>
    </tr>
    <tr>
      <td>Method</td>
      <td>함수 <sub>Function</sub>, 동작 <sub>Operation</sub>, 행동 <sub>Behavior</sub></td>
    </tr>
    <tr>
      <td>객체 <sub>Object</sub></td>
      <td>Instance</td>
    </tr>
  </table><br>
  <table>
    <caption>Class의 member가 될 수 있는 것</caption>
    <tr>
      <th scope="row">생성자와 초기화 block</th>
      <td>객체가 생성될 때 자동 실행되는 method 또는 code block</td>
    </tr>
    <tr>
      <th scope="row">Property</th>
      <td>변수의 이름과 변수의 접근 함수가 포함된 형태</td>
    </tr>
    <tr>
      <th scope="row">Method</th>
      <td>일반적은 함수의 형태</td>
    </tr>
    <tr>
      <th scope="row">중첩 <sub>Nested</sub> class와<br>Inner class</th>
      <td>Class 내부에 구성되는 class</td>
    </tr>
    <tr>
      <th scope="row">객체 선언</th>
      <td>Class 없이 접근할 수 있는 객체</td>
    </tr>
  </table>
  <h4 class="mb-0">Class Diagram</h4>
  UML <sub>Unified Modeling Language</sub>은 객체 지향 program 설계를 위한 diagram 표기법이다.
  <table style="text-align: left;">
    <tr>
      <th scope="row">Class Diagram</th>
      <td>Class의 정의와 관계를 나타낸다.</td>
    </tr>
    <tr>
      <th scope="row">Sequence Diagram</th>
      <td>시간의 개념을 통해 class에서 생성된 객체의 실행 흐름을 나타낸다.</td>
    </tr>
    <tr>
      <th scope="row">Use Case Diagram</th>
      <td>사용자 관점에서 사용 방법에 대해 설명한다.</td>
    </tr>
    <tr>
      <th scope="row">State-Machine Diagram</th>
      <td>System 관점에서 상태가 어떻게 변화하는지 나타낸다.</td>
    </tr>
  </table>
  <h3 class="title mb-0">Class와 추상화</h3>
  <table class="no-border">
    <tr>
      <td style="text-align: center;">새의 추상화</td>
      <td></td>
    </tr>
    <tr>
      <th class="border">Bird</th>
      <td><span class="material-icons">arrow_back</span> Class 이름</td>
    </tr>
    <tr>
      <td class="bg-lg border">+ name: String<br>+ wing: Int = 2<br>+ beak: String<br>+ color: String</td>
      <td><span class="material-icons">arrow_back</span> Property</td>
    </tr>
    <tr>
      <td class="bg-lg border">+ fly(): Unit<br>+ sing(vol: Int): Unit</td>
      <td><span class="material-icons">arrow_back</span> Method</td>
    </tr>
  </table>
  <span class="material-icons red">info</span> 가시성 <sub>Visibility</sub> + : public, - : private
  <h3 class="title mb-0">Class 선언하기</h3>
  <pre>
class Bird {} // 빈 class 선언

class Bird // {} 생략 가능</pre>
  <pre>
<strong>class Bird</strong> {
  // property (속성)
  var name: String = "mybird"
  var wing: Int = 2
  var beak: String = "short"
  var color: String = "blue"

  // method (함수)
  fun fly() = println("Fly wing: $wing")
  fun sing(vol: Int) = println("Sing vol: $vol")
}

fun main() {
  val coco = <strong>Bird()</strong> // 생성자를 통한 객체의 생성
  coco.color = "blue" // 객체의 propery에 값 할당

  println("coco.color: ${coco.color}") // 객체의 member propery 읽기

  coco.fly() // 객체의 member method 사용
  coco.sing(3)
}<hr>>>
coco.color: blue
Fly wing: 2
Sing vol: 3</pre>
  <h4 class="mb-0">객체와 Instance 정리하기</h4>
  인스턴스화 <sub>Instantiate</sub> : Class로부터 객체 <sub>Object</sub>를 생성하는 것.
  <hr>
  <h2 class="title"><span class="titleNumber">05-2</span>생성자 <sub>Constructor</sub></h2>
  Class를 통해 객체가 만들어질 때 기본적으로 호출되는 함수.
  <pre>
class Class이름 <strong>constructor</strong>(필요한 매개변수..) { // 주<sub>Primary</sub> 생성자의 위치
  ...
  constructor(필요한 매개변수..) { // 부<sub>Secondary</sub> 생성자의 위치
    // property 초기화
  }

  [constructor(필요한 매개변수..) { ... }] // 추가 부 생성자
  ...
}
</pre>
  <h3 class="title mb-0">부 생성자 <sub>Secondary Constructor</sub></h3>
  Class의 본문에 함수처럼 선언한다.
  <pre>
class Bird {
  // property 선언만 한다.
  var name: String
  var wing: Int
  var beak: String
  var color: String

  // 부 생성자 : 매개변수를 통해 초기화할 property에 지정
  <strong>constructor</strong>(name: String, wing: Int, beak: String, color: String) {
    // 매개변수와 property 이름을 다르게 하면 <strong>this.</strong>를 사용할 필요가 없다.
    <strong style="line-height: 1rem;">this.</strong>name = name 
    this.wing = wing
    this.beak = beak
    this.color = color
  }

  // method
  fun fly() = println("Fly wing: $wing")
  fun sing(vol: Int) = println("Sing vol: $vol")
}

fun main() {
  // 생성자의 인자로 객체 생성과 동시에 초기화
  val coco = <strong>Bird("mybird", 2, "short", "blue")</strong>
  coco.color = "yellow"

  println("coco.color: ${coco.color}")

  coco.fly()
  coco.sing(3)
}</pre>
  <h4 class="mb-0">부 생성자를 여러 개 포함한 class 사용하기</h4>
  Kotlin에서는 class에 부 생성자를 하나 이상 포함할 수 있다. 이때는 매개변수를 다르게 정의해야 한다.
  <pre>
class Class이름 {
  constructor(매개변수[, 매개변수...]) { // code }
  constructor(매개변수[, 매개변수...]) { // code }
}</pre>
  <pre>
class Bird {
  var name: String
  var wing: Int
  var beak: String
  var color: String

  <strong>constructor</strong>(_name: String, _wing: Int, _beak: String, _color: String) {
    name = _name 
    wing = _wing
    beak = _beak
    color = _color
  }

  <strong>constructor</strong>(_name: String, _beak: String) {
    name = _name 
    wing = 2
    beak = _beak
    color = "grey"
  }

  ...
}

val bird1 = Bird("myBird", 2, "short", "blue")
val bird2 = Bird("myBird", "long")</pre>
  <h3 class="title mb-0">주 생성자 <sub>Primary Constructor</sub></h3>
  Class 이름과 함께 생성자 정의를 이용할 수 있는 기법이다. 주 생성자는 class 이름과 block 시작 부분 사이에 선언한다.
  <pre>
class Bird <strong>constructor</strong>(_name: String, _wing: Int, _beak: String, _color: String) {
  var name: String = _name
  var wing: Int = _wing
  var beak: String = _beak
  var color: String = _color
  ...
}

// constructor을 <strong>생략</strong>할 수 있다.
// 하지만 가시성 지시자나 annotation 표기가 class 선언에 있다면 생략할 수 없다.
class Bird(_name: String, _wing: Int, _beak: String, _color: String) { ... }</pre>
  <h4 class="mb-0">Property를 포함한 주 생성자</h4>
  <pre>
// constructor 생략
class Bird(<strong>var name: String, var wing: Int, var beak: String, var color: String</strong>) {
  // Property를 주 생성자의 매개변수에 선언했으므로 본문에선 생략.
  ...
}</pre>
  <h4>초기화 block을 가진 주 생성자 : <strong>init{}</strong></h4>
  <pre>
class Bird(<strong>var name: String, var wing: Int, var beak: String, var color: String</strong>) {
  // 초기화 block
  <strong>init {</strong>
    println("--- Start init block ---")
    println("name is $name, beak is $beak")
    this.sing(3)
    println("--- End init block ---")
  <strong>}</strong>
  ...
}

fun main() {
  val coco = Bird("mybird", 2, "short", "blue") // 객체 생성과 함께 초기화 block를 수행한다.
  coco.color = "yellow"
  println("coco.color is ${coco.color}")
  coco.fly()
}<hr>>>
--- Start init block ---
name is mybird, beak is short
Sing vol: 3
--- End init block ---
coco.color is yellow
Fly wing: 2</pre>
  <h4 class="mb-0">호출 순서</h4>
  <ul class="mt-0">
    <li>주 생성자 <span class="material-icons">arrow_forward</span> init {}</li>
    <li>init{} <span class="material-icons">arrow_forward</span> 부 생성자</li>
  </ul>
  <span class="material-icons red">info</span> init{}과 부 생성자에는 getter/setter가 사용된다.
  <h4>Property의 기본값 지정</h4>
  <pre>
class Bird(<strong>var name: String = "NONAME", var wing: Int = 2, var beak: String, var color: String</strong>) {
  ...
}

fun main() {
  // 기본값이 없는 것만 전달 가능.
  val coco = Bird(beak = "long", color = "red")

  println("coco.name is ${coco.name}, coco.wing is ${coco.wing}")
  println("coco.color is ${coco.color}, coco.beak is ${coco.beak}")
}<hr>>>
coco.name is NONAME, coco.wing is 2
coco.color is red, coco.beak is long</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">05-3</span>상속 <sub>Inheritance</sub>과 다형성 <sub>Polymorphism</sub></h2>
  <ul>
    <li><b>상속</b> : 자식 class는 부모 class의 속성과 기능을 물려 받는다.</li>
    <li><b>다형성</b> : Method가 같은 이름을 사용하지만 구현 내용이 다르거나<sub>Overriding</sub> 매개변수가 달라서 하나의 이름 <sub>Overloading</sub>으로 다양한 기능을 수행할 수 있다.</li>
  </ul>
  <h3 class="title">상속과 Class의 계층</h3>
  <table class="no-border">
    <caption style="caption-side: bottom;">&lt;기본 class와 파생된 하위 class></caption>
    <tr>
      <td></td>
      <td class="bg-lg border" style="text-align: center;">Any</td>
      <td>최상위 class <sub>Super Class</sub></td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: center;"><span class="material-icons" style="line-height: .9rem;">change_history<br>|<br> <br></span></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td class="bg-lg border" style="text-align: center;">Bird</td>
      <td>기반 Class <sub>Base Class</sub></td>
    </tr>
    <tr>
      <td></td>
      <td class="bg-lg border">name: String<br>wing: Int = 2<br>beak: String<br>color: String</td>
      <td rowspan="2"></td>
    </tr>
    <tr>
      <td></td>
      <td class="bg-lg border">fly(): Unit<br>sing(vol: Int): Unit</td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: center;"><span class="material-icons" style="line-height: .9rem;">change_history<br>|<br> <br></span></td>
      <td>상속</td>
    </tr>
    <tr>
      <td class="bg-lg border" style="text-align: center;">Lark</td>
      <td></td>
      <td class="bg-lg border" style="text-align: center;">Parrot</td>
    </tr>
    <tr>
      <td class="bg-lg border"><br><br></td>
      <td></td>
      <td class="bg-lg border">language: String</td>
    </tr>
    <tr>
      <td class="bg-lg border">singHitone()</td>
      <td></td>
      <td class="bg-lg border">speak()</td>
    </tr>
  </table>
  <h4>하위 Class 선언하기</h4>
  Kotlin은 <strong style="font-size: 1rem;">open</strong> 없이 기본으로 class를 선언하면 상속할 수 없는 기본 class가 된다.
  <pre>
<strong>open class</strong> 기반_Class_이름 { // 묵시적으로 <strong>Any</strong>로 부터 상속됨.
  ...
}

<strong>class</strong> 파생_Class_이름 : 기반_Class_이름 {
  ...
}</pre><br>
  Sample.kt
  <pre>
// 상속 가능한 class를 만들기 위해 open 사용
<strong>open</strong> class <span class="custom">Bird</span>(var name: String, var wing: Int, var beak: String, var color: String) {
  fun fly() = println("Fly wing: $wing")
  fun sing(vol: Int) = println("Sing vol: $vol")
}

// 주 생성자를 사용한 상속
class <span class="custom">Lark</span>(name: String, wing: Int, beak: String, color: String)<strong> : Bird</strong>(name, wing, beak, color) {
  fun <strong>singHitone</strong>() = println("Happy Song!") // 새로 추가한 method
}

// 부 생성자를 사용한 상속
class <span class="custom">Parrot</span> : Bird {
  val language: String

  <strong>constructor</strong>(name: String, wing: Int, beak: String, color: String, <strong>language: String</strong>) : <strong>super</strong>(name, wing, beak, color) {
      <strong class="lh-1">this.language = language</strong> // 새로 추가한 property
  }

  fun <strong>speak()</strong> = println("Speak! $language")
}

fun main() {
  val coco = Bird("mybird", 2, "short", "blue")
  val lark = Lark("mylark", 2, "long", "brown")
  val parrot = Parrot("myparrot", 2, "short", "multiple", <strong>korean"</strong>)

  println("Coco: ${coco.name}, ${coco.wing}, ${coco.beak}, ${coco.color}")
  println("Lark: ${lark.name}, ${lark.wing}, ${lark.beak}, ${lark.color}")

  with(parrot) { println("Parrot: ${name}, ${wing}, ${beak}, ${color}, ${language}") }

  <strong>lark.singHitone()</strong>
  <strong class="lh-1">parrot.speak()</strong>
  lark.fly()
}<hr>>>
Coco: mybird, 2, short, blue
Lark: mylark, 2, long, brown
Parrot: myparrot, 2, short, multiple, korean
Happy Song!
Speak! korean
Fly wing: 2</pre>
  <pre>
// 주 생성자를 사용한 상속
// 마지막 인자만 var로 선언되어 property가 추가되었음을 알 수 있다.
class <span class="custom">Parrot</span>(name: String, wing: Int, beak: String, color: String, <strong>var</strong> language: String) : Bird(name, wing, beak, color) {
  fun speak() = println("Speak! $language")
}</pre>
  <h3 class="title mb-0">다형성</h3>
  <h4 class="mt-0 mb-0">Overloading</h4>
  같은 이름의 method를 매개변수만 다르게 해서 여러 번 정의할 수 있다.<br>
  반환값만 다르고 매개변수는 같은 경우에는 해당되지 않는다.
  <pre>
fun add(x: Int, y: Int): Int { return x + y }
fun add(x: Double, y: Double): Double { return x + y }
fun add(x: Int, y: Int, z: Int): Int { return x + y + z }

// return type 만으로 overloading 안된다.
fun add(x: Int, y: Int)<strong>: Long</strong> { return (x + y).toLong() } // <span class="red">Error! Conflicting overloadings.</span>
</pre>
  <h4 class="mb-0">Overriding</h4>
  <ul class="mt-0">
    <li>상위 Class의 method를 재정의한다.</li>
    <li>상위 Class는 <strong>open</strong>을 하위 Class에서는 <strong>override</strong> keyword를 사용해야 한다.</li>
    <li>Kotlin에서는 property도 overriding 할 수 있다.</li>
  </ul>
  <pre>
<strong>open</strong> class Bird {
  fun fly() { ... } // override 불가!

  <strong>open</strong> fun sing() { ... } // override 가능.
}

class Lark() : Bird() {
  fun fly() { ... } // <span class="red">Error!</span>

  <strong>override</strong> fun sing() { ... } // 재정의.
}</pre><br>
  만약, Lark을 상속한 class에서 sing()의 overriding 막고 싶다면 <strong>final</strong>를 앞에 붙인다.
  <pre>
<strong>open</strong> class Lark() : Bird() {
  <strong class="lh-1">final</strong> override fun sing() { ... } // 재정의. 하위 class에서 재정의 불가.
}

class Skylark() : Lark() {
  override fun sing() { ... } // <span class="red">Error!</span> 재정의할 수 없다.
}</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">05-4</span><code class="no-bgc" style="font-size: 1em;">super</code>와 <code class="no-bgc" style="font-size: 1em;">this</code>의 참조</h2>
  <h3 class="title mb-0"><code class="no-bgc" style="font-size: 1.2rem">super</code>로 상위 객체 참조하기</h3>
  <pre>
open class Bird {
  open fun sing() {
    println("Bird sing.")
  }
} 

class Parrot() : Bird() {
  override fun sing() {
    <strong>super.sing()</strong>

    println("Parrot sing")
  }
}</pre>
  <h3 class="title mb-0"><code class="no-bgc" style="font-size: 1.2rem">this</code>로 현재 객체 참조하기</h3>
  <h4 class="mb-0">여러 개의 부 생성자에서 참조하기</h4>
  <pre>
<span class="keyword">open class</span> <span class="custom">Person</span> {
  <span class="keyword">constructor</span>(firstName: String) {
      println("[Person] $firstName")
  }

  // ①
  <span class="keyword">constructor</span>(firstName: String, age: Int) {
      println("[Person] $firstName, $age")
  }
}

<span class="keyword">class</span> <span class="custom">Developer</span> : <span class="custom">Person</span> {
  <span class="keyword">constructor</span>(firstName: String) : <strong>this</strong>(firstName, 18) { // call ②
      println("[Developer] $firstName")
  }

  // ②
  <span class="keyword">constructor</span>(firstName: String, age: Int) : <strong>super</strong>(firstName, age) { // call ①
      println("[Developer] $firstName, $age")
  }
}

fun main() {
  val peter = Developer("Peter")
}<hr>>>
[Person] Peter, 10
[Developer] Peter, 10
[Developer] Peter</pre>
  <h4 class="mb-0">주 생성자와 부 생성자 함께 사용하기</h4>
  <pre>
class Person(firstName: String, out: Unit = println("[Primary Constructor] Parameter")) { // ② 주 생성자
  val name = println("[Property] Person name: $firstName") // ③ property 할당

  // ④ 초기화 block
  init {
      println("[init] Person init block")
  }

  // ① 부 생성자
  constructor(
    firstName: String, 
    age: Int, 
    out: Unit = println("[Secondary Constructor] Parameter")) : <strong>this</strong>(firstName) {
      println("[Secondary Constructor] Body: $firstName, $age") // ⑤ 부 생성자 본문
  }
}

fun main() {
  val p1 = Person("Peter", 18) // ①②③④⑤
  println("-----------------------")
  val p2 = Person("Tony") // ②③④
}<hr>>>
[Secondary Constructor] Parameter
[Primary Constructor] Parameter
[Property] Person name: Peter
[init] Person init block
[Secondary Constructor] Body: Peter, 18
-----------------------
[Primary Constructor] Parameter
[Property] Person name: Tony
[init] Person init block</pre>
  <h3 class="title mb-0">바깥 Class 호출하기</h3>
  <pre>
open class Base {
  open val x: Int = 1 // ④
  open fun f() = println("Base Class f()") // ①
}

class Child : Base() {
  override val x: Int = super.x + 1
  override fun f() = println("Child Class f()") // ②

  <strong>inner</strong> class Inside {
      fun f() = println("Inside Class f()") // ③

      fun test() {
          f() // ③
          <strong>Child().f()</strong> // ②
          <strong class="lh-1">super@Child.f()</strong> // ①
          println("[Inside] super@Child.x: ${<strong>super@Child.x</strong>}")
      }
  }
}

fun main() {
  <strong>Child().Inside().test()</strong>
}<hr>>>
Inside Class f()
Child Class f()
Base Class f()
[Inside] super@Child.x: 1</pre>
  <h3 class="title mb-0">Interface에서 참조하기</h3>
  <ul class="mt-0">
    <li>Interface는 구현약속이다.</li>
    <li>Interface 자체로는 객체를 만들 수 없고 항상 Interface를 구현하는 Class에서 생성해야 한다.</li>
    <li>Kotlin은 Class를 하나만 상속 받을 수 있다.</li>
    <li>Interface는 여러 개를 구현할 수 있다.</li>
  </ul>
  <pre>
// 이름 중복해결하기

open class A {
  open fun <strong>f()</strong> = println("class A f()")
  fun a() = println("class A a()")
}

// Interface는 기본으로 open 이다.
interface B {
  fun <strong>f()</strong> = println("interface B f()")
  fun b() = println("interface B b()")
}

// ','로 구분해서 상속할 class와 interface를 여러 개 지정할 수 있다.
class C : <strong>A(), B</strong> {
  // class A와 interface B에 f()가 중복되므로 반드시 f()는 override해야 한다.
  <strong>override fun f()</strong> = println("class C f()")

  fun test() {
      f()
      b()

      // super&lt;부모_Type>을 사용해서 누구의 f()를 사용할지 선택한다.
      <strong>super&lt;A>.f()</strong> // class A의 f()
      <strong class="lh-1">super&lt;B>.f()</strong> // interface B의 f()
  }
}

fun main() {
  C().test()
}<hr>>>
class C f()
interface B b()
class A f()
interface B f()</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">05-5</span>정보 은닉 캡슐화 <sub>Encapsulation</sub></h2>
  <h3 class="title mb-0">가시성 지시자 <sub>Visibility Modifier</sub></h3>
  가시성 : 각 class나 method, property의 접근 범위.
  <table class="th-ta-r">
    <tr>
      <th><code>private</code></th>
      <td>private class는 같은 file 안에서만 생성할 수 있다.<br>class안의 private property는 class 안에서만 접근할 수 있다.</td>
    </tr>
    <tr>
      <th><code>protected</code></th>
      <td>자신과 자식 class에서만 접근할 수 있다.<br>최상위 요소에는 지정할 수 없다.<br><code>class</code>나 <code>interface</code> 안의 memeber에만 지정할 수 있다.</td>
    </tr>
    <tr>
      <th><code>internal</code></th>
      <td>같은 module <sub>build 된 하나의 묶음</sub> 안에서만 접근할 수 있다.<br>Project에 한 개의 module만 있다면 internal의 접근 범위는 Project 전체가 된다.</td>
    </tr>
    <tr>
      <th><code>public</code></th>
      <td><strong>기본값</strong> 어디에서든 접근할 수 있다.</td>
    </tr>
  </table>
  <h4><code class="no-bgc">private</code></h4>
  <pre>
<strong>private</strong> class PrivateClass {
  <strong class="lh-1">private</strong> var i = 1

  <strong>private</strong> fun privateFunc() { i += 1 }

  fun access() { privateFunc() }
}

class OtherClass {
  val pc = PrivateClass() // <span class="red">!Error</span>

  // private class를 지정하려면 똑같이 private으로 선언해야 한다.
  <strong>private</strong> val pc2 = PrivateClass()

  fun test() {
      val pc = PrivateClass()
  }
}

fun main() {
  val pc = PrivateClass() // 가능

  pc.i  // <span class="red">!Error</span>
  pc.privateFunc()  // <span class="red">!Error</span>
}

fun topFunc() {
  val pc = PrivateClass() // 가능.
}</pre>
  <h4><code class="no-bgc mb-0">protected</code></h4>
  <pre>
// 최상위 class에는 protected를 사용할 수 없다.
open class Base {
    <strong>protected</strong> var i = 1

    <strong>protected</strong> fun protectedFunc() { i += 1}
    fun access() { protectedFunc() }

    // 내부 class에는 protected를 사용할 수 있다.
    <strong>protected</strong> class Nested
}

// 부모 class인 Base의 protected 요소에 접근할 수 있다.
class Derived : Base() {
    fun test(base: Base): Int {
        protectedFunc()
        return i
    }
}

fun main() {
    val base = Base()

    base.i // <span class="error">!Error</span>
    base.protectedFunc() // <span class="error">!Error</span>

    base.access()
}</pre>
  <h4><code class="no-bgc">internal</code></h4>
  <table class="no-border">
    <tr>
      <td><span class="material-icons info" style="float:left">info</span></td>
      <td>Java의 가시성 지시자 기본값인 <strong><code>package</code></strong> 지시자는 Kotlin에서는 사용하지 않는다.<br>
        Java에서 <code class="no-bgc">package</code>로 지정된 경우 같은 package라면 project 단위 묶음인 .jar 파일이 달라도 모두 접근 할 수 있다.
        이는 보안 문제가 발생할 수 있다.<br>그래서 Kotlin에서는 package를 버리고 같은 module 안에서만 접근할 수 있는 <code>internal</code>을 사용한다.<br>
        Module이 다른 .jar 파일에서는 internal로 선언된 요소에 접근할 수 없다는 뜻이다.</td>
    </tr>
  </table>
  Sample.kt
  <pre>
<strong>internal</strong> class InternalClass {
  <strong class="lh-1">internal</strong> var i = 1

  <strong>internal</strong> fun internalFunc() { i += 1 }

  fun access() { internalFunc() }
}

class OtherClass {
  // 같은 internal로 선언해야 한다.
  <strong>internal</strong> var ic = InternalClass()

  fun test() {
      ic.i
      ic.internalFunc()
  }
}

fun main() {
  val ic = InternalClass()
  ic.i
  ic.internalFunc()
}</pre><br>
  OtherFile.kt
  <pre>
fun main() {
  val ic = InternalClass()
  ic.i
  ic.internalFunc()
}</pre>
  <h3 class="title mb-0">가시성 지시자와 Class의 관계</h3>
  <pre>
open class Base {
  // 접근 가능 : a, b, c, d, e
  
  private         val a = 1
  protected open  val b = 2
  internal        val c = 3
                  val d = 4 // 기본값은 public

  protected class Nested {
      // 접근 가능 : a, b, c, d, e, f 
      
              val e = 5
      private val f = 6
  }
}

class Derived : Base() {
  // 접근 불가 : a, f
  // 접근 가능 : b, c, d, e
  
  // <strong>Overriding된 member는 상위 class와 동일한 가시성을 가진다.</strong>
  override val b = 5 // protected
}

class Other(base: Base) {
  // 같은 module이므로 접근 가능 : Base.c, Base.d
}</pre>
  <h4 class="mb-0">자동차와 도둑의 예제</h4>
  <pre>
// 주 생성자가 protected이므로 자식 class에서만 Car 객체를 만들 수 있다.
// 이때는 constructor keyword를 생략할 수 없다.
open class Car <strong>protected</strong> constructor(
  <strong>private</strong> val year: Int,  
  var model: String,
  <strong>protected</strong> open var power: String,
  <strong class="lh-1">internal</strong> var wheel: String,
) {
    protected fun start(key: Boolean) {
      if (key) println("Start the Engine!")
    }

    class Driver(<strong>private</strong> var name: String, var license: String) {
      <strong>internal</strong> fun driving() = println("[Driver] Driving() - $name")
    }
}

class Tico(
    year: Int,
    model: String,
    override var power: String = "50hp",
    wheel: String,
    var name: String,
    private var key: Boolean,
) : Car(year, model, power, wheel) {
    val driver = Driver(name, "first class")

    constructor(name: String, key: Boolean)
            : this(2014, "basic", "100hp", "normal", name, key) {
    }

    fun access(password: String) {
        when (password) {
            "gotico" -> {
                println("----- [Tico] access() -----")
                super.year // <span class="error">Error!</span> private 접근 불가
                println("model = $model")
                println("power = $power")
                println("wheel = $wheel")
                start(true)

                driver.name // <span class="error">Error!</span> private 접근 불가
                println("dirver.license = ${driver.license}")
                driver.driving()
            }
            else -> println("Your are a burglar!")
        }
    }
}

class Burglar {
    fun steal(any: Any) {
        when (any) {
            <strong>is</strong> Tico -> {
                println("----- [Burglar] steal() -----")
                println(any.year) // <span class="error">Error!</span> private 접근 불가
                println(any.power) // <span class="error">Error!</span> protected 접근 불가

                println(any.name)
                println(any.wheel)
                println(any.model)

                println(any.driver.license)
                any.driver.driving()
                any.start() // <span class="error">Error!</span> protected 접근 불가
                any.access("dontknow")
            }
            else -> println("Nothing to steal.")
        }
    }
}

fun main() {
    val car = Car() // <span class="error">Error!</span> protected 직접 생성 불가

    val tico = Tico("peter", true)
    tico.access("gotico")

    val burglar = Burglar()
    burglar.steal(tico)
}<hr>>>
----- [Tico] access() -----
model = basic
power = 100hp
wheel = normal
Start the Engine!
dirver.license = first class
[Driver] Driving() - peter
----- [Burglar] steal() -----
peter
normal
basic
first class
[Driver] Driving() - peter
Your are a burglar!</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">05-6</span>Class와 Class의 관계</h2>
  <h3 class="title">Class 혹은 객체 간의 관계</h3>
  <h4>Class 간의 관계를 판별하는 방법</h4>
  <ul class="mt-0">
    <li>두 class가 서로 참조하는가?</li>
    <li>두 class가 생명주기에 영향을 주는가?</li>
  </ul>
  <table class="center no-border">
    <tr>
      <td class="border">Class 서로 참조 유지 여부 ?</td>
      <td><span class="material-icons">horizontal_rule</span>N<span class="material-icons">arrow_forward</span></td>
      <td class="bg-lg border">의존 <sub>Dependency</sub></td>
    </tr>
    <tr>
      <td><span class="material-icons">arrow_downward</span>Y</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="bg-lg border">연관 <sub>Association</sub></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><span class="material-icons">arrow_downward</span>&nbsp;&nbsp;</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="border">Class 각자의 생명주기 유지 ?</td>
      <td><span class="material-icons">horizontal_rule</span>N<span class="material-icons">arrow_forward</span></td>
      <td class="bg-lg border">구성 <sub>Composition</sub></td>
    </tr>
    <tr>
      <td><span class="material-icons">arrow_downward</span>Y</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td class="bg-lg border">집합 <sub>Aggregation</sub></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <h4>연관 관계 <sub>Association</sub></h4>
  <ul class="mt-0">
    <li>2개의 서로 분리된 class가 연결을 가지는 것이다.</li>
    <li>단방향, 양방향으로 연결될 수 있다.</li>
    <li>핵심은 두 요소가 서로 독립적인 생명주기를 가진다는 것이다.</li>
  </ul>
  <pre>
class Doctor(val name: String) {
  fun patientList(patient: Patient) {
      println("Doctor: $name - Patient: ${patient.name}")
  }
}

class Patient(val name: String) {
  fun doctorList(doctor: Doctor) {
      println("Patient: $name - Doctor: ${doctor.name}")
  }
}

fun main() {
  val doctor = Doctor("Strange")
  val patient = Patient("Peter")

  doctor.patientList(patient)
  patient.doctorList(doctor)
}<hr>>>
Doctor: Strange - Patient: Peter
Patient: Peter - Doctor: Strange</pre>
  <h4 class="mb-0">의존 관계 <sub>Dependency</sub></h4>
  <pre>
class Patient(val name: String, val id: Int) {}

// Doctor class는 Patient class에 의존하고 있다.
class Doctor(val name: String, <strong>val patient: Patient</strong>) {
  private val customerId = patient.id

  fun patientList() {
      println("Doctor = $name, Patient = ${patient.name}")
      println("Patient Id = $customerId")
  }
}

fun main() {
  val patient = Patient("Peter", 1234)
  val doctor = Doctor("Strange", patient)
  doctor.patientList()
}<hr>>>
Doctor = Strange, Patient = Peter
Patient Id = 1234</pre>
  <h4 class="mb-0">집합 관계 <sub>Aggregation</sub> <strong>has a</strong></h4>
  연관관계와 거의 동일하지만 특정 객체를 소유한다는 개념이 추가되었다.
  <pre>
// 연못에 있는 오리들을 저장할 list 매개변수 (집합)
class Pond(<strong>val members: MutableList&lt;Duck></strong>) {
  constructor() : this(<strong class="lh-1">mutableListOf&lt;Duck>()</strong>)
}

class Duck(val name: String)

fun main() {
  // 두 객체는 서로 생명주기에 영향을 주지 않는다.
  val pond = Pond()
  val duck1 = Duck("donald")
  val duck2 = Duck("daisy")

  // 연못에 오리를 추가.(오리의 집합)
  pond.members.add(duck1)
  pond.members.add(duck2)

  // 연못에 있는 오리들
  for (duck in pond.members) {
      println(duck.name)
  }
}<hr>>>
donald
daisy</pre>
  <h4>구성 관계 <sub>Composition</sub> <strong>own a</strong></h4>
  <ul class="mt-0">
    <li>집합 관계와 거의 동일하지만 특정 class가 어느 한 class의 부분이 되는 것이다.</li>
    <li>구성품으로 지정된 class는 생명주기가 소유자 class에 의존한다.</li>
    <li>소유자 class가 삭제되면 구성된 class도 삭제된다.</li>
  </ul>
  <pre>
class Car {
  // Engine class는 Car class의 생명주기에 의존적이다.
  // Car 객체가 사라지면 Engine 객체도 사라진다.
  private val engine = <strong>Engine()</strong>

  fun startEngine() = engine.start()
  fun stopEngine() = engine.stop()
}

class Engine {
  fun start() = println("Start engine")
  fun stop() = println("Stop engine")
}

fun main() {
  val car = Car()
  car.startEngine()
  car.stopEngine()
}<hr>>>
Start engine
Stop engine</pre>
  <h3 class="title mb-0">객체 간의 Message 전달하기</h3>
  시간의 흐름에 따라 일어나는 경우가 대부분기 때문에 UML의 Sequence Diagram으로 표현한다.
  <hr>
  <h1><span class="titleNumber">06</span>Property와 초기화</h1>
  Kotlin에서 class의 property는 <strong>변수</strong>와 <strong>접근 method</strong>가 포함된 개념이다.<br>
  접근 method는 <code>getter</code>, <code>setter</code>라고 부르고 자동으로 만들어 진다.<br>
  Property는 반드시 초기화되어야 한다.
  <h2 class="title mb-0"><span class="titleNumber">06-1</span>Property의 접근</h2>
  Class 내에 선언한 변수를 property라고 부른다.
  <h3 class="title mb-0">Kotlin에서 getter와 setter가 작동하는 방식</h3>
  내부적으로 getter, setter를 자동으로 만들어 준다.
  <pre>class User(val id: Int, var name: String, var age: Int)</pre>
  val은 불변값이므로 getter만, var는 getter/setter를 만들어 준다.
  <code class="no-bgc">
  <table>
    <tr>
      <th>Kotlin</th>
      <th>Java</th>
    </tr>
    <tr>
      <td>user.name</td>
      <td>user.getName()</td>
    </tr>
    <tr>
      <td>user.age = 18</td>
      <td>user.setAge(18)</td>
    </tr>
  </table></code>
  <h3 class="title mb-0">기본 getter와 setter 직접 지정하기</h3>
  <table>
    <caption>구조</caption>
    <tr>
      <td>
        <pre class="no-bgc">
<span class="keyword-on-light">var</span> Property_이름[: Property_자료형][= Property_초기화]
  [<strong>get</strong>() { getter_본문 }]
  [<strong class="lh-1">set</strong>(value) { setter_본문 }]</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre class="no-bgc">
<span class="keyword-on-light">val</span> Property_이름[: Property_자료형][= Property_초기화]
  [<strong>get</strong>() { getter_본문 }]</pre>
      </td>
    </tr>
  </table><br>
  <table>
    <caption>getter, setter에 사용되는 특수 변수</caption>
    <tr>
      <th scope="row"><code>value</code></th>
      <td>setter의 매개변수.</td>
    </tr>
    <tr>
      <th scope="row"><code>field</code></th>
      <td>보조 <sub>Backing</sub> Field.<br>Property를 참조하는 변수.</td>
    </tr>
  </table>
  <pre>
class User(_id: Int, _name: String, _age: Int) {
  val id: Int = _id
      get() = field

  var name: String = _name
      get() = field
      set(value) {
          field = value
      }


  var age: Int = _age
      get() = field
      set(value) {
          field = value
      }
}</pre>
  <h3 class="title mb-0">Custom getter와 setter의 사용</h3>
  사용자가 직접 getter/setter를 정의하면서 새로운 내용을 작성하는 것.
  <pre>
class User(_id: Int, _name: String, _age: Int) {
  val id: Int = _id

  var <strong>name</strong>: String = _name
      <strong class="lh-1">set</strong>(<span class="keyword">value</span>) {
        <span class="keyword">field</span> = value<span class="custom">.uppercase()</span> // 대문자로 저장한다.
      }

  var age: Int = _age
}

fun main() {
  val user = User(1962, "peter", 18)
  println(user.name)

  <strong>user.name = "parker"</strong>
  println(user.name)
}<hr>>>
peter
PARKER</pre><br>
  보안으로 외부에서 name에 접근하지 못하게 하려면 가시성 지시자를 사용하면 된다.<br>
  아래와 같이 setter를 <code>private</code>으로 지정하면 외부에서 name에 값을 할당할 수 없다.
  <pre>
var name: String = _name // public
  // getter의 가시성은 property의 가시성과 <strong>같아야</strong> 한다.
  <span class="error">private</span> get() = field // <span class="error">Error!</span>

  <strong>private</strong> set(<span class="keyword">value</span>) {
    <span class="keyword">field</span> = value<span class="custom">.uppercase()</span>
}</pre>
  <h4 class="mb-0">보조 property의 사용</h4>
  보조 field를 사용하지 않는 경우에는 임시로 사용할 property를 선언해 놓고 getter/setter에서 사용할 수 있다.
  <h4 class="mb-0">Property의 overriding</h4>
  Property는 기본적으로 overriding 할 수 없다.<br>
  Overriding을 하려면 <strong>open</strong> keyword와 함께 property를 선언해야 한다.
  <pre>
open class First {
  <strong>open</strong> val x: Int = 0
      get() {
          println("First x")
          return field
      }

  val y: Int = 0
}

class Second : First() {
  <strong>override</strong> val x: Int = 0
      get() {
          println("Second x")
          return field + 3
      }

  <span class="error">// 'y' in 'First' is final and cannot be overridden</span>
  override val y: Int = 0 <span class="error">// Error!</span>
}

fun main() {
  val second = Second()
  println(second.x)
  println(second.y)
}<hr>>>
Second x
3
0</pre>
  <span class="material-icons red" style="float:left;">info</span> Overriding 때 상위 class에 property를 <code>val</code>로 정의한 경우에는 하위 class에서 <code>var</code>로 변경할 수 있다.<br>
  반대로 <code>var</code>를 <code>val</code>로 변경할 수는 없다.<br>
  <hr>
  <h2 class="title"><span class="titleNumber">06-2</span>지연 초기화와 위임</h2>
  Property를 선언하면 기본적으로 모두 초기화해야 한다. 하지만 객체의 정보가 나중에 나타나는 경우 객체 생성과 동시에 초기화하기 힘든 경우가 있다. 이럴 때 지연 초기화를 사용한다.
  <h3 class="title">lateinit을 사용한 지연 초기화</h3>
  <h4>Property 지연 초기화하기</h4>
  <ul><b>Property를 초기화하는 방법</b>
    <li>주 생성자에서 초기화</li>
    <li>init {} 초기화</li>
    <li>부 생성자 초기화</li>
    <li>매개변수의 기본값 초기화</li>
  </ul>
  <ul><b><code>lateinit</code>의 제한</b>
    <li><code>var</code>로 선언된 property만 가능하다.</li>
    <li>property에 대한 getter/setter를 사용할 수 없다.</li>
  </ul>
  <pre>
class Person {
  <strong>lateinit var</strong> name: String // 지연 초기화를 위한 선언

  fun test() {
      println(
          // <strong>::name</strong> name property 참조.
          // property의 초기화 여부를 판단한다.
          if (<strong>::name.isInitialized</strong>) "initialized"
          else "not initialized"
      )
  }
}

fun main() {
  val peter = Person() // peter.name은 아직 초기화 되지 않았다.
  peter.test()
  peter.name = "peter" // 이 시점에 초기화된다.
  peter.test()

  // 초기화 하지 않고 참조하면 예외가 발생한다.
  // <span class="error">kotlin.UninitializedPropertyAccessException:</span>
  // <span class="error">lateinit property name has not been initialized</span>
  println("name=${peter.name}")
}<hr>>>
not initialized
initialized
name=peter</pre>
  <h4>객체 지연 초기화하기</h4>
  <pre>
data class Person(var name: String, var age: Int)

<strong>lateinit</strong> var person: Person // 객체 생성의 지연 초기화.

fun main() {
    <strong>person = Person("peter", 18)</strong> // 생성자 호출 시점에서 초기화됨.
    println(person)
}</pre>
  <h3 class="title">lazy를 사용한 지연 초기화</h3>
  <ul class="mt-0">
    <b>lazy 특징</b>
    <li>호출 시점에 <strong>by lazy {...}</strong> 정의에 의해 block 부분의 초기화를 진행한다.</li>
    <li><strong>val</strong>에서만 사용할 수 있다.</li>
    <li><code>val</code>이므로 값을 다시 변경할 수 없다.</li>
  </ul>
  <h4 class="mb-0">Property 지연 초기화하기</h4>
  <code>lazy</code>는 lambda식으로 구성되어 lazy instance 반환값을 가지는 함수다.<br>
  property에 <strong>최초로 접근</strong>한 시점에 해당 property가 초기화된다.
  <pre>
class LazyTest {
  init {
      println("init block")
  }

  <strong>val</strong> subject <strong>by lazy</strong> {
      println("lazy initialized")
      "kotlin programming"
  }

  fun flow() {
      println("not initialized")
      
      // val로 선언되었기 때문에 다시 값을 설정할 수 없다.
      println("subject one: <strong>$subject</strong>") // 최초 초기화 시점
      
      println("subject two: <strong>$subject</strong>") // 이미 초기화된 값 사용
  }
}

fun main() {
  val test = LazyTest() // 객체 생성. init{} 실행
  test.flow()
}<hr>>>
init block
not initialized
lazy initialized
subject one: kotlin programming
subject two: kotlin programming</pre>
  <h4 class="mb-0">객체 지연 초기화하기</h4>
  객체의 property나 method가 접근되는 시점에 초기화된다.
  <pre>
class Person(val name: String, val age: Int)

fun main() {
    var isPersonInstantiated: Boolean = false // 초기화 확인 용도

    <strong>val</strong> <span class="custom">person</span>: <strong>Person</strong> <strong>by lazy</strong> {
        isPersonInstantiated = true
        Person("peter", 18) // Lazy 객체로 반환된다.
    }

    // 위임 변수를 사용한 초기화
    <strong>val</strong> <span class="custom">personDelegate</span> = <strong>lazy</strong> { Person("Tony", 40) }

    println("person Init: $isPersonInstantiated")
    println("personDelegate Init: ${personDelegate<span class="keyword">.isInitialized()</span>}")

    // 객체의 property나 method가 접근되는 시점에 초기화된다.
    println("person.name=${<strong>person</strong>.name}") // 이 시점에 초기화
    println("personDelegate.value.name = ${<strong>personDelegate.value</strong>.name}") // 이 시점에 초기화

    println("person Init: $isPersonInstantiated")
    println("personDelegate Init: ${personDelegate<span class="keyword">.isInitialized()</span>}")

    <span class="custom">person</span>.javaClass                // class Person
    <span class="custom">personDelegate</span>.javaClass        // class kotlin.SynchronizedLazyImpl
    <span class="custom">personDelegate.value</span>.javaClass  // class Person  
}<hr>>>
person Init: false
personDelegate Init: false
person.name=peter
personDelegate.value.name = Tony
person Init: true
personDelegate Init: true</pre>
  <table class="th-ta-r">
    <tr>
      <th><code class="no-bgc">by lazy {}</code></th>
      <td>객체의 위임</td>
    </tr>
    <tr>
      <th><code class="no-bgc">lazy {}</code></th>
      <td>변수에 위임된 Lazy 객체. 이 객체의 <strong>value</strong> property로 실제 객체에 접근한다.</td>
    </tr>
  </table>
  <h4>lazy 모드 확인하기</h4>
  LazyJVM.kt
  <pre>
public actual fun &lt;T> <span class="custom">lazy</span>(initializer: () -> T): <strong>Lazy&lt;T></strong> = <span class="custom">SynchronizedLazyImpl</span>(initializer)

public actual fun &lt;T> <span class="custom">lazy</span>(mode: LazyThreadSafetyMode, initializer: () -> T): <strong>Lazy&lt;T></strong> =
  when (mode) {
      LazyThreadSafetyMode<span class="keyword">.SYNCHRONIZED</span> -> <span class="custom">SynchronizedLazyImpl</span>(initializer)
      LazyThreadSafetyMode<span class="keyword">.PUBLICATION</span> -> <span class="custom">SafePublicationLazyImpl</span>(initializer)
      LazyThreadSafetyMode<span class="keyword">.NONE</span> -> <span class="custom">UnsafeLazyImpl</span>(initializer)
  }</pre>
  <table class="th-ta-r">
    <caption>Lazy mode</caption>
    <tr>
      <th>SYNCHRONIZED</th>
      <td>기본값. lock을 사용해 단일 thread만이 사용하는 것을 보장한다.</td>
    </tr>
    <tr>
      <th>PUBLICATION</th>
      <td>여러 군데에서 호출될 수 있으나 처음 초기화된 후 반환값을 사용한다.</td>
    </tr>
    <tr>
      <th>NONE</th>
      <td>lock을 사용하지 않기 때문에 빠르지만 다중 thread가 접근할 수 있다. (값의 일관성을 보장할 수 없다.)</td>
    </tr>
  </table>
  <h3 class="title mb-0">by를 이용한 위임 <sub>Delegation</sub></h3>
  <pre>// 위임자 : Property나 Class를 대신할 객체
&lt;val | var | class> property 또는 class 이름: 자료형 <strong>by</strong> 위임자</pre>
  <h4>Class의 위임</h4>
  Sample.kt
  <pre>
interface Animal {
  fun eat() { ... }
  ...
}

class Cat : Animal {}
val cat = Cat()

// Animal의 정의된 Cat의 모든 member를 Robot에 위임
class Robot : Animal <strong>by cat</strong></pre>
  Robot은 Cat이 가지는 모든 Animal의 method를 가진다.<br><br>
  Sample.decompiled.java로 변환된 source code (대략)
  <pre>
public interface Animal {
  void eat();

  public static final class DefaultImpls {
    public static void eat(@NotNull Animal $this) {}
  }
}
  
public final class Cat implements Animal {
  public void eat() {
      Animal.DefaultImpls.eat(this);
  }
}

public final class SampleKt {
  @NotNull
  private static final Cat cat = new Cat();

  @NotNull
  public static final Cat getCat() { return cat; }
}

public final class Robot implements Animal {
  private final Cat cat = SampleKt.getCat();

  public void eat() {
      this.cat.eat();
  }
}</pre>
  Robot class를 사용할 때 Animal을 명시적으로 참조하지 않고도 eat()를 바로 호출하는 것이 가능하다.<br>

  <p><span class="material-icons red">info</span>왜 위임을 사용할까?<br>
    기본적으로 Kotlin이 가지고 있는 표준 library는 open으로 정의되지 않은 class를 사용하고 있다.<br>
    즉, 모두 final 형태의 class로 상속이나 직접 class의 기능을 확장하는것을 어렵게 만들었다.<br>
    이렇게 함으로써 표준 library의 무분별한 상속에 따른 복잡한 문제를 방지할 수 있었다.<br>
    따라서 필요한 경우에만 위임을 통해 상속과 비슷하게 해당 class의 모든 기능을 사용하면서 동시에 기능을 추가 확장을 구현할 수 있다.</p>
  <pre>
interface Car {
  fun info(): String
}

class VanImpl(val power: String) : Car {
  override fun info() = "짐을 적재하며 ${power}을 가진다."
}

class SportImpl(val power: String) : Car {
  override fun info() = "경주용에 사용되며 ${power}을 가진다."
}

class CarModel(val model: String, <strong>impl: Car</strong>) : Car <strong>by</strong> impl {
  fun carInfo() {
      println("$model : ${<strong>info()</strong>}") // 참조 없이 각 interface 구현 class의 info()에 접근.
  }
}

fun main() {
  val truck = CarModel("트럭 2010", <strong>VanImpl("100마력")</strong>)
  val sport = CarModel("포르쉐 2008", <strong class="lh-1">SportImpl("350마력")</strong>)

  truck.carInfo()
  sport.carInfo()
}<hr>>>
트럭 2010 : 짐을 적재하며 100마력을 가진다.
포르쉐 2008 : 경주용에 사용되며 350마력을 가진다.</pre>
  <h4>Property 위임과 <code>by lazy</code></h4>
  <ul class="mt-0" style="list-style: decimal;"><b>동작 설명</b>
    <li>lazy lambda식은 lambda식을 전달받아 저장한 Lazy&lt;T> instance를 반환한다.</li>
    <li>최초 property의 getter 실행은 lazy에 넘겨진 lambda식을 실행하고 결과를 기록한다.</li>
    <li>이후 property의 getter 실행은 이미 초기화되어 기록된 값을 반환한다.</li>
  </ul>
  <code>by lazy</code>에 의한 지연 초기화는 thread에 좀 더 안정적으로 property를 사용할 수 있다.<br>
  예를 들어 program 시작 시 큰 객체가 있다면 초기화할 때 모든 내용을 시작 시간에 할당해야 하므로 느려질 수밖에 없다.<br>
  이것을 필요에 따라 해당 객체를 접근하는 시점에 초기화하면 시작할 때마다 property를 생성하느라 소비되는 시간을 줄일 수 있다.<br>
  <h4>observable()과 vetoable()의 위임</h4>
  <pre>import kotlin.properties.Delegates</pre>
  <ul>
    <li>observable()<br>property를 감시하고 있다가 특정 code의 logic에서 변경이 일어날 때 호출되어 처리된다.<br>
      특정 변경 event에 따라 호출되므로 callback이라고도 불린다.</li>
    <li>vetoable()<br>
      반환값에 따라 property 변경을 허용하거나 취소할 수 있다.</li>
  </ul>
  Delegates.kt
  <pre>
public object Delegates {
  ...
  // initialValue : property의 초깃값
  // onChange : property 변경된 후 호출되는 callback
  public inline fun &lt;T> <strong>observable</strong>(
    initialValue: T, 
    crossinline onChange: (property: KProperty&lt;*>, oldValue: T, newValue: T) -> Unit
  ): ReadWriteProperty&lt;Any?, T> = object: ObservableProperty&lt;T>(initialValue) {
    override fun <strong>afterChange</strong>(property: KProperty&lt;*>, oldValue: T, newValue: T) = <strong>onChange</strong>(property, oldValue, newValue)
  }

  // initialValue : property의 초깃값
  // onChange : property 값의 변경이 시도되기 전 호출.
  // 이 callback이 호출되었을 때는 property는 아직 변경되지 않음.
  // callback이 true를 반환하면 새 값이 지정된것이고, false라면 새 값은 취소되고 이전 값을 유지한다.
  public inline fun &lt;T> <strong>vetoable</strong>(
    initialValue: T, 
    crossinline onChange: (property: KProperty&lt;*>, oldValue: T, newValue: T) -> Boolean
  ): ReadWriteProperty&lt;Any?, T> = object: ObservableProperty&lt;T>(initialValue) {
    override fun <strong>beforeChange</strong>(property: KProperty&lt;*>, oldValue: T, newValue: T): Boolean = <strong>onChange</strong>(property, oldValue, newValue)
  }
}</pre>
  <h4 class="mb-0">observable()의 사용 방법</h4>
  <pre>
import kotlin.properties.Delegates

class User {
  var name: String <strong>by</strong> <strong>Delegates.observable</strong>("NONAME") { // property 위임
    prop, old, new -> println("$old -> $new") // event가 발생할 때만 실행
  }
}

fun main() {
  val user = User()
  user.name = "peter"   // 값이 변경되는 시점에서 첫 event 발생
  user.name = "parker"  // 값이 변경되는 시점에서 두 번째 event 발생
}<hr>>>
NONAME -> peter
peter -> parker</pre>
  <h4 class="mb-0">vetoable()의 사용 방법</h4>
  <pre>
import kotlin.properties.Delegates

fun main() {
  var max: Int <strong>by</strong> <strong>Delegates.vetoable</strong>(0) { prop, old, new -> 
    new > old // 조건에 맞지 않으면 old 값을 유지한다.
  }

  println(max)

  max = 10
  println(max)

  max = 5
  println(max)
}<hr>>>
0
10
10</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">06-3</span>정적<sub>Static</sub> 변수와 Companion 객체</h2>
  Program을 실행할 때 고정으로 가지는 memory로 객체 생성 없이 사용할 수 있다.
  <h3 class="title">정적 변수와 Companion 객체</h3>
  <h4>Companion 객체 사용하기</h4>
  Kotlin에서는 정적 변수를 사용할 때 static keyword가 없는 대신 Companion 객체를 제공한다.
  <pre>
class <span class="custom">Person</span> {
  var id: Int = 0
  var name: String = "peter"
  
  // singleton
  <strong>companion object</strong> {
    var language: String = "english"
    fun work() {
      println("Working...")
    }
  }
}

fun main() {
  // Person의 instance를 만들지 않고 사용
  println(<span class="custom">Person</span>.language)
  <span class="custom">Person</span>.language = "korean"
  println(<span class="custom">Person</span>.language)
  <span class="custom">Person</span>.work()

  println(<span class="custom">Person</span>.name) // <span class="error">Error!</span> name은 Companion 객체가 아니다.
}<hr>>>
english
korean
Working...</pre>
  <h4><a href="https://kotlinlang.org/docs/gradle.html#targeting-the-jvm" target="_blank">Targeting the JVM</a> (with Gradle)</h4>
  To target the JVM, apply the Kotlin JVM plugin.
  <pre>
// build.gradle.kts    
plugins {
  kotlin("jvm") version "1.5.10"
}</pre>
  <h4 class="mb-0">Kotlin과 Java sources</h4>
  Kotlin sources는 Java sources와 같은 folder에 저장되거나 다른 folder에 저장될 수 있다.<br>
  기본 규칙은 다른 folder를 사용하는 것이다.
  <pre>
project
  - src
    - main (root)
      - kotlin
      - java</pre>
  기본 규칙을 사용하지 않으면 대응되는 <code>sourceSet</code> 속성을 갱신해야 한다.
  <pre>
sourceSet.main {
  java.srcDirs("src/main/myJava", "src/main/myKotlin")
}</pre>
  <h4>Kotlin에서 Java의 static member 사용하기</h4>
  /src/main/<code>java/chaop06/section3/</code>Customer.java
  <pre>
package chap06.section3;

public class Customer {
  public <strong>static</strong> final String <span class="custom">LEVEL</span> = "BASIC";

  public <strong>static</strong> void <span class="custom">login</span>() {
      System.out.println("Login...");
  }
}</pre><br>
  /src/main/<code>kotlin/chaop06/section3/</code>CustomerAccess.kt
  <pre>
package chap06.section3

fun main() {
  println(<strong>Customer</strong>.<span class="custom">LEVEL</span>)
  <strong>Customer</strong>.<span class="custom">login</span>()
}<hr>>>
BASIC
Login...</pre>
  <h4>Java에서 Kotlin Companion 객체 사용하기 <strong><code>@JvmStatic</code></strong></h4>
  <span class="material-icons red" style="float:left; font-size: 2rem;">info</span>Annotation : @ 기호로 시작.<br>Code에서는 특수한 의미를 부여해 compiler가 목적에 맞춰 해석하도록 하거나 실행할 때 특정 기능을 수행하게 할 수 있다.<br><br>
  /src/main/<code>kotlin/chaop06/section3/</code>KCustomer.kt
  <pre>
<span class="keyword">package</span> chap06.section3

<span class="keyword">class</span> KCustomer {
  <strong>companion object</strong> {
    // const는 complile time에 값이 할당된다. Java에서 접근하기 위해 필요하다. (val은 runtime에 할당된다.)
    // const는 기본형과 String에만 사용할 수 있다.
    <strong class="lh-1">const</strong> <span class="keyword">val</span> <span class="property">LEVEL</span> = <span class="comment">"INTERMEDIATE"</span>

    // @JvmStatic은 java source에서 code를 해석할 때 Companion을 생략할 수 있게 해준다.
    <strong class="lh-1">@JvmStatic</strong> <span class="keyword">fun</span> <span class="func-decl">login</span>() = println(<span class="comment">"Login ..."</span>)

    <strong class="lh-1">@JvmStatic</strong>
    <span class="keyword">fun</span> <span class="func-decl">hello</span>() = println(<span class="comment">"Hello!"</span>)

    // 특정 자료형을 사용하기 위한 annotation
    <strong>@JvmField val JOB = KJob()</strong>
  }
}

class <strong>KJob</strong>(var title: String = "Programmer")</pre><br>
  /src/main/<code>java/chaop06/section3/</code>KCustomerAccess.java
  <pre>
<span class="keyword">package</span> chap06.section3<span class="keyword">;</span>

<span class="keyword">public class</span> KCustomerAccess {

  <span class="keyword">public static void</span> <span class="func-decl">main</span>(String[] args) {
    System.<span class="property">out</span>.println(KCustomer.<span class="property">LEVEL</span>);
    KCustomer.login();            // @JvmStatic을 사용하는 경우.
    KCustomer.<span class="property">Companion</span>.login();  // @JvmStatic을 사용하지 않는 경우.

    // KJob에 대한 객체 생성 후 접근
    KJob kjob = <strong>KCustomer.JOB</strong>;
    System.out.println(<strong class="lh-1">kjob.getTitle()</strong>);

    // KCustomer를 통한 접근
    <strong>KCustomer.JOB.setTitle("Designer");</strong>
    System.out.println(<strong class="lh-1">KCustomer.JOB.getTitle()</strong>);
  }
}<hr>>>
INTERMEDIATE
Login ...
Login ...
Programmer
Designer</pre>
  <h3 class="title mb-25">최상위 함수 사용하기 <sub>Top-level Function / Package-level Function</sub></h3>
  /src/main/kotlin/chap06/section3/PackageLevelFunction.kt
  <pre>
package chap06.section3

fun packageLevelFunc() {
  println("Package-level Function")
}

fun main() {
  packageLevelFunc()
}</pre><br>
  PackageLevelFunction.decompiled.java (간략)
  <pre>
package chap06.section3;

// .kt file 이름으로 자동 생성된 class
public final class <strong>PackageLevelFunctionKt</strong> {
  public <strong class="lh-1">static final</strong> void packageLevelFunc() {
    System.out.println("Package-level Function");
  }

  public static final void main() {
    packageLevelFunc();
  }

  public static void main(String[] var0) {
    main();
  }
}</pre>
  Class 이름을 자동 생성하지 않고 kotlin code에서 이름을 명시할 수 있다.<br>
  이름을 변경하고 싶다면 <strong><code>@file:JvmName("ClassName")</code></strong>을 code 위쪽에 입력하면 된다.<br>
  <pre>
<strong>@file:JvmName("PKLevel")</strong>

package chap06.section3

fun packageLevelFunc() {
  println("Package-level Function")
}

fun main() {
  packageLevelFunc()
}</pre>
  <pre>
package chap06.section3;

import kotlin.jvm.JvmName;

@JvmName(
  name = "PKLevel"
)
public final class <strong>PKLevel</strong> {
  public <strong class="lh-1">static final</strong> void packageLevelFunc() {
    System.out.println("Package-level Function");
  }
  ...
}</pre>
  최상위 함수는 JVM에서 실행하기 위해 내부적으로 static으로 선언되기 때문에 main() block에서 객체 생성없이 사용될 수 있다.
  <h3 class="title">object와 singleton</h3>
  <h4>object 선언</h4>
  <ul class="mt-0">
    <li>객체 첫 접근 때 객체가 생성된다.</li>
    <li>생성자 호출을 하지 않으므로 object 선언에는 주 생성자와 부 생성자를 사용할 수 <strong>없다</strong>.</li>
    <li>init{}은 최초 접근에서 실행된다.</li>
    <li>object 선언에도 class나 interface를 상속할 수 있다.</li>
    <li>Java에서 object 선언으로 생성된 instance에 접근하려면 <strong>INSTANCE</strong>를 사용한다.</li>
  </ul>
  /src/main/kotlin/chap06/section3/ObjectDeclaration.kt
  <pre>
package chap06.section3

class Hobby(val name: String)

// object keyword를 사용한 방식
<strong>object</strong> OCustomer {
  var name = "peter"

  init {
    println("Init")
  }

  fun greeting() = println("Hello World!")
  val HOBBY = Hobby("spider-man")
}

// Companion 객체를 사용한 방식
class CCustomer {
  <strong>companion object</strong> {
    <strong class="lh-1">const</strong> val HELLO = "Hello" // 상수 표현
    val name = "tony"

    <strong>@JvmField</strong> val HOBBY = Hobby("iron-man")
    <strong class="lh-1">JvmStatic</strong> fun greeting() = println("Hello World!")
  }
}

fun main() {
    OCustomer.greeting() // 접근 시점에 객체가 생성된다. init{} 실행
    OCustomer.name = "parker"
    println("name=${OCustomer.name}")
    println("hobby=${OCustomer.HOBBY.name}")
    println("-----------------------")

    CCustomer.greeting()
    println("name=${CCustomer.name}, HELLO=${CCustomer.HELLO}")
    println("hobby=${CCustomer.HOBBY.name}")
}<hr>>>
Init
Hello World!
name=parker
hobby=spider-man
-----------------------
Hello World!
name=tony, HELLO=Hello
hobby=iron-man</pre><br>
  /src/main/java/chap06/section3/OCustomAccess.java
  <pre>
package chap06.section3;

public class OCustomAccess {
  public static void main(String[] args) {
    // Kotlin의 object 선언 객체의 method 접근.
    String name = OCustomer.<strong>INSTANCE</strong>.getName();
    System.out.println(name);
  }
}<hr>>>
Init
peter</pre><br>
  ObjectDeclaration.decompiled.java (간략)
  <pre>
public final class OCustomer {
  @NotNull
  private <strong>static</strong> String name;
  @NotNull
  private <strong>static final</strong> Hobby HOBBY;
  @NotNull
  public <strong>static final</strong> OCustomer <strong>INSTANCE</strong>;

  @NotNull
  public final String getName() {
    return name;
  }

  public final void setName(@NotNull String var1) {
    name = var1;
  }

  public final void greeting() {
    System.out.println("Hello World!");
  }

  @NotNull
  public final Hobby getHOBBY() {
    return HOBBY;
  }

  private OCustomer() {}

  <strong>static</strong> {
    OCustomer var0 = new OCustomer();
    <strong>INSTANCE</strong> = var0;
    name = "peter";
    HOBBY = new Hobby("spider-man");
    System.out.println("Init");
  }
}</pre>
  <h4>object 표현식</h4>
  <ul class="mt-0">
    <li>object 선언과 달리 이름이 없고 singleton이 아니다.</li>
    <li>object 표현식이 사용될 때마다 새로운 instance가 만들어진다.</li>
    <li>결과적으로 익명 내부 class로 불리는 형태를 object 표현식으로 만들 수 있다.</li>
  </ul>
  <pre>
package chap06.section3

<strong>open</strong> class Superman {
  fun work() = println("Taking photos.")
  fun talk() = println("Talking with people.")
  <strong>open</strong> fun <strong>fly()</strong> = println("Flying in the sky.")
}

fun main() {
  val pretendMan = <strong>object:</strong> Superman() {
    // 재정의
    <strong>override</strong> fun <strong class="lh-1">fly()</strong> = println("I'm not a real Superman. I can't fly!")
  }

  pretendMan.work()
  pretendMan.talk()
  pretendMan.fly()
}<hr>>>
Taking photos.
Talking with people.
I'm not a real Superman. I can't fly!</pre><br>
  딱 한 번만 사용되는 interface인 경우.
  <pre>
interface Shape {
  fun onDraw()
}

// 익명 interafce 구현 class
val triangle = <strong>object:</strong> Shape {
  override fun onDraw() { ... }
}</pre><br>
  객체는 필요하지만 상위 interface나 class가 없는 경우.
  <pre>
fun foo() {
  val adHoc = <strong>object</strong> {
    var x: Int = 0
    var y: Int = 0
  }

  println(adHoc.x + adHoc.y)
}</pre>
  <ul class="mt-0">
    <li>이런 익명 객체는 local이나 private 정의 영역에서만 자료형으로 사용될 수 있다.</li>
    <li>만일 익명 객체를 public 함수의 반환 자료형이나 public 속성의 자료형에 쓴다면,<br>이러한 함수나 속성의 실제 자료형은 익명 객체로 선언된 상위 자료형이거나 상위 자료형을 선언하지 않으면 Any형이 된다.</li>
  </ul>
  <pre>
class C {
  // 반환 자료형은 익명 객체 자료형
  <strong>private</strong> fun foo() = object {
    val x: String = "x"
  }

  // 반환 자료형은 Any
  <strong>public</strong> fun publicFoo() = object {
    val x: String = "x"
  }

  fun bar() {
    val x1 = foo().x        // Ok
    val x2 = publicFoo().x  // <span class="error">Error!</span> Unresolved reference: x
  }
}</pre>
  Java의 익명 내부 class와 같이, object 표현식 안의 code는 둘러싸여 있는 범위 내부의 변수에 접근할 수 있다.<br>
  <pre>
fun countClicks(window: JComponent) {
  var <strong>clickCount</strong> = 0
  var <strong class="lh-1">enterCount</strong> = 0
  
  window.addMouseListener(<strong>object:</strong> MouseAdapter() {
    override fun mouseClicked(e: MouseEvent?) {
      clickCount++
    }

    override fun mouseEntered(e: MouseEvent?) {
      enterCount++
    }
  })
}</pre>
  <hr>
  <h1><span class="titleNumber">07</span>다양한 Class와 Interface</h1>
  <h2 class="title"><span class="titleNumber">07-1</span>추상 <sub>Abstract</sub> Class와 Interface</h2>
  <ul>
    <li>추상 class는 선언 등의 대략적인 설계 명세와 공통의 기능을 구현한 class.</li>
    <li>추상 class를 상속하는 하위 class에서 내용을 더 구체화해야 한다.</li>
    <li>Interface는 추상 class와 비슷하지만 property에 상태 정보를 저장할 수 없다.</li>
    <li>다중 상속과 같이 여러 개의 interface를 하나의 class에서 구현하는 것이 가능하다.</li>
  </ul>
  <h3 class="title">추상 Class <strong><code>abstract</code></strong></h3>
  <h4>추상 Class의 정의와 구현</h4>
  <pre><strong>abstract</strong> class Vehicle</pre>
  <ul>
    <li>Property나 method도 abstract로 선언될 수 있다. 이를 추상 property, 추상 method라고 부른다.</li>
    <li>기본 property나 method는 abstract가 아니므로 초기화나 구현이 필요하다.</li>
    <li>Class에 추상 property나 추상 method가 있다면 추상 class로 선언되어야 한다.</li>
    <li>추상 요소는 재정의 할 때 open keyword를 사용할 필요가 없다.</li>
  </ul>
  <pre>
<strong>abstract</strong> class Vehicle(val name: String, val color: String, val weight: Double) {

  // 추상 property. 하위 class에서 반드시 재정의해 초기화해야 한다.
  <strong>abstract</strong> var maxSpeed: Double

  // 추상 method. 반드시 하위 class에서 구현해야 한다.
  <strong class="lh-1">abstract</strong> fun start()
  <strong>abstract</strong> fun stop()

  // 일반 property. 초깃값인 상태를 저장할 수 있다.
  var year = "2021"

  fun displaySpec() = println("name=$name, color=$color, weight=$weight, year=$year, maxSpeed=$maxSpeed")
}

class Car(name: String, color: String, weight: Double, <strong>override</strong> var maxSpeed: Double) : Vehicle(name, color, weight) {
  <strong class="lh-1">override</strong> fun start() = println("Car started")
  <strong>override</strong> fun stop() = println("Car stopped")
}

class Motorcycle(name: String, color: String, weight: Double, <strong>override</strong> var maxSpeed: Double) : Vehicle(name, color, weight) {
  <strong class="lh-1">override</strong> fun start() = println("Motorcycle started.")
  <strong>override</strong> fun stop()  = println("Motorcycle stopped.")
}

fun main() {
  val car = Car("porsche", "red", 1500.0, 300.0)
  car.displaySpec()
  car.start()

  val motorcycle = Motorcycle("aq-300", "black", 170.0, 150.0)
  motorcycle.displaySpec()
  motorcycle.start()
}<hr>>>
name=porsche, color=red, weight=1500.0, year=2021, maxSpeed=300.0
Car started
name=aq-300, color=black, weight=170.0, year=2021, maxSpeed=150.0
Motorcycle started.</pre>
  <pre>
<strong>abstract</strong> class Printer {
  <strong class="lh-1">abstract</strong> fun print()
}

val myPrinter = <strong>object</strong>: Printer() { // 객체 instance
  <strong>override</strong> fun print() = println("printing ...")
}

fun main() {
  myPrinter.print()
}<hr>>> printing ...</pre>
  <h3 class="title">Interface</h3>
  <ul>
    <li>Interface에는 <code>abstract</code>로 선언된 추상 method나 일반 method가 포함된다.</li>
    <li>Method에 구현 내용이 포함될 수 있다. (Java 8 부터 지원)</li>
    <li>추상 property에 상태를 저장할 수 없고 선언만 가능하다.</li>
    <li>Interface도 추상 class 처럼 객체를 만들 수 없고 하위 class를 통해 구현 및 생성을 해야 한다.</li>
  </ul>
  <ul><b>사용 이유</b>
    <li>Interface는 다중 상속이 가능하다.</li>
  </ul>
  <h4>Interface의 선언과 구현 <strong><code>interface</code></strong></h4>
  <strong><code>interface</code></strong> keyword를 사용해 선언하고 하위 class에서는 <strong><code>override</code></strong>를 사용해 해당 method를 구현해야 한다.
  <pre>
interface interface_이름 [: interface_이름...] {
  추상_Property_선언
  추상_Method_선언

  [일반_Method_선언 { ... }]
}</pre>
  <pre>
<strong>interface</strong> Pet {
  <strong class="lh-1">var</strong> category: String    // 추상 property.
  fun feeding()           // 추상 method.

  // 구현부가 있는 경우 일반 method.
  fun patting() = println("Keep patting!")
}</pre>
  <ul>
    <li>Interface에는 abstract를 붙여 주지 않아도 기본적으로 추상 property와 추상 method로 지정된다.</li>
    <li>Method에 구현부가 있다면 일반 method이다.</li>
    <li>Property는 상태값을 가질 수 없다.</li>
  </ul>
  <pre>
class Cat(<strong>override</strong> var category: String) : <strong>Pet</strong> {
  <strong class="lh-1">override</strong> fun feeding() = println("Feed the cat a tuna can.")
}

fun main() {
  val obj = Cat("small")
  println("Pet category = ${obj.category}")

  obj.feeding() // 구현 method
  obj.patting() // 기본 method
}<hr>>>
Pet category = small
Feed the cat a tuna can.
Keep patting!</pre>
  <h4 class="mb-0">Getter를 구현한 property</h4>
  Interface에서는 property에 값을 저장할 수 없다. 단, <strong><code>val</code></strong>로 선언된 property는 getter를 통해 필요한 내용을 구현할 수 있다.
  <pre>
interface Pet {
  var category: String    // 추상 property.
  fun feeding()           // 추상 method.

  // val 선언 시 getter의 구현이 가능. 
  <strong class="lh-1">val msgTags: String</strong>
      <strong>get() = "I'm your lovely pet!"</strong>

  // 구현부가 있는 경우 일반 method.
  fun patting() = println("Keep patting!")
}
...
println("${obj.msgTags}")</pre>
  <span class="material-icons red" style="float:left">info</span>
  <ul>
    <li><code>val</code>로 선언된 msgTags는 초기화할 수 없지만 getter를 통해 반환값을 지정할 수 있다.</li>
    <li>하지만 여전히 보조 Field인 <code>field</code>를 사용할 수 없다.</li>
    <li><code>var</code>로 property를 선언하더라도 보조 Field를 사용할 수 없기 때문에 받은 <code>value</code>를 저장할 수 없다.</li>
  </ul>
  <h3 class="title">여러 Interface의 구현</h3>
  <h4>여러 interface를 이용한 다중 상속</h4>
  <pre>
package chap07.section1

<strong>interface Bird</strong> {
  val wings: Int
  fun fly()

  // 일반 method. 필요하면 구현 class에서 overriding 할 수 있다.
  fun jump() = println("Bird jump.")
}

<strong>interface Horse</strong> {
  val maxSpeed: Int
  fun run()
  fun jump() = println("Horse jump. maxSpeed = $maxSpeed")
}

class Pegasus(<strong>override</strong> val wings: Int = 2, <strong>override</strong> val maxSpeed: Int = 100) : <strong>Bird, Horse</strong> {

  init { println("Pegasus init") }

  <strong class="lh-1">override</strong> fun fly() = println("Fly!")
  <strong class="lh-1">override</strong> fun run() = println("Run!")
  <strong class="lh-1">override</strong> fun jump() {
    <strong>super&lt;Horse></strong>.jump() // Horse의 jump()를 사용하는 경우다.
    println("Pegasus jump!")
  }
}

fun main() {
  Pegasus().run {
    fly()
    run()
    jump()
  }
}<hr>>>
Pegasus init
Fly!
Run!
Horse jump. maxSpeed = 100
Pegasus jump!</pre>
  <h3 class="title mb-0">Interface의 위임</h3>
  <pre>
<strong>interface A</strong> {
  fun funcA() = println("A.funcA()")
}

<strong>interface B</strong> {
  fun funcB() = println("B.funcB()")
}

class C(<strong>val a: A, val b: B</strong>) {
  fun funcC() {
    <strong class="lh-1">a.</strong>funcA()
    <strong>b.</strong>funcB()
  }
}

class DelegatedC(<strong>a: A, b: B</strong>) : <strong>A by a, B by b</strong> {
  fun funcC() {
    funcA() // method를 '.' 없이 접근할 수 있다.
    funcB()
  }
}

fun main() {
  C(object: A {}, object: B {}).funcC()
  DelegatedC(object: A {}, object: B {}).funcC()
}<hr>>>
A.funcA()
B.funcB()
A.funcA()
B.funcB()</pre>
  <h4 class="mb-0">위임을 이용한 member 접근</h4>
  <pre>
interface Nameable {
  var name: String
}

class StaffName(override var name: String = "Peter") : Nameable

class Work : <strong>Runnable</strong> { // thread 실행을 위한 interface.
  <strong>override</strong> fun run() {
    println("Working...")
  }
}

// 매개변수에 해당하는 interface를 위임.
class Person(name: Nameable, work: Runnable) : <strong>Nameable by name, Runnable by work</strong>

fun main() {
  val person = Person(StaffName(), Work()) // 생성자를 사용해 객체를 바로 전달.
  println(<strong>person.name</strong>)
  <strong class="lh-1">person.run()</strong>
}<hr>>>
Peter
Working...</pre>
  <h3 class="title">Coffee 제조기 만들어 보기</h3>
  요구사항
  <pre>
Coffee를 만들려면 물을 끓이는 Heater가 필요하다.
Heater는 켜거나 끌 수 있다. 충분히 뜨거운지도 알 수 있다.
Coffee는 열사이펀<sub>Thermosiphon</sub>을 통해 추출한다.
열사이펀은 기압차를 통해 pumping하는 원리로 coffee액을 추출한다.
Coffee module은 이 열사이펀을 사용해 drip coffee를 제조한다.
이제 coffee를 제조하는 brewing 과정을 실행할 수 있게 한다.
Brewing 과정은 전원을 켜고 pumping -> coffee 완성 -> 전원 끄기 순서로 진행된다.</pre>
  <table class="td-ta-r">
    <caption>Coffee 제조를 위한 용어 정리</caption>
    <tr>
      <th scope="col">선언</th>
      <th scope="col">설명</th>
    </tr>
    <tr>
      <td>Heater</td>
      <td>일반적인 켜기, 끄기, 뜨거운 상태를 확인한다.</td>
    </tr>
    <tr>
      <td>ElectricHeater</td>
      <td>추상적인 heater를 구체화한 class</td>
    </tr>
    <tr>
      <td>Pump</td>
      <td>열사이펀 과정을 위한 pumping 기능을 가진 개념</td>
    </tr>
    <tr>
      <td>Thermosiphon</td>
      <td>Coffee 추출을 위한 방법 중 하나</td>
    </tr>
    <tr>
      <td>CoffeeModule</td>
      <td>Coffee module은 추출 방법을 선택할 수 있다. (여기선 열사이펀 방법만 사용한다.)</td>
    </tr>
    <tr>
      <td>MyDripCoffeeModule</td>
      <td>Coffee module을 전기 heater와 열사이펀을 조합해 구체화한다.</td>
    </tr>
    <tr>
      <td>CoffeeMaker</td>
      <td>최종 제품으로 coffee module을 통해 brewing 과정을 진행한다.</td>
    </tr>
  </table>
  <h4 class="mb-0">Coffee 제조기의 구현</h4>
  Heater.kt
  <pre>
interface Heater {
  fun on()
  fun off()
  fun isHot(): Boolean
}</pre><br>
  ElectricHeater.kt
  <pre>
class ElectricHeater(private var <strong>heating</strong>: Boolean = false) : <strong>Heater</strong> {

  <strong>override</strong> fun on() {
    println("[${this.javaClass.simpleName}] on")
    println("[${this.javaClass.simpleName}] heating...")
    heating = true
  }

  <strong>override</strong> fun off() {
    println("[${this.javaClass.simpleName}] off")
    heating = false
  }

  <strong>override</strong> fun isHot(): Boolean = heating
}</pre><br>
  Pump.kt
  <pre>
interface Pump {
  fun pump()
}</pre><br>
  Thermosiphon.kt
  <pre>
class Thermosiphon(heater: Heater) : <strong>Pump</strong>, <strong>Heater by heater</strong> {

  <strong>override</strong> fun pump() {
    if (isHot()) println("[${this.javaClass.simpleName}] pumping...")
  }
}</pre><br>
  CoffeeModule.kt
  <pre>
interface CoffeeModule {
  fun <strong>getThermosiphon</strong>(): Thermosiphon
}</pre><br>
  MyDripCoffeeModule.kt
  <pre>
class MyDripCoffeeModule : CoffeeModule {

  <strong class="lh-1">companion object</strong> {
    <strong>val</strong> electricHeater: ElectricHeater <strong>by lazy</strong> {
      ElectricHeater()
    }
  }

  <strong>private val</strong> _thermosiphon: Thermosiphon <strong>by lazy</strong> {
    Thermosiphon(electricHeater)
  }

  // 오직 이 method에서만 Thermosiphon을 초기화한다.
  // electricHeater, _thermosiphon는 여기서 초기화된다.
  <strong>override</strong> fun <strong>getThermosiphon</strong>(): Thermosiphon = _thermosiphon
}</pre><br>
  CoffeeMaker.kt
  <pre>
class CoffeeMaker(val coffeeModule: CoffeeModule) {
  fun <strong>brew</strong>() {
    val theSiphon: Thermosiphon = coffeeModule.getThermosiphon()
    theSiphon.apply {
      on()
      pump()
      println("Coffee, here! Enjoy!")
      off()
    }
  }
}

fun main() {
  val coffeeMaker = CoffeeMaker(<strong>MyDripCoffeeModule()</strong>)
  coffeeMaker.brew()
}<hr>>>
[ElectricHeater] on
[ElectricHeater] heating...
[Thermosiphon] pumping...
Coffee, here! Enjoy!
[ElectricHeater] off</pre>
  <hr>
  <h2 class="title"><span class="titleNumber">07-2</span>Data Class와 기타 Class</h2>
  <h3 class="title mb-0">Data 전달을 위한 Data Class</h3>
  <ul class="mt-0">
    <li>Data 전달을 위한 객체를 <b>DTO</b><sub>Data Transfer Object</sub> 라고 한다.<br>Java에서는 <b>POJO</b><sub>Plain Old Java Object</sub> 라고 부르기도 한다.</li>
    <li>DTO는 구현 logic를 가지지 않고 순수한 data 객체를 표현하기 때문에 속성과 getter/setter를 가진다.</li>
    <li>추가로 <code>toString(), equals()</code>등과 같은 data를 표현하거나 비교하는 method를 가진다.</li>
    <li>Kotlin은 data class를 정의할 때 이 method들을 내부적으로 자동으로 만들어 준다.</li>
  </ul>
  <ul><b>자동 생성되는 method들</b>
    <li>Property를 위한 getter/setter</li>
    <li>비교를 위한 <code>equals()</code>, key 사용을 위한 <code>hashCode()</code></li>
    <li>Property를 문자열로 변환해 순서대로 보여주는 <code>toString()</code></li>
    <li>객체 복사를 위한 <code>copy()</code></li>
    <li>Property에 상응하는 <code>component1(), component2()</code> 등</li>
  </ul>
  <pre class="border-line">Kotlin의 property = field (변수) + getter/setter</pre>
  <h4>Data Class 선언하기</h4>
  <pre><strong>data</strong> class Customer(<strong>var</strong> name: String, <strong>var</strong> email: String)</pre>
  <ul style="padding-left: 1rem; list-style: inside;">Data class는 다음 <b>조건을 만족</b>해야 한다.
    <li>주 생성자는 최소한 하나의 매개변수를 가져야 한다.</li>
    <li>주 생성자의 모든 매개변수는 <conde>val, var</conde>로 지정된 property여야 한다.</li>
    <li>Data class는 <code>abstract, open, sealed, inner</code>를 사용할 수 없다.</li>
  </ul>
  Data class는 오로지 data를 기술하는 용도로만 사용되지만 <br>필요하다면 부 생성자나 init block을 넣어 data를 위한 간단한 logic을 포함 할 수 있다.<br>
  <pre>
<strong>data</strong> class Customer(<strong>var name: String, var email: String</strong>) {

  var job: String = "Unknown"

  <strong>constructor</strong>(name: String, email: String, job: String) : this(name, email) {
    this.job = job
  }

  <strong>init</strong> { // 간단한 logic은 여기에
    println("init")
  }
}

fun main() {
  val customer = Customer("peter", "spiderman@avengers.com")
  println(customer)
}<hr>>>
init
<strong>Customer(name=peter, email=spiderman@avengers.com)</strong></pre>
  <table class="td-ta-r">
    <caption>Data class가 자동 생성하는 method들</caption>
    <tr>
      <th scope="col">method</th>
      <th scope="col">기능</th>
    </tr>
    <tr>
      <td><code class="no-bgc">equals()</code></td>
      <td>두 객체의 내용이 같은지 비교하는 연산자 (고유값은 다르지만 의미 값이 같을 때), <code>==</code> 연산자</td>
    </tr>
    <tr>
      <td><code class="no-bgc">hashCode()</code></td>
      <td>객체를 구별하기 위한 고유한 정숫값 생성<br>Data set이나 hash table을 사용하기 위한 하나의 생성된 index</td>
    </tr>
    <tr>
      <td><code class="no-bgc">copy()</code></td>
      <td>Builder 없이 특정 property만 변경해서 객체 복사하기
        <pre>val customer2 = customer.copy(name = "tony") // name 만 변경해서 복사</pre>
      </td>
    </tr>
    <tr>
      <td><code class="no-bgc">toString()</code></td>
      <td>Data 객체를 읽기 편한 문자열로 반환하기</td>
    </tr>
    <tr>
      <td><code class="no-bgc">componentN()</code></td>
      <td>객체의 선언부 구조를 분해하기 위해 property에 상응하는 method</td>
    </tr>
  </table>
  <h4 class="mb-0">객체 Destructuring 하기</h4>
  Destructuring : 객체가 가지고 있는 property를 개별 변수로 분해해 할당하는 것이다.
  <pre>
val (name, email) = customer
println("$name, $email") // peter, spiderman@avengers.com
val (_, email) = customer // email만 가져온다.

name = customer.component1() // 1st property
email = customer.component2() // 2nd property</pre>
  <pre>
val a = Customer("a", "a@mail.com")
val b = Customer("b", "b@mail.com")
val c = Customer("c", "c@mail.com")
val d = Customer("d", "d@mail.com")

val list = listOf(a, b, c, d)

for (<strong>(name, email)</strong> in list) {
  println("$name, $email")
}</pre>
  <pre>
fun myFunc(): Customer {
  <strong>return</strong> Customer("peter", "peter@mail.com")
}
...
val (name, email) = <strong>myFunc</strong>()</pre>
  <pre>
val myLambda = { <strong>(name, email)</strong>: Customer ->
  println(name)
  println(email)
}
myLambda(customer)</pre>
  <h3 class="title mb-0">내부 Class 기법</h3>
  <table class="td-ta-r">
    <caption>Java의 내부 class 종류</caption>
    <tr>
      <th scope="col">종류</th>
      <th scope="col">역할</th>
    </tr>
    <tr>
      <td>정적<sub>Static</sub> class</td>
      <td><strong>static</strong> keyword를 가지며 외부 class를 instance화하지 않고 바로 사용 가능한 내부 class.<br>(주로 builder에 이용)</td>
    </tr>
    <tr>
      <td>Member class</td>
      <td>Instance class로도 불리며 외부 class의 field나 method와 연동하는 내부 class.</td>
    </tr>
    <tr>
      <td>Local class</td>
      <td>초기화 block이나 method 내의 block에서만 유효한 class.</td>
    </tr>
    <tr>
      <td>익명<sub>Anonymous</sub> class</td>
      <td>이름이 없고 주로 일회용 객체를 instance화하면서 override method를 구현하는 내부 class.<br>가독성이 떨어진다.</td>
    </tr>
  </table>
  Java의 내부 class는 외부 class의 어떤 member field도 참조할 수 있다.<br>반대로 외부 class도 내부 class의 field에 접근할 수 있다.<br><br>
  <table class="td-ta-r">
    <caption>Java와 Kotlin의 내부 class 비교</caption>
    <tr>
      <th scope="col">Java</th>
      <th scope="col">Kotlin</th>
    </tr>
    <tr>
      <td>정적<sub>Static</sub> class</td>
      <td>중첩<sub>Nested</sub> class.<br>객체 생성 없이 사용 가능.</td>
    </tr>
    <tr>
      <td>Member class</td>
      <td>Inner class.<br>Field나 method와 연동하는 내부 class. <strong>inner</strong> keyword가 필요하다.</td>
    </tr>
    <tr>
      <td>Local class</td>
      <td>Local class.<br>Class의 선언이 block 안에 있다.</td>
    </tr>
    <tr>
      <td>익명<sub>Anonymous</sub> class</td>
      <td>Anonymous Object.<br><strong>object</strong> keyword를 통해 선언한다.</td>
    </tr>
  </table>
  <pre>
// Java의 Member class
class A {
  class B {
    // 외부 class A의 field에 접근 가능
  }
}

// Kotlin의 Inner class
class A {
  <strong>inner</strong> class B {
    // 외부 class A의 field에 접근 가능
  }
}
<hr>
// Java Static class
class A {
  <strong>static</strong> class B {}
}

// Kotlin Nested class
class A {
  class B {
    // 외부 class A의 property, method에 접근 불가.
  }
}</pre>
  <h4 class="mb-0">중첩 Class</h4>
  <ul class="mt-0">
    <li>바깥 class의 객체 생성 없이 사용 가능</li>
    <li>바깥 class의 member에 접근 불가</li>
    <li>바깥 class의 <strong>companion object</strong>에는 접근 가능.</li>
  </ul>
  <pre>
class Outer {
  val outVal = 1

  <strong>companion object</strong> {
    const val co = 3
    fun coFunc() = println("coFunc()")
  }

  class Nested {
    val inVal = 2

    fun inside() {
      println(inVal)
      println(outVal) // <span class="error">Error!</span>

      // 외부 class의 companion object 접근 가능
      println(co)
      coFunc()
    }
  }

  fun outside() {
    Nested().inside()
    println(Nested().inVal)
  }
}

fun main() {
  <strong>Outer.Nested()</strong>.inside()

  Outer.outside() // <span class="error">Error!</span>
  <strong>Outer()</strong>.outside()
}</pre>
  <h4 class="mb-0">Inner Class <strong>inner</strong></h4>
  <ul class="mt-0">
    <li>바깥 class의 member에 접근 가능</li>
    <li>바깥 class의 <code>private</code> member에도 접근 가능</li>
  </ul>
  <pre>
class Outer {
  <strong>private</strong> val ov1 = 1
  val ov2 = 2

  <strong>inner</strong> class Inner {
    fun innerFunc() {
      val iv = 3
      println("$ov1, $ov2, $iv")
    }
  }
}

fun main() {
  <strong>Outer().Inner()</strong>.innerFunc()
}</pre>
  <h4 class="mb-0">지역 Class</h4>
  Block 범위에서만 유효한 class<br>
  <pre>
class Outer {
  <strong>private</strong> val a = 1
  val b = 2

  fun myFunc() {
    val c = 3

    <strong>class</strong> Local {
      val d = 4

      fun localFunc() {
          val e = 5
          println("<strong>$a, $b, $c, $d, $e</strong>")
      }
    }

    <strong>Local()</strong>.localFunc()
  }
}

fun main() {
  Outer().myFunc()
}</pre>
  <h4>익명 객체 <strong>object</strong></h4>
  <pre>
<strong>interface Switch</strong> {
  fun on()
}

class SmartPhone {
  private var power = "off"

  fun powerOn() {
    val msg = "power"

    val powerSwitch = <strong>object : Switch</strong> {
      val a = 1
      
      <strong>override</strong> fun on() {
          power = "on"
          println("$msg $power $a")
      }
    }

    powerSwitch.on()
  }
}

fun main() {
  SmartPhone().powerOn()
}</pre>
  <h3 class="title">Sealed Class와 열거형 Class</h3>
  <h4>Sealed Class <strong>sealed</strong></h4>
  <ul class="mt-0">
    <li>미리 만들어 놓은 자료형들을 묶어서 제공한다.</li>
    <li>추상 class이므로 객체를 만들 수 없다.</li>
    <li>private 생성자만 가진다.</li>
    <li>같은 file 안에서만 상속이 가능하다.</li>
    <li>Block 안에 선언된 class는 상속이 필요한 경우 <code>open</code>으로 선언될 수 있다.</li>
  </ul>
  Sealed class를 선언하는 첫 번째 방법
  <pre>
<strong class="lh-1">sealed</strong> class <span class="custom">Result</span> {
  <strong>open</strong> class Success(val message: String) <strong class="lh-1">: Result()</strong>
  class Error(val code: Int, val message: String) <strong>: Result()</strong>
}

class Status <strong>: Result()</strong> // 같은 file 안에서만 상속이 가능.

class Inside <strong>: Result.Success</strong>("Good") // 내부 class 상속.</pre><br>
  Sealed class를 선언하는 두 번째 방법
  <pre>
<strong>sealed</strong> class <span class="custom">Result</span>

<strong>open</strong> class Success(val message: String) <strong>: Result()</strong>

class Error(val code: Int, val message: String) <strong>: Result()</strong>

class Status <strong>: Result()</strong>

class Inside : <strong>Success</strong>("Good")</pre><br>
  <pre>
fun main() {
  val result = <strong>Result.Success</strong>("Good!")
  val message = eval(result)
  println(message)
}

// 상태를 검사한다.
fun eval(result: Result): String = <strong>when</strong> (result) {
  <strong class="lh-1">is</strong> Status -> "in progress."
  <strong class="lh-1">is</strong> Result.Success -> result.message
  <strong>is</strong> Result.Error -> result.message
}</pre>
  <h4>열거형 Class <strong>enum</strong></h4>
  <ul class="mt-0">
    <li>여러 개의 상수를 선언하고 열거된 값을 조건에 따라 선택할 수 있는 특수한 class.</li>
    <li>Sealed class 처럼 다양한 자료형을 다루지 못하고 자료형이 동일한 상수를 나열한다.</li>
    <li>열거형 class의 각 상수는 객체로 취급한다.</li>
  </ul>
<pre class="border-line">
enum class Class_이름 [(생성자)] {
  상수1[(값)], 상수2[(값)], 상수3[(값)] ...
  [; Property 또는 Method]
}</pre>
<pre>
enum class Direction {
  NORTH, EAST, SOUTH, WEST
}</pre>
<pre>
enum class DayOfWeek(val <strong>num</strong>: Int) {
  MONDAY(<strong>1</strong>), TUESDAY(<strong>2</strong>), WEDNESDAY(<strong>3</strong>), THURSDAY(<strong>4</strong>), FRIDAY(<strong>5</strong>), SATURDAY(<strong>6</strong>), SUNDAY(<strong>7</strong>)
}

val day = <strong>DayOfWeek.SATURDAY</strong>
when (day.num) {
  1, 2, 3, 4, 5 -> "Weekday"
  6, 7 -> "Weekend"
}</pre>
<pre>
enum class Color(val r: Int, val g: Int, val b: Int) {
  RED(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0),
  GREEN(0, 255, 0), BLUE(0, 0, 255), INDIGO(75, 0, 130), 
  VIOLET(238, 130, 238)<strong>;</strong> // ; 으로 열거값의 끝을 표시한다.

  fun rgb() = (r * 256 + g) * 256 + b
}

fun main() {
  println(Color.BLUE.rgb()) // 255
  println(getColor(Color.VIOLET))
}

fun getColor(color: Color) = when (color) {
  Color.RED -> color.name             // "RED"
  Color.ORANGE-> color.ordinal        // 1 (0 부터 시작하는 순서)
  Color.YELLOW -> color.toString()    // "YELLOW"
  Color.GREEN -> color                // "GREEN"
  Color.BLUE -> color.b               // 0
  Color.INDIGO -> color.r             // 75
  Color.VIOLET -> color.rgb()         // 15631086
}</pre>


  <h3 class="title">Annotation Class</h3>
  <h4>Annotation 선언하기</h4>
  <h4>Annotation의 위치</h4>
  <h4>Annotation의 매개변수와 생성자</h4>
  <h4>표준 Annotation</h4>
  <hr>
  <h2 class="title"><span class="titleNumber">07-3</span>연산자 Overloading</h2>
  <h3 class="title">연산자의 작동 방식</h3>
  <h3 class="title">연산자의 종류</h3>
  <h4>산술 연산자</h4>
  <h4>호출 연산자</h4>
  <h4>Index 접근 연산자</h4>
  <h4>단일 연산자</h4>
  <h4>범위 연산자</h4>
  <h4>대입 연산자</h4>
  <h4>동등성 연산자</h4>
  <h4>비교 연산자</h4>
  <hr>
  <h1 class="madang"><span class="madang_number">셋째 마당</span><br>Kotlin<br>표준 Library의 활용</h1>
  <h1><span class="titleNumber">08</span>Generic과 배열</h1>
  <h2 class="title"><span class="titleNumber">08-1</span>Generic 다루기</h2>
  <h3 class="title">Generic의 일반적인 사용 방법</h3>
  <h4>Generic Class</h4>
  <hr>
  <h1><span class="titleNumber">09</span>Collection</h1>
  <hr>
  <h1><span class="titleNumber">10</span>표준 함수와 File 입출력</h1>
  <hr>
  <h1><span class="titleNumber">11</span>Coroutine과 동시성 Programming</h1>
  <hr>


  <p id="end">END</p>
</body>

</html>
<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    .red {
      color: red
    }

    .material-icons {
      display: inline-flex;
      vertical-align: middle;
    }

    .float {
      position: fixed;
      width: 4rem;
      height: 4rem;
      bottom: 2rem;
      right: 2rem;
      background-color: blueviolet;
      color: #FFF;
      border-radius: 2rem;
      text-align: center;
      box-shadow: 1px 1px 2px gray;
    }

    .my-float {
      font-size: 4rem;
    }

    pre {
      margin: .25rem;
      border-radius: .5rem;
      padding: .25rem .5rem;
      font-size: .9rem;
      background-color: #073042;
      color: whitesmoke;
      width: fit-content;
    }

    strong {
      background-color: goldenrod;
      padding: 0rem .25rem;
      border-radius: .25rem;
      color: black;
      display: inline-flex;
      font-size: .9rem;
    }

    pre>strong {
      font-family: monospace;
    }

    .madang,
    .center {
      text-align: center;
    }

    .madang_number {
      font-size: 0.75em;
      color: tomato;
      text-decoration-line: underline;
    }

    h1>.titleNumber {
      color: white;
      background-color: tomato;
      padding: .25rem .5rem;
      margin-right: .5rem;
    }

    h2.title {
      border-width: 1px;
      border-bottom-style: dashed
    }

    h2>.titleNumber,
    h3.title {
      color: tomato;
      margin-right: .5rem;
    }

    ul.roundBox {
      border: 1px solid lightgray;
      border-radius: 0.5em;
      padding: .5rem 2rem;
    }

    table,
    th,
    td {
      border-collapse: collapse;
      border: 1px solid gray;
      padding: 0.25em;
    }

    table.noneLine,
    table .noneLine {
      border-collapse: collapse;
      border: 1px none;
      padding: 0.25em;
      margin: 0.25em;
      background-color: #EEE;
    }

    th {
      background-color: lightgray;
    }

    span.title {
      background-color: red;
      padding: 0.1rem 0.25em;
    }

    kbd {
      border: 1px solid gray;
      border-radius: 10%;
      padding: 0.25em;
      background-color: lightgray;
      box-shadow: .05rem .05rem black;
    }

    img {
      max-width: 100%;
      height: auto;
    }

    a {
      text-decoration: none;
      border-bottom: 1px solid lightgray;
      padding-bottom: .1rem;
      cursor: pointer;
      color: inherit
    }

    a:hover {
      border-bottom: 1px solid black;
    }

    .number {
      font-family: D2Coding;
    }

    h4 {
      margin-bottom: .5rem;
    }

    .no-border {
      border: none;
    }

    table.no-border td {
      border: none;
    }

    code {
      font-size: .9rem;
    }
  </style>
  <title>Kotlin programming</title>
</head>

<body>
  <a href="#end" class="float">
    <span class="material-icons my-float">
      arrow_circle_down
    </span>
  </a>
  <h1 class="madang"><span class="madang_number">첫째 마당</span><br>Kotlin<br>기본 익히기</h1>
  <h1><span class="titleNumber">01</span>시작하기</h1>
  <h2 class="title"><span class="titleNumber">01-1</span> 탄생 배경</h2>
  <h3 class="title">소개합니다</h3>
  <p>IntelliJ IDEA라는 통합 개발 환경으로 유명한 JetBrains에서 개발했다.<br>
  <ul>
    <li><a href="https://kotlinlang.org/" target="_blank">Kotlinlang.org</a></li>
    <li><a href="https://github.com/JetBrains/kotlin/" target="_blank">Github Kotlin</a></li>
  </ul>
  </p>
  종류
  <ul>
    <li>Kotlin/JVM : Java 가상 Machine에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/JS : Javascript로 web browser에서 동작하는 application을 만들 수 있다.</li>
    <li>Kotlin/Native : LLVM compiler를 이용하여 여러 platform을 target으로 하는 application을 만들 수 있다.</li>
  </ul>
  사용 환경
  <ul>
    <li>Apple iOS (arm32, arm64, emulator x86_64)</li>
    <li>Apple Mac OS(x86_64)</li>
    <li>Android (arm32, arm64)</li>
    <li>Windows (MinGW x86_64)</li>
    <li>Linux (x86_64, arm32, MIPS, MIPS litter-endian)</li>
    <li>Web 전용(wasm32)</li>
  </ul>
  Java와 완벽하게 호환된다.
  <h3 class="title">장점</h3>
  <ul>
    <li>Compiled 자료형을 검사하여 확정하는 정적 언어로 자료형 오류를 초기에 발견할 수 있다.</li>
    <li>NPE <sub>Null pointer exception</sub>로 인한 program의 중단을 예방할 수 있다.</li>
    <li>아주 간결하고 효율적이다.</li>
    <li>함수형 programming과 객체 지향 programming이 모두 가능하다.</li>
    <li>';' 을 생략할 수도 있다.</li>
  </ul>
  <h3 class="title">Android 공식 언어로 채택된 Kotlin</h3>
  <h4>JDK 들</h4>
  <ul>
    <li><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank">Oracle JDK</a></li>
    <li><a href="https://openjdk.java.net/" target="_blank">Open JDK</a></li>
    <li><a href="https://www.azul.com/" target="_blank">Zulu</a></li>
  </ul>
  <h3 class="title">IntelliJ IDEA 설치하기</h3>
  <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ IDEA 2021.1.1 (211.7142.45 build)</a>
  <h2 class="title"><span class="titleNumber">01-3</span> Kotlin project 시작하기</h2>
  <h3 class="title">Kotlin project 만들기</h3>
  <h4>Hellokotlin project 만들기</h4>
  <img src="images/creatNewProject.png" width="582" height="414" alt="Create New Project" title="새 project 생성하기"><br>
  <img src="images/newProject.png" width="925" height="686" alt="New Project" title="Kotlin/JVM project 선택"><br>
  <img src="images/newProject2.png" width="952" height="423" alt="New Project2" title="Kotlin/JVM project 선택 2"><br>
  <img src="images/newProject3.png" width="735" height="197" alt="New Project3" title="Kotlin/JVM project 선택 3"><br>
  <img src="images/newProject4.png" width="334" height="261" alt="New Project4" title="Kotlin/JVM project 선택 4"><br>
  HelloKotlin.kt
  <pre>
fun main() {
  println("Hello Kotlin!")
}</pre>
  <code>Run > Run > HelloKotlinKt > Run</code> menu를 선택해서 실행한다.
  <pre>
// 결과
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Hello Kotlin!

Process finished with exit code 0</pre>
  <h3 class="title">Project 하나씩 뜯어보기</h3>
  <h4>Kotlin의 <code>main()</code> 함수는 program의 실행 진입점</h4>
  <ul>
    <li>Kotlin code는 JVM에서 실행되며, <code>main()</code> 함수가 있는 file 이름을 기준으로 Java class가 자동 생성된다.</li>
    <li>자동 생성된 class는 <code>Tools > Kotlin > Show Kotlin Bytecode</code>에서 <code>Decompile</code>(역compile) button을 누르면 확인할 수 있다.</li>
  </ul>
  <pre>
// compiler의 version에 따라 다를 수 있다. 
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

@Metadata(
    mv = {1, 5, 1},
    k = 2,
    d1 = {"\u0000\u0014\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u0011\n\u0002\u0010\u000e\n\u0002\b\u0002\u001a\u0019\u0010\u0000\u001a\u00020\u00012\f\u0010\u0002\u001a\b\u0012\u0004\u0012\u00020\u00040\u0003¢\u0006\u0002\u0010\u0005¨\u0006\u0006"},
    d2 = {"main", "", "args", "", "", "([Ljava/lang/String;)V", "HelloKotlin.main"}
)
public final class HelloKotlinKt {
    public static final void main(@NotNull String[] args) {
      Intrinsics.checkNotNullParameter(args, "args");
      String var1 = "Hello Kotlin!";
      boolean var2 = false;
      System.out.println(var1);
    }
}</pre>
  <h4>Program의 memory 영역</h4>
  <table>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
    <tr>
      <th>Code</th>
      <td>명령어가 저장된다.</td>
    </tr>
    <tr>
      <th>Data</th>
      <td>문자열, 정적 변수등이 저장된다. Method Static Area, 정적 memory 영역, literal pool</td>
    </tr>
    <tr>
      <th>Heap</th>
      <td>실행 중 생성되는 객체들이 저장된다. <span class="material-icons">arrow_downward</span> 아래쪽 방향으로 증가, 동적 memory 영역</td>
    </tr>
    <tr>
      <th>Stack</th>
      <td>지역 변수나 함수 호출 정보(매개변수)가 저장된다. <span class="material-icons">arrow_upward</span>위쪽 방향으로 증가</td>
    </tr>
  </table>
  <span class="material-icons">info</span><code>Garbage Collection</code> : JVM은 더 이상 참조하지 않는 객체들을 자동으로 memory에서 삭제해준다.
  <h4>Kotlin의 <code>main()</code> method에서 매개변수를 사용할 경우</h4>
  <code>main()</code>에 전달할 외부의 인자들을 가리키고, 명령행에서 입력받은 값들이 차례대로 배열에 저장된다.<br>
  <pre>
fun main(<strong>args: Array&lt;String></strong>) {
  for (str in args) {
      println(str)
  }
}</pre>
  <code>Run > Edit Configurations... > Program arguments</code> 에 'Good 안녕 123'을 입력한다.
  <pre>
// 실행 결과 화면
"C:\Program Files\Java\jdk1.8.0_291\bin\java.exe" ...
Good
안녕
123

Process finished with exit code 0</pre>
  <hr>
  <h1><span class="titleNumber">02</span>변수와 자료형, 연산자</h1>
  <h2 class="title"><span class="titleNumber">02-1</span>코틀린 패키지</h2>
  Kotlin에서 Project는 Module, Package, File로 구성된다.
  <h3 class="title">Project, Module, Package, File의 관계 이해하기</h3>
  <ul>
    <li style="list-style: none;">HelloKotlin (Project)
      <ul>
        <li>HelloKotlin (Module 1)
          <ul>
            <li>default (Package)
              <ul>
                <li>HelloKotlin.kt (File)</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>OtherModule (Module 2)</li>
      </ul>
    </li>
  </ul>
  <ul>
    <li>default package는 src folder에 따로 package 이름을 지정하지 않은 file들이 포함된다.</li>
    <li>Kotlin file은 .kt 확장자를 가지며 compiler가 알 수 있도록 file의 맨 위에는 이 file이 속한 package 이름을 선언해야 한다.</li>
    <li>그렇지 않으면 자동으로 <strong>default</strong> package에 포함된다.</li>
    <li>file이 package folder 안에 있어도 package 이름을 선언하지 않으면 default package에 포함된 것으로 인식한다.</li><br>
    <li>File에 1개의 class가 정의되어 있다면 project 창 화면에 .kt 확장자가 빠진 class 이름만 보인다.</li>
    <li>File에 여러 개의 class를 정의한다면 file은 단순히 class를 묶는 역할을 하고 .kt 확장자가 붙게 된다.</li>
    <li>Kotlin에서는 file 이름과 class의 선언 개수에 큰 의미를 두지 않는다.</li>
    <li>같은 file에 들어 있는 class들은 모두 그 file에 지정한 package로 인식한다.</li>
    <li>Kotlin은 Java처럼 class 이름과 file 이름이 같아야 하고, plublic class는 하나만 사용해야 하는 규칙이 <strong>없다</strong>.</li>
  </ul>
  <h4>Package를 만들어야 하는 이유</h4>
  같은 이름의 file이라도 package가 다르면 다른 file로 인식되어 중복 오류가 발생하지 않는다.
  <h3 class="title">Kotlin project에 package 만들기</h3>
  <h4>Package 이름 정하기</h4>
  <ul>
    <li>이름은 file 첫 줄에 적는다.</li>
    <li><code><strong>package</strong></code> keyword를 앞에 붙인다.</li>
    <li>이름은 특수문자나 숫자로 시작하면 안된다.</li>
    <li>여러 단계의 분류가 필요하면 <strong>.</strong> 을 붙여 이름을 짓는다.</li>
  </ul>
  예) <code><strong>package com.acaroom.net.upload</strong></code>
  <h3 class="title">기본 package 활용하기</h3>
  <ul>
    <li>기본 package는 자주 사용하는 class와 함수 등을 미리 만들어 놓은 것이다.</li>
    <li><code><strong>import</strong></code> keyword로 package를 선언하지 않아도 바로 사용할 수 있다.</li>
  </ul>
  <table>
    <caption>기본 package</caption>
    <tr>
      <th>이름</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>kotlin.*</code></td>
      <td><code>Any, Int, Double</code> 등 핵심 함수와 자료형</td>
    </tr>
    <tr>
      <td><code>kotlin.text.*</code></td>
      <td>문자와 관련된 API</td>
    </tr>
    <tr>
      <td><code>kotlin.sequences.*</code></td>
      <td>Collection 자료형의 하나로 반복이 허용되는 개체를 열거</td>
    </tr>
    <tr>
      <td><code>kotlin.ranges.*</code></td>
      <td><code>if</code> 문이나 <code>for</code> 문에서 사용할 범위 관련 요소</td>
    </tr>
    <tr>
      <td><code>kotlin.io.*</code></td>
      <td>입출력 관련 API</td>
    </tr>
    <tr>
      <td><code>kotlin.collections.*</code></td>
      <td><code>List, Set, Map</code> 등의 collection</td>
    </tr>
    <tr>
      <td><code>kotlin.annotation.*</code></td>
      <td>주석 관련 API</td>
    </tr>
  </table>
  <sub>별표(*)는 해당 package에 포함된 모든 요소를 의미한다.</sub>
  <h4>IntelliJ 단축키</h4>
  <ul>
    <li style="line-height: 1.5rem;"><kbd>Ctr</kbd> + <kbd>B</kbd> : 선택한 class나 함수의 source file을 찾아 보여준다.</li>
    <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F10</kbd> : 현재 file 실행하기</li>
  </ul>
  <h3 class="title">사용자 class 가져오기</h3>
  <pre>
package com.example.edu.Person

class Person(val name: String, val age: Int) { ... }</pre>
  <pre>
package chap02.section1

// 같은 이름의 class가 있을 때 as 로 별명을 지정 할 수 있다.
<strong>import</strong> com.example.edu.Person <strong>as</strong> <span style="color:gold;">User</span>

fun main(args: Array&lt;String&gt;) {
    val user1 = <span style="color:gold;">User</span>("Kildong", 30)
    println(user1.name)
    println(user1.age)

    // 이 package에 선언된 Person
    val user2 = Person("A123", "Kildong") 
    println(user2.id)
    println(user2.name)
}

class Person(val id: String, val name: String) { ... }</pre>
  <h2 class="title"><span class="titleNumber">02-2</span>변수와 자료형</h2>
  <h3 class="title">변수를 선언하고 자료형 추론하기</h3>
  <ul>
    <li><code><strong>val</strong></code>ue : 읽기 전용, 변경 불가 변수</li>
    <li><strong><code>var</code></strong>iable : 변경 가능 변수</li>
  </ul>
  <h4>변수 이름 짓기 규칙</h4>
  <ul>
    <li>영문자, 숫자, _ 만 사용할 수 있다.</li>
    <li>숫자로 시작할 수 없다.</li>
    <li>keyword는 사용할 수 없다.</li>
    <li>여러 단어로 구성된 이름은 소문자로 시작하는 낙타표기법을 사용하면 좋다.<br>
      예) <code>lowerCamelCase</code></li>
  </ul>
  <h4>변수를 선언하는 방법</h4>
  <table>
    <tr>
      <th>방법</th>
      <th>설명</th>
    </tr>
    <tr>
      <td><code>val username: String = "Kildong"</code></td>
      <td>선언 keyword 변수이름: 자료형 = 값</td>
    </tr>
    <tr>
      <td><code>val username = "Kildong"</code></td>
      <td>초기화 값을 보고 자료형을 추론한다.
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> : 추론한 자료형을 알려준다.
      </td>
    </tr>
    <tr>
      <td><code>val username</code></td>
      <td><span class="material-icons red">warning</span> 초기값이 없어서 자료형을 추론하지 못한다.</td>
    </tr>
    <tr>
      <td><code>val username: String</code></td>
      <td>이런 경우 자료형을 반드시 지정해야 한다.</td>
    </tr>
  </table>
  <h3 class="title">자료형 알아보기</h3>
  <h4>Kotlin의 자료형은 <strong>참조형</strong>을 사용한다</h4>
  <ul>
    <li>Primitive Data Type (기본형)</li>
    <li>Reference Type (참조형)<br>
      객체를 생성하고 heap<sub>(동적 memory 영역)</sub>에 data를 저장한 후 이것을 참조하는 자료형.<br>
      <small>(* Kotlin에서 참조형은 성능 최적화를 위해 컴파일러에서 다시 기본형으로 대체된다.)</small>
    </li>
  </ul>
  <h4>기본형과 참조형의 동작 원리</h4>
  Java에서 기본형은 stack에 값이 저장되고 참조형은 참조하는 객체가 heap에 저장되고 그 주소가 stack에 저장된다.
  <h4>정수 자료형</h4>
  <table class="center">
    <caption>부호가 있는 정수 자료형<sub>signed</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">정수 자료형</td>
      <td><code>Byte</code></td>
      <td>8</td>
      <td>-2<sup> 7</sup> ~ 2<sup> 7</sup>-1</td>
    </tr>
    <tr>
      <td><code>Short</code></td>
      <td>16</td>
      <td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>
    </tr>
    <tr>
      <td><code>Int</code></td>
      <td>32</td>
      <td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>
    </tr>
    <tr>
      <td><code>Long</code></td>
      <td>64</td>
      <td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>
    </tr>
  </table>
  <pre>
val a = 123               // 10진수 표현
val b = 123<strong>L</strong>	          // Long 형으로 추론
val c = <strong>0x</strong>0F	          // 16진수 표현
val d = <strong>0b</strong>00001111	  // 2진수 표현</pre>
  보통 숫자값은 <code>Int</code>형으로 추론되기 때문에 좀 더 작은 범위의 정수 자료형인 <code>Byte</code>형이나 <code>Short</code>형을 사용하기 위해서는 <strong>직접</strong> 자료형을 명시해야 한다.
  <p />
  <table class="center">
    <caption>부호가 없는 정수 자료형<sub>unsigned</sub></caption>
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="4">부호 없는<br>정수 자료형</td>
      <td><code>UByte</code></td>
      <td>8</td>
      <td>0 ~ 2<sup> 8</sup>-1</td>
    </tr>
    <tr>
      <td><code>UShort</code></td>
      <td>16</td>
      <td>0 ~ 2<sup>16</sup>-1</td>
    </tr>
    <tr>
      <td><code>UInt</code></td>
      <td>32</td>
      <td>0 ~ 2<sup>32</sup>-1</td>
    </tr>
    <tr>
      <td><code>ULong</code></td>
      <td>64</td>
      <td>0 ~ 2<sup>64</sup>-1</td>
    </tr>
  </table><br>
  부호 없는 자료형에는 <strong>u</strong> 식별자를 사용해야 한다. 없으면 값을 할당할 수 없다.<br>
  <pre>
val a: UInt = 153<strong>u</strong>
val b: ULong = 46322342<strong>uL</strong></pre><br>
  <strong>_</strong>로 자리값을 구분할 수 있다. 값에 영향을 주지 않는다.
  <pre>
val million = 1_000_000
val cardNumber = 1234_1234_1234_1234
val hexVal = 0xAB_CD_EF_12
val binary = 0b1010_0101</pre>
  <h4>실수 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<br><small>(Bits)</small></th>
      <th>값의 범위</th>
    </tr>
    <tr>
      <td rowspan="2">실수 자료형</td>
      <td><code>Float</code></td>
      <td>32</td>
      <td>약 1.4E<sup>-45</sup> ~ 3.4E<sup>+38</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
    <tr>
      <td><code>Double</code></td>
      <td>64</td>
      <td>약 4.9E<sup>-324</sup> ~ 1.7E<sup>+308</sup> <small>(IEEE 754 표준)</small></td>
    </tr>
  </table>
  <ul>
    <li>실수도 자료형을 명시하지 않으면 <code>Double</code>형으로 추론된다.</li>
    <li><code>Float</code>형으로 지정하고 싶다면 식별자 <strong>F</strong>를 값 뒤에 붙이면 된다.</li>
  </ul>
  <pre>
val a = 3.14	// Double형으로 추론. 기본
val b = 3.14<strong>F</strong>	// Float형으로 추론.</pre>
  <table>
    <tr>
      <th>일반 수학의 표현</th>
      <th>Source code상의 표현</th>
    </tr>
    <tr>
      <td>3.14<sub>가수</sub> x 10<sub>밑수</sub><sup>16<sub>지수</sub></sup></td>
      <td>3.14<sub>(소수점이 없을 수도 있다.)</sub>E<sub>(또는 e)</sub> +<sub>(- 또는 +, +는 생략 가능)</sub> 16</td>
    </tr>
  </table>
  <pre>
val exp1 = 3.14E-2 // 0.0314
val exp2 = 3.14e2  // 314
</pre>
  <h4>부동 소수점 제대로 이해하기<small>(IEEE 754 표준)</small></h4>
  <p><span class="material-icons red" style="float:left">info</span>지수부에 저장되는 값은 <strong>(지수 bias + 실제 지수 값)</strong> 이다.<br>
    <sub>값이 2의 보수로 저장 되는데 이 때 음수값의 비교를 쉽게 하기위해 지수 bias를 적용해 양수값으로 저장되게 한다.</sub>
  </p>
  <table class="center number">
    <caption>32 bits Float (지수 bias : 2<sup>7</sup>-1 = 127)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 8 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 23 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>31</td>
      <td>30...23</td>
      <td>22...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b0000_0001 ~ 0b1111_1110 : 실제 지수값 범위: -126 ~ 127</li>
          <li>0b1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table><br>
  <table class="center number">
    <caption>64 bits Float (지수 bias : 2<sup>10</sup>-1 = 1023)</caption>
    <tr>
      <th></th>
      <th>부호 <sub>1 bit</sub></th>
      <th>지수 <sub>exponent, 11 bits</sub></th>
      <th>가수 <sub>fraction or mantissa, 52 bits</sub></th>
    </tr>
    <tr>
      <th>Bit 번호</th>
      <td>63</td>
      <td>62...52</td>
      <td>51...0</td>
    </tr>
    <tr>
      <th>값</th>
      <td>0 : 양수<br>1 : 음수</td>
      <td style="text-align: left;">
        <ul>
          <li>0 : 비정규화값 <sub>denormalized number</sub><br>가장 작은 일반 숫자보다 더 작은 0이 아닌 값.</li>
          <li>0b000_0000_0001 ~ 0b111_1111_1110 : 실제 지수값 범위: -1022 ~ 1023</li>
          <li>0b111_1111_1111 : 무한대값</li>
        </ul>
      <td></td>
    </tr>
  </table>
  <h4>정수값을 2진수로 표현하기</h4>
  <ul>
    <li>정수값을 2로 나누어 나머지를 취한다.</li>
    <li>몫을 다음 정수값으로 사용한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>나머지</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>10 ÷ 2 = 5, 0</td>
      <td>0</td>
      <td rowspan="4">low<br><span class="material-icons">arrow_upward</span><br>hi</td>
    </tr>
    <tr>
      <td>5 ÷ 2 = 2, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2 ÷ 2 = 1, 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1 ÷ 2 = 0, 1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10<sub>10</sub></th>
      <th colspan="2">1010<sub>2</sub></th>
    </tr>
  </table><br>
  <h4>소수값을 2진수로 표현하기</h4>
  <ul>
    <li>소수값에 2를 곱한 결과값에서 정수 부분을 취한다.</li>
    <li>다음 소수값은 이 정수 값을 뺀 값으로 한다.</li>
  </ul>
  <table class="center number">
    <tr>
      <th></th>
      <th>정수부</th>
      <th>자리순서</th>
    </tr>
    <tr>
      <td>0.375 x 2 = 0.75</td>
      <td>0</td>
      <td rowspan="3">hi<br><span class="material-icons">arrow_downward</span><br>low</td>
    </tr>
    <tr>
      <td>(0.75 - 0) x 2 = 1.5</td>
      <td>1</td>
    </tr>
    <tr>
      <td>(1.5 - 1) x 2 = 1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0.375<sub>10</sub></th>
      <th colspan="2">0.011<sub>2</sub></th>
    </tr>
  </table><br>
  <span class="material-icons red">info</span>정수부는 항상 1이 되게 정규화한 후 값을 저장한다.
  <pre>
예) -12.375<sub>10</sub>를 32bits의 float 형식으로 표현하면 음수이므로 부호 bit는 1이고,
절댓값 12.375<sub>10</sub>의 2진수는 1100.011<sub>2</sub>이다.
이 값을 정수부가 항상 1이 되게 정규화 하면 1.100011 x 2<sup>3</sup>이 된다.
항상 1인 정수부를 제외한 소수부 100011<sub>2</sub>만 가수부에 저장한다. 뒤쪽엔 0으로 채운다.
지수부는 (3 + 127<sub>지수 bias 값</sub>)인 130<sub>10</sub>의 2진수인 10000010<sub>2</sub>를 저장한다.
<div style="font-size: 1.5rem;">
<span style="background:#a11; padding:.3rem">1</span><span style="background:#191; padding:.3rem">10000010</span><span style="background:#77f; padding:.3rem">10001100000000000000000</span>
</div>
</pre><br>
  부동소수점을 사용할 때는 오차에 주의해야 한다.
  <pre>
fun main() {
  var num = 0.0
  for (i in 1..10)
      num += 0.1

  println(num) // 0.9999999999999999 <span class="material-icons red">warning</span>1.0이 아니다!
}</pre>
  <h4>정수 자료형과 실수 자료형의 최솟값과 최댓값 알아보기</h4>
  각 자료형에 <strong><code>MIN_VALUE, MAX_VALUE</code></strong> 상수가 정의되어 있다.
  <h4>2의 보수</h4>
  <table class="number">
    <caption>음수는 2의 보수로 표현한다.</caption>
    <tr>
      <th>0b0000_0001</th>
      <td>+1</td>
    </tr>
    <tr>
      <th>0b1111_1110</th>
      <td>1의 보수는 각 bit를 반대로 하면 된다.</td>
    </tr>
    <tr>
      <th>0b1111_1111</th>
      <td>1의 보수에 +1를 하면 2의 보수가 된다. -1</td>
    </tr>
  </table>
  <small>(* 컴퓨터는 뺄셈을 2의 보수와의 합으로 계산한다.)</small>
  <h4>논리 자료형</h4>
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>논리 자료형</td>
      <td>Boolean</td>
      <td>1<sub>Java에서</sub></td>
      <td>true, false</td>
    </tr>
  </table>
  <pre>
val isOpen = true       // Boolean으로 추론
val isUploaded: Boolean // 선언만 한 경우 자료형을 반드시 명시</pre>
  <h4>문자 자료형</h4>
  문자를 작은따옴표(')로 감싸 표현한다.
  <table class="center">
    <tr>
      <th>형식</th>
      <th>자료형</th>
      <th>크기<small>(Bits)</small></th>
      <th>값</th>
    </tr>
    <tr>
      <td>문자 자료형</td>
      <td>Char</td>
      <td>16</td>
      <td>0 ~ 2<sup>15</sup>-1 (\u0000 ~ \uffff)</td>
    </tr>
  </table>
  <pre>
val ch = 'A'
val ch1: Char

println(ch + 1) // 'B'

val ch2: Char = 65 // error!

val code: Int = 65
val ch3 = code.<strong>toChar()</strong> // 'A'

val ch4 = '<strong>\u</strong>D55C' // unicode '한'
</pre>
  <h3 class="title">문자열 자료형(<strong>String</strong>) 알아보기</h3>
  문자 자료형인 Char은 기본형으로 처리되지만, 문자열 자료형은 기본형에 속하지 않는 배열 형태로 되어 있는 특수한 자료형이다.<br>
  <h4>문자열 자료형 선언과 저장 방식 이해하기</h4>
  <pre>
fun main() {
  val str1: String = "Hello"
  val str2 = "World"
  val str3 = "Hello"

  // === : 참조 비교. 객체의 주소를 비교한다.
  println("str1 === str2 is ${str1 === str2}")
  println("str1 === str3 is ${str1 === str3}")
}
<hr>>>
str1 === str2 is false
str1 === str3 is true</pre>
  <table>
    <tr>
      <table style="background-color:lightgray;text-align: center; border-collapse: separate;">
        <caption style="caption-side: bottom;">Heap</caption>
        <tr>
          <td style="border:none">
            <table style="border:none">
              <caption style="caption-side: bottom">&nbsp;</caption>
              <tr>
                <th style="border:none">A1<span class="material-icons">arrow_forward</span></th>
              </tr>
              <tr>
                <th style="border:none">A2<span class="material-icons">arrow_forward</span></th>
              </tr>
            </table>
          </td>
          <td>
            <table>
              <tr>
                <table style="background-color:whitesmoke;width:7rem; border-collapse: separate; border:1px dashed black">
                  <tr>
                    <td style="background-color: gray;">Hello</td>
                  </tr>
                  <tr>
                    <td style="background-color: gray;">World</td>
                  </tr>
                  <tr>
                    <td style="width:fit-content; border:none;">String Pool</td>
                  </tr>
                </table>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </tr><br>
    <tr>
      <table style="border: none;">
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str3</td>
        </tr>
        <tr>
          <td>주소: A2</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str2</td>
        </tr>
        <tr>
          <td>주소: A1</td>
          <td style="border: none;"><span class="material-icons">arrow_back</span> str1</td>
        </tr>
        <tr>
          <td style="text-align: center; border:none">Stack</td>
          <td style="border:none"></td>
        </tr>
      </table>
    </tr>
  </table>
  String 형 선언 및 할당에 사용되는 memory는 <strong>String Pool</strong>이다.<br>
  <h4>표현식과 <strong><code>$</code></strong> 기호 사용하여 문자열 출력하기</h4>
  <pre>
val a = 1
val s1 = "a is <strong>$a</strong>"             // a is 1
val s2 = "(a + 1) is <strong>${a + 1}</strong>" // (a + 1) is 2</pre>
  변수가 아니라 표현식을 문자열에 포함하려면 <strong><code>{}</code></strong> 를 사용한다.<br>
  Escape 문자 <strong><code>\</code></strong>를 사용해 문자열 안에 ", $를 표시할 수 있다.
  <pre>
val str = "<strong>\"</strong>hello\", I have <strong>\$</strong>15"
val str2 = "${'"'}hello${'"'}, I have ${'$'}15"
<hr>>>
"hello", I have $15
</pre>
  <h4>형식화된 다중 문자열 사용하기</h4>
  <pre>
val str5 = <strong>"""</strong>
    abc
        abc
            abc<strong>"""</strong>
println(str5)
<hr>>

    abc
        abc
            abc</pre>

  <h4>자료형에 별명 붙이기</h4>
  <pre>
<strong>typealias</strong> UserName = String
val userName: UserName = "Peter"</pre>
  <h2 class="title"><span class="titleNumber">02-3</span>자료형 검사하고 변환하기</h2>
  <ul>
    <li>변수를 사용할 때 반드시 값이 할당되어 있어야 한다.</li>
    <li>값이 없는 상태를 <strong>null</strong> 이라고 한다.</li>
    <li>null 상태인 변수를 허용하려면 <strong>?</strong>를 사용해 선언한다.<br>
      이 변수를 사용하려면 null을 검사하고 처리하는 방법을 고려해야 한다.</li>
  </ul>
  <h3 class="title">null을 허용한 변수 검사하기</h3>
  프로그램 실행 중 값이 null인 변수에 접근하면 NPE<sub>(Null Point Exception)</sub> 예외 오류가 발생한다.
  <h4>변수에 null 할당하기</h4>
  <pre>
fun main() {
  var str: String = "Hello"
  str = null // <span class="red">Error!</span>
  
  var str2: String<strong>?</strong> = "World"
  str2 = null // <span style="color:#0f0">OK</span>
}</pre>
  <h4>Safe call(<strong>?.</strong>)과 non-null 단정 기호(<strong>!!.</strong>)를 활용하여 null을 허용한 변수 사용하기</h4>
  <ul>
    <li>Safe call : null일 수 있는 변수를 검사하여 안전하게 호출할 수 있도록 도와준다.
      <pre>
// str2가 유효한 문자열이면 문자열의 길이, str2가 null 이면 null을 return 한다.
val length = str2<strong>?.</strong>length</pre>
    </li>
    <li>non-null 단정 : compile 때 null 검사를 하지 않는다. 하지만 값이 null 이면 실행시에 NPE가 발생한다.</li>
  </ul>
  <h4>조건문을 활용해 null을 허용한 변수 검사하기</h4>
  <pre>val length = if (str2 != null) str2.length else -1</pre>
  <h4>Safe call과 Elvis 연산자(<strong>?:</strong>)를 활용해 null을 허용한 변수 더 안전하게 사용하기</h4>
  <pre>val length = str2?.length <strong>?:</strong> -1</pre>
  <h3 class="title">자료형 비교하고 검사하고 변환하기</h3>
  자료형이 서로 다른 변수를 비교하거나 연산할 수 없다.
  <h4>자료형 변환</h4>
  <pre>
val a: Int = 1
val b: Double = a // <span class="red">Type mismatch error!</span>
val c: Int = 1.1  // <span class="red">Type mismatch error!</span>

// 변환 method 사용
val d: Double = a.toDouble() // <span style="color:#0f0">OK</span>

// 표현식에서는 자료형이 표현할 수 있는 범위가 큰 자료형으로 자동 형 변환하여 연산한다.
val result = 1L + 3 // Long형 + Int형 -> result는 Long형
</pre>
  자료형 변환 method 들
  <ul style="margin-top:0">
    <li>toByte: Byte</li>
    <li>toLong: Long</li>
    <li>toShort: Short</li>
    <li>toInt: Int</li>
    <li>toFloat: Float</li>
    <li>toDouble: Double</li>
    <li>toChar: Char</li>
  </ul>
  <h4>기본형과 참조형 자료형의 비교 원리</h4>
  <ul>
    <li>구조적 동등성(Structural equality). equals()를 이용한 비교
      <ul>
        <li>==, !=</li>
        <li>a == b 는 다음으로 해석된다.
          <pre>a?.equals(b) ?: (b === null)</pre>
        </li>
        <li>a가 null이 아니면 equals(Any?) 함수를 호출하고, null이면 b가 null인지 참조 동등성을 검사한다.</li>
        <li>a == null은 명시적으로 a === null로 자동으로 변환된다.</li>
        <li>사용자 정의로 같음을 구현하려면 <strong><code>open operator fun equals(other: Any?): Boolean</code></strong>를 overriding 하면된다.</li>
        <li>Comparable&lt;...> interface에서 정의된 비교와는 상관 없다.</li>
      </ul>
    </li>
    <li>참조 동등성(Referential equality). 두 개의 참조가 같은 객체를 가리키는지 비교
      <ul>
        <li>===, !==</li>
        <li>a === b는 a와 b가 같은 객체를 가리킬 때만 true이다.</li>
        <li>기본형의 === 비교는 == 비교와 같다.</li>
      </ul>
    </li>
  </ul>
  <span class="material-icons red" style="float:left">info</span>저장되는 값이 -128~127 사이의 값이면 cache에 저장되어 참조된다.<br>
  이 경우 기본형이 stack에 값으로 저장되지 않고 값이 저장된 cache의 주소를 참조하게 된다.
  <h4>Smart Cast 알아보기</h4>
  <ul>
    <li>Compiler가 자동으로 형 변환을 해주는 것이다.</li>
    <li><strong>Number</strong> 자료형에 적용된다.
      <pre>
fun main() {
  val a: <strong>Number</strong> = 3.14

  println(a is Number) // true
  println(a is Double) // true
  println(a is Float)  // false
}</pre>
    </li>
  </ul>
  <h4>자료형 검사하기 <strong>is, !is</strong></h4>
  is는 변수의 자료형을 검사한 다음 그 변수를 해당 자료형으로 변환하는 기능도 있다.
  <pre>
fun main() {
  val x: <strong>Any</strong> // 임의의 자료형
  x = "Hello"

  if (x <strong>is</strong> String) {
      println(x.length) // x는 String으로 smart cast 된다.
  }
}</pre>
  <h4><strong>as</strong>에 의한 Smart Cast</h4>
  as는 형 변환이 불가능하면 예외를 발생시킨다.
  <pre>
// y가 null 이거나 String으로 형 변환이 불가능하면 예외 발생.
val x: String = y as String 

// y가 null 이거나 String으로 형 변환이 불가능하면 null을 return.
val x: String<strong>?</strong> = y <strong>as?</strong> String</pre>
  <h4>묵시적 변환</h4>
  <ul>
    <li><strong>open class Any</strong>는 최상위 class 이다.</li>
    <li>Any형은 자료형이 특별히 정해지지 않은 경우에 사용한다.</li>
    <li>Any형은 무엇이든 될 수 있기 때문에 언제든 필요한 자료형으로 자동 변환할 수 있다.(묵시적 변환)</li>
    <li></li>
  </ul>
  <pre>
fun main() {
  var a: Any = 1 // Int형
  a = 20L        // Long 형

  println("a is $a, type is ${a.<strong>javaClass</strong>}") // .javaClass: Java 기본형을 출력
}
<hr>>> a is 20, type is class java.lang.Long</pre>
  <h2 class="title"><span class="titleNumber">02-4</span>코틀린 연산자</h2>
  <h3 class="title">기본 연산자</h3>
  <h4>수식의 구조</h4>
  <code>
  <table style="text-align: center;" class="no-border">
    <tr>    
      <td colspan="3"></td>
      <td colspan="3">표현식</td>
    </tr>
    <tr>
      <td colspan="3"></td>
      <td style="background-color: lightgray;">항</td>
      <td style="background-color: lightgray;"></td>
      <td style="background-color: lightgray;">항</td>
    </tr>
    <tr style="font-size: 1.3rem;">
      <td colspan="2">val result</td>
      <td>=</td>
      <td style="background-color: lightgray;border:1px solid red">num1</td>
      <td style="background-color: lightgray;">+</td>
      <td style="background-color: lightgray;border:1px solid red">num2</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td><sub>대입<br>이항 연산자</sub></td>
      <td></td>
      <td><sub>덧셈<br>이항 연산자</sub></td>
      <td></td>
    </tr>
  </table></code>
  <h4>산술 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>+</td>
      <td>덧셈</td>
    </tr>
    <tr>
      <td>-</td>
      <td>뺄셈</td>
    </tr>
    <tr>
      <td>*</td>
      <td>곱셈</td>
    </tr>
    <tr>
      <td>/</td>
      <td>나눗셈</td>
    </tr>
    <tr>
      <td>%</td>
      <td>나머지 <sub>Modulus</sub></td>
    </tr>
  </table>
  <h4>대입 연산자 =</h4>
  변수에 값을 할당하는 연산자. 이항 연산자 중 우선순위가 가장 낮다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col">의미</th>
    </tr>
    <tr>
      <td>=</td>
      <td>a = b</td>
    </tr>
    <tr>
      <td>+=</td>
      <td>a += b, a = a + b</td>
    </tr>
    <tr>
      <td>-=</td>
      <td>a -= b, a = a - b</td>
    </tr>
    <tr>
      <td>*=</td>
      <td>a *= b, a = a * b</td>
    </tr>
    <tr>
      <td>/=</td>
      <td>a /= b, a = a / b</td>
    </tr>
    <tr>
      <td>%=</td>
      <td>a %= b, a = a % b</td>
    </tr>
  </table>
  <h4>증가 연산자와 감소 연산자</h4>
  단항 연산자
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
      <th scope="col" colspan="2">의미</th>
    </tr>
    <tr>
      <td rowspan="2">++</td>
      <td>b = a++</td>
      <td>b = a, a = a + 1</td>
    </tr>
    <tr>
      <td>b = ++a</td>
      <td>a = a + 1, b = a</td>
    </tr>
    <tr>
      <td rowspan="2">--</td>
      <td>b = a--</td>
      <td>b = a, a = a - 1</td>
    </tr>
    <tr>
      <td>b = --a</td>
      <td>a = a - 1, b = a</td>
    </tr>
  </table>
  <h4>비교 연산자</h4>
  결과 값은 true 또는 false 이다.
  <table style="text-align: center;">
    <tr>
      <th scope="col">연산자</th>
    </tr>
    <tr>
      <td>>, >=, &lt;, &lt;=</td>
    </tr>
    <tr>
      <td>==, !=</td>
    </tr>
    <tr>
      <td>===, !==</td>
    </tr>
  </table>
  <h4>논리 연산자</h4>
  <table style="text-align: center;">
    <tr>
      <th>연산자</th>
      <th>의미</th>
    </tr>
    <tr>
      <td>&&</td>
      <td>AND</td>
    </tr>
    <tr>
      <td>||</td>
      <td>OR</td>
    </tr>
    <tr>
      <td>!</td>
      <td>NOT</td>
    </tr>
  </table>
  <span class="material-icons red">info</span>단축평가 <sub>Short Circuit Evaluation</sub>
  <pre>
// a 가 true 라면 b는 검사하지 않고 true를 return 한다.    
val x = a || b 

// a 가 false 라면 b는 검사하지 않고 false를 return 한다.
val y = a && b </pre>
  <h3 class="title">Bit 연산자</h3>
  <h4>Bit와 Bit 연산</h4>
  <h4>Bit 연산을 위한 Bit Method</h4>
  <pre>
val x = 4.shl(1)  // 함수 호출 형식
val y = 4 shl 1   // 중위 표현식. infix</pre>
<code>
  <table>
    <caption>class Int의 Bit 연산자</caption>
    <tr>
      <th scope="col">예시</th>
      <th scope="col" colspan="2">설명</th>
    </tr>
    <tr>
      <td><code>shl(bits)</code></td>
      <td>shift left. 왼쪽으로 bits 만큼 이동. 부호 있음</td>
      <td rowspan="2">사라진 bit는 0으로 채우고 부호 bit는 그대로 둔다.</td>
    </tr>
    <tr>
      <td><code>shr(bits)</code></td>
      <td>shift right. 오른쪽으로 bits 만큼 이동. 부호 있음</td>
    </tr>
    <tr>
      <td><code>ushr(bits)</code></td>
      <td>unsigned shift right. 오른쪽으로 bits 만큼 이동. 부호 없음</td>
      <td>제일 왼쪽 bit에 0을 채운다.</td>
    </tr>
    <tr>
      <td><code>and(bits)</code></td>
      <td>bits와 논리곱 연산</td>
      <td>0b1100 and<br>0b1010<hr>0b1000</td>
    </tr>
    <tr>
      <td><code>or(bits)</code></td>
      <td>bits와 논리합 연산</td>
      <td>0b1100 or<br>0b1010<hr>0b1110</td>
    </tr>
    <tr>
      <td><code>xor(bits)</code></td>
      <td>bits와 배타적 연산</td>
      <td>0b1100 xor<br>0b1010<hr>0b0110</td>
    </tr>
    <tr>
      <td><code>inv()</code></td>
      <td>모든 bit를 반대로 한다. invert</td>
      <td>1.inv() == -2</td>
    </tr>
  </table></code>
  <span class="material-icons red">info</span>IntelliJ Debug 관련 단축키
  <ul style="line-height: 1.5rem;margin-top:0rem;">
    <li><kbd>Ctrl </kbd>+<kbd>F8</kbd> : Break Point Toggle 설정</li>
    <li><kbd>Shift</kbd>+<kbd>F9</kbd> : Debugging Run</li>
    <li><kbd>F8</kbd> : Step Over. 한 줄씩 실행.</li>
    <li>Debug > Variables 창에 있는 변수를 선택한 후 Pop-up menu에서 <strong>View As > Binary</strong>를 선택하면 2진수로 값을 볼 수 있다.</li>
  </ul>
  <span class="material-icons red">info</span>xor 3번으로 두 값 swap 하기
  <pre>
fun main() {
  var a = 12
  var b = 25

  a = a xor b
  b = a xor b
  a = a xor b

  println(a) // 25
  println(b) // 12
}</pre>
  <hr>
  <h1><span class="titleNumber">03</span>함수와 함수형 프로그래밍</h1>
  <h2 class="title"><span class="titleNumber">03-1</span></h2>
  <h2 class="title"><span class="titleNumber">03-2</span></h2>
  <h2 class="title"><span class="titleNumber">03-3</span></h2>
  <h2 class="title"><span class="titleNumber">03-4</span></h2>
  <h2 class="title"><span class="titleNumber">03-5</span></h2>
  <h2 class="title"><span class="titleNumber">03-6</span></h2>
  <h1><span class="titleNumber">04</span>프로그램의 흐름 제어</h1>
  <h2 class="title"><span class="titleNumber">04-1</span></h2>
  <h2 class="title"><span class="titleNumber">04-2</span></h2>
  <h2 class="title"><span class="titleNumber">04-3</span></h2>

  <p id="end">END</p>
</body>

</html>